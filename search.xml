<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分布式锁]]></title>
    <url>%2FmyBlog%2F2018%2F11%2F10%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[什么是锁为了实现多个线程在同一时刻同一代码块只能有一个线程可执行，需要在某个地方做标记，这个标记必须满足所有的线程可见，标记不存在的时候设置标记，后续的线程发现已标记则等待拥有标记的线程结束，同步代码块取消标记后，在尝试设置标记，这个标记可以理解为锁。 什么是分布式锁单体单机部署的系统被演化成分布式集群系统后，系统可能会有多份并且部署在不同的机器上，这些资源已经不是在线程之间共享了，而是属于进程之间共享的资源。指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。 分布式的 CAP 理论： 任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。 分布式锁要满足哪些要求呢 互斥性：在任意时刻，只有一个客户端能持有锁。 不会发生死锁：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。 容错性：获取或释放锁的机制必须高可用且性能佳 解铃还须系铃人：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。 分布式锁实现方式为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。 基于数据库实现分布式锁；基于缓存（Redis等）实现分布式锁；基于Zookeeper实现分布式锁； 基于数据库思路：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。 基于Redis1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Collections;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;public class XttblogLock &#123; private static final String LOCK_SUCCESS = "OK"; private static final String SET_IF_NOT_EXIST = "NX"; private static final String SET_WITH_EXPIRE_TIME = "PX"; private static final Long RELEASE_SUCCESS = 1L; private static void validParam(JedisPool jedisPool, String lockKey, String requestId, int expireTime) &#123; if (null == jedisPool) &#123; throw new IllegalArgumentException("jedisPool obj is null"); &#125; if (null == lockKey || "".equals(lockKey)) &#123; throw new IllegalArgumentException("lock key is blank"); &#125; if (null == requestId || "".equals(requestId)) &#123; throw new IllegalArgumentException("requestId is blank"); &#125; if (expireTime &lt; 0) &#123; throw new IllegalArgumentException("expireTime is not allowed less zero"); &#125; &#125; public static boolean tryLock(JedisPool jedisPool, String lockKey, String requestId, int expireTime) &#123; validParam(jedisPool, lockKey, requestId, expireTime); Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime); if (LOCK_SUCCESS.equals(result)) &#123; return true; &#125; &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; if (null != jedis) &#123; jedis.close(); &#125; &#125; return false; &#125; public static boolean unLock(JedisPool jedisPool, String lockKey, String requestId) &#123; validParam(jedisPool, lockKey, requestId, 1); String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); Object result = jedis.eval(script, Collections.singletonList(lockKey),Collections.singletonList(requestId)); if (RELEASE_SUCCESS.equals(result)) &#123; return true; &#125; &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; if (null != jedis) &#123; jedis.close(); &#125; &#125; return false; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.concurrent.TimeUnit;import org.redisson.Redisson;import org.redisson.core.RLock;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class RedissonLockUtil &#123; private static final Logger logger = LoggerFactory.getLogger(RedissonLockUtil.class); private static Redisson redisson = RedissonManager.getRedisson(); private static final String LOCK_FLAG = "recruitlock_"; /** * 根据name对进行上锁操作，redissonLock 阻塞的，采用的机制发布/订阅 * @param key */ public static void lock(String key)&#123; String lockKey = LOCK_FLAG + key; RLock lock = redisson.getLock(lockKey); //lock提供带timeout参数，timeout结束强制解锁，防止死锁 ：1分钟 lock.lock(1, TimeUnit.MINUTES); logger.info("lock key:&#123;&#125;",lockKey); &#125; /** * 根据name对进行解锁操作 * @param key */ public static void unlock(String key)&#123; String lockKey = LOCK_FLAG + key; RLock lock = redisson.getLock(lockKey); if (lock.isHeldByCurrentThread()) &#123; lock.unlock(); logger.info("unlock , key:&#123;&#125;"+lockKey); &#125; &#125; /** * @param key * @param millisToWait 等待获取锁的时间--单位：秒 */ public static boolean tryLock(String key, long millisToWait) &#123; String lockKey = LOCK_FLAG + key; logger.info("get redis lock start , key:&#123;&#125;"+lockKey); RLock lock = redisson.getLock(lockKey); logger.info("get redis lock end , key:"+lockKey); try &#123; return lock.tryLock(millisToWait,5000, TimeUnit.MILLISECONDS); &#125; catch (Exception e) &#123; logger.error("try lock error,key is:&#123;&#125;", lockKey, e); &#125; logger.info("get redis lock false , key:"+lockKey); return false; &#125;&#125; 错误示例12345Long result = jedis.setnx(lockKey, requestId); if (result == 1) &#123; // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁 jedis.expire(lockKey, expireTime); &#125; https://www.cnblogs.com/seesun2012/p/9214653.html http://www.cnblogs.com/linjiqin/p/8003838.html https://www.xttblog.com/?p=3171]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring+Shiro+Redis实践]]></title>
    <url>%2FmyBlog%2F2018%2F08%2F08%2FSpring%2BShiro%2BRedis%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Apache Shiro是Java的一个安全框架。使用Spring+Shiro+Redis完成登录注册，权限认证的功能。 Subject本质上就是当前访问用户的抽象描述。所有 参考张开涛《跟我学Shiro教程》]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试常用手写代码]]></title>
    <url>%2FmyBlog%2F2017%2F10%2F12%2F%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[快速排序123456789101112131415161718192021222324252627int a[10],n;void quickSort(int left,int right)&#123; int i,j,t,temp; if(left &gt;right)&#123; return; &#125; temp=a[left]; i=left; j=right; while(i!=j)&#123; while(a[j]&gt;=temp&amp;&amp;i&lt;j)&#123; j--; &#125; while(a[i]&gt;=temp&amp;&amp;i&lt;j)&#123; i++; &#125; if(i&lt;j)&#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; a[left]=a[i]; a[i]=temp; quicpSort(left,i-1); quickSort(i+1,right);&#125; 单例模式volatile 的一个语义禁止指令重排优化。synchronized关键字当两个线程同事进入第一的if判断语句后，线程1获取锁，线程2阻塞在1处，线程1 123456789101112131415161718192021public class Singleton &#123; private volatile static Singleton instance=null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if (instance==null)&#123; synchronized(Singleton.class)&#123;//1 if(instance==null)&#123;//2 instance=new Singleton();//3 &#125; &#125; &#125; return instance; &#125;&#125;public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125; 判断链表是否有环123456789101112131415161718typedef struct node&#123; char data ; node * next ; &#125;Node; bool exitLoop(Node *head) &#123; Node *fast, *slow ; slow = fast = head ; while (slow != NULL &amp;&amp; fast -&gt; next != NULL) &#123; slow = slow -&gt; next ; fast = fast -&gt; next -&gt; next ; if (slow == fast) return true ; &#125; return false ; &#125; 单链表反转123456789101112public Node reverse(Node node) &#123; Node prev = null; Node now = node; while (now != null) &#123; Node next = now.next; now.next = prev; prev = now; now = next; &#125; return prev; &#125;]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized关键字]]></title>
    <url>%2FmyBlog%2F2017%2F10%2F01%2Fsynchronized%2F</url>
    <content type="text"><![CDATA[synchronized是一种同步锁同一时刻只能有一个线程能获取到锁 修饰代码块：同步代码块，作用域是{}里面的代码，作用的对象是调用这个代码块的对象。 修饰方法：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。 修饰静态的方法：作用范围是整个方法，作用对象是这个类的所有对象。 修饰类：作用范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。 1.synchronized 代码块12345public void run() &#123; synchronized(obj) &#123; //一次只能有一个线程进入 &#125;&#125; synchronized锁住的是括号里的对象，不是代码。当synchronized锁住一个对象时，别的线程也想拿到这个对象的锁，必须等待这个线程执行完释放锁，才能再次给这个对象加锁。 example 1234567891011121314151617181920212223public class SyncThread implements Runnable &#123; private static int count; public SyncThread() &#123; &#125; @Override public void run() &#123; try &#123; String lock=new String(); synchronized (this) &#123;//1 synchronized (lock) 2//synchronized (SyncThread.class)3 System.out.println(Thread.currentThread().getName()+":a begin"); Thread.sleep(500); System.out.println(Thread.currentThread().getName()+":a end"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789//1,2,3 public static void main(String[] arg)&#123; SyncThread a = new SyncThread(); Thread t1 = new Thread(a); Thread t2 = new Thread(a); t1.start(); t2.start(); &#125; 12345678910//3 public static void main(String[] arg)&#123; SyncThread a = new SyncThread(); SyncThread b = new SyncThread(); Thread t1 = new Thread(a); Thread t2 = new Thread(b); t1.start(); t2.start(); &#125; 1,3输出 t1—:a begin t1—:a end t2—:a begin t2—:a end 2输出 t2—:a begin t1—:a begin t1—:a end t2—:a end 1是对类的当前实例加锁2是对锁特定的实例加锁3是对该类的所有对象都加了锁，该类所有的对象同一把锁。 1.synchronized 方法123456public synchronized void syncAdd() &#123; //4&#125;public static synchronized void syncAdd() &#123; //5&#125; example 12345678910111213141516171819202122232425262728293031323334353637public class SyncThread &#123; public SyncThread() &#123; &#125; public synchronized void isSyncA() &#123; int i = 5; while( i-- &gt; 0)&#123; System.out.println("funA-"+Thread.currentThread().getName() + " : " + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ie)&#123; &#125; &#125; &#125; public synchronized void isSyncB()&#123; int i = 5; while( i-- &gt; 0)&#123; System.out.println("funB-"+Thread.currentThread().getName() + " : " + i); try &#123; Thread.sleep(500); &#125;catch (InterruptedException ie)&#123; &#125; &#125; &#125; public static synchronized void cSync()&#123; int i = 5; while( i-- &gt; 0) &#123; System.out.println("cSync"+Thread.currentThread().getName() + " : " + i); try&#123; Thread.sleep(500); &#125;catch (InterruptedException ie)&#123; &#125; &#125; &#125;&#125; main 1234567891011121314151617181920public static void main(String[] arg)&#123;//4 SyncThread a = new SyncThread(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; a.isSyncA(); &#125; &#125;,"t1"); Thread t2 =new Thread(new Runnable() &#123; @Override public void run() &#123; a.isSyncB(); &#125; &#125;,"t2"); t1.start(); t2.start(); &#125; 输出 funA-t1 : 4 funA-t1 : 3 funA-t1 : 2 funA-t1 : 1 funA-t1 : 0 funB-t2 : 4 funB-t2 : 3 funB-t2 : 2 funB-t2 : 1 funB-t2 : 0 1234567891011121314151617181920public static void main(String[] arg)&#123; //5 SyncThread a = new SyncThread(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; SyncThread.cSync(); &#125; &#125;,"t1"); Thread t2 =new Thread(new Runnable() &#123; @Override public void run() &#123; SyncThread.cSync(); &#125; &#125;,"t2"); t1.start(); t2.start(); &#125; cSynct1 : 4 cSynct1 : 3 cSynct1 : 2 cSynct1 : 1 cSynct1 : 0 cSynct2 : 4 cSynct2 : 3 cSynct2 : 2 cSynct2 : 1 cSynct2 : 0 4是对象锁3,5得到的锁是类的锁 4是防止多线程同时访问这个对象的synchronized方法，（如果这个对象有多个synchronized方法，只要有一个线程访问了一个synchronized方法，其他的线程不能访问这个对象的任一synchronized方法），不同对象的synchronized方法互不影响。 5是防止多线程中不同实例对象同时访问方法，它对类的所有实例起作用。 synchronized的实现原理 1,synchronized代码块 monitorenter //进入同步方法 monitorexit //退出同步方法 2,synchronized方法 ACC_SYNCHRONIZED指明该方法为同步方法 参考]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis归纳]]></title>
    <url>%2FmyBlog%2F2017%2F08%2F18%2FRedis%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[Redis一个基于内存的高性能的key-value数据库。 数据结构：String字符串，Hash字典，List列表，Set集合，SortedSet有序集合。 使用Redis有哪些好处？ (1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) (2) 支持丰富数据类型，支持string，list，set，sorted set，hash (3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 (4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除 2.为什么redis需要把所有数据放到内存中? Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。 3.Redis是单进程单线程的为什么也那么快？ Redis快的主要原因是： 完全基于内存 数据结构简单，对数据操作也简单 使用多路 I/O 复用模型 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。 4.Redis锁的使用。 1234567891011121314151617181920212223242526272829private static Redisson redisson = RedissonManager.getRedisson(); private static final String LOCK_FLAG = "mylock_"; /** * 根据name对进行上锁操作，redissonLock 阻塞的，采用的机制发布/订阅 * @param key */ public static void lock(String key)&#123; String lockKey = LOCK_FLAG + key; RLock lock = redisson.getLock(lockKey); //lock提供带timeout参数，timeout结束强制解锁，防止死锁 ：1分钟 lock.lock(1, TimeUnit.MINUTES); logger.info("lock key:&#123;&#125;",lockKey); &#125; /** * 根据name对进行解锁操作 * @param key */ public static void unlock(String key)&#123; String lockKey = LOCK_FLAG + key; RLock lock = redisson.getLock(lockKey); //如果锁被当前线程持有，则释放 if(lock.isHeldByCurrentThread())&#123; lock.unlock(); logger.info("unlock key:&#123;&#125;",lockKey); &#125; &#125;]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Volatile关键字]]></title>
    <url>%2FmyBlog%2F2017%2F08%2F01%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Volatile 能够保证可见性。 volatile的两大特性：禁止重排序、内存可见性。 并发编程中三大概念：原子性，有序性，可见性。 1.原子性一个操作或者多个操作，要么全部执行并且执行过程中不会被任何一个因素打扰，要么就不会执行。Java中，对于基本数据类型的变量读取和赋值操作是原子的。 1234x=10; //1y=x; //2x++; //3x=x+1; //4 只有1是原子的操作。 2是两个操作，先读取x的值，在把x的值写入工作内存，这两个操作都是原子操作，放在一起就不是原子操作了。 3和4都是先读取x的值，在进行加一的操作，写入新的值。 只有简单的读取、赋值（变量之间赋值不是）才是原子操作。 可以通过synchronized和Lock解决原子性问题。 2.可见性线程之间的可见性，一个线程修改这个变量的值，其他的线程能够立即看到修改的值。 Java中，volatile关键字来保证可见性。被volatile修饰的变量，变量修改的值会立即更新到主存，当其他线程需要读取的时候。就会读取主存的值。 普通变量被修改的时候，什么时候写入主存是不确定的。当其他线程读取的时候可能还是原来的值，因此无法保证可见性。 synchronized和Lock也能保证可见性，能够保证同一时刻只有一个线程获取锁，并且在释放锁之前会将变量修改刷新到主存中。 3.有序性程序执行的顺序按照代码先后执行。 指令重排序不会影响单个线程的执行，会影响到线程并发执行的正确性。 Java中允许编译器和处理器对指令进行重排序，volatile、synchronized和Lock都可以保证有序性， volatile实现原理]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集算法]]></title>
    <url>%2FmyBlog%2F2017%2F07%2F20%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.标记-清除算法最基础的收集算法。分为两个阶段：标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。不足：效率，空间，标记清除后会产生大量不连续的内存碎片。 2.复制算法解决效率问题。将可用的内存按容量分为大小相等的两块，每次只使用一块。当一块用完了，将还存活的对象复制到另一块，然后再把已使用过的内存空间一次清理掉。 3.标记整理算法复制算法有较多复制操作，效率问题。根据老年代的特点，标记过程与标记-清除算法一样，后续操作让所有存活对象都像一端移动，然后直接清理掉边界以外的内存。 4.分代收集算法在新生代中有大批对象死去，少量存活：复制算法。复制成本少。老年代中对象存活率高，没有额外的空间对他进行担保：就必须使用 标记-清理 或 标记-整理 算法回收。 一共有两种算法，一种是引用计数算法，每被引用一次计数器就+1，当引用为0就回收，不过这种算法有一个弊端就是，当对象之间互相引用的时候就永远不会回收，所以用的最多的还是GC ROOTS可达性分析，看对象是否被GC ROOTS引用，那么哪些可以作为GC ROOTS呢？有以下四种：1.栈里面的局部变量表，方法区的2.类静态属性引用的对象3.方法区中常量引用的对象，4.JNI本地变量栈中引用的对象http://www.importnew.com/13493.html]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存分配]]></title>
    <url>%2FmyBlog%2F2017%2F07%2F13%2FJVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1.程序计数器（PCR）可以看做当前线程所执行的字节码的行号指示器。为了线程切换后能够恢复到正确执行位置，每条线程都需要独立的程序计数器。 2.栈（JVM stack）线程私有，生命周期与线程相同。描述的事Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接方法出口。每个方法执行到完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 3.本地方法栈（Native Method Stack）与JVM栈相似，本地方法栈是用的是虚拟机的native方法 4.堆（heap)是Java虚拟机管理内存中最大的一块。是被所有线程共享的一块内存区域，次内存区域唯一目的是存放对象实例，几乎所有的对象及数组都要在这里分配内存。是垃圾回收器管理的主要区域，因此很多时候也被称作“GC堆”。现在收集器采用分代收集算法，所以Java堆还可以细分为：新生代，老年代； 5.方法区（Method）域Java堆一样。是各个线程共享的内存区域，用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。 6.运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件不仅有类的版本，字段，方法，接口描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。 7.直接内存（Direct Memory）不是虚拟机运行数据区的一部分。NIO（New Input/Output）类，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存。通过一个Java堆DirectByteBuffer对象作为这块内存的引用进行操作。显著提高性能，因为避免了Java堆和Native堆来回复制数据。 栈区：每次方法的执行都会有一次栈帧的生成，并且其中有局部变量表。堆区：每次new出来的对象都保存在这儿。本地方法栈：通过C/C++调用系统接口的一些方法。方法区：类的信息 静态变量都在这儿，还有程序计数器]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap归纳总结]]></title>
    <url>%2FmyBlog%2F2017%2F05%2F12%2FHashMap%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结ArrayList和LinkedList （1）ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢 （2）LinkedList以链表形式实现，顺序插入、查找较慢，插入、删除方便 HashMap 了解HashMap吗？ HashMap是一种键值对（Key-Value）形式的存储结构。 key和value都允许为null。 当key重复的时候会覆盖，value允许重复。 是无序的，不会按照put的顺序排序。 是非线程安全的。 HashMap的Entry是一个单向链表 知道HashMap的工作原理吗？ 内部是一个数组，数组元素Node是实现了Map.Entry(hash,key,value,next)，next非null的时候指向定位相同的另一个Entry。 使用put()传递键和值，先对键调用hashCode()方法，通过hashCode确定bucket位置存储Entry对象。当发生碰撞的时候，使用散列法处理碰撞节点，将旧的Entry的引用赋值给新的Entry的next上，就是一个链表，冲突的节点从链表头部插入，这样插入新的Entry就不需要遍历链表。 通过get()获取对象。 当两个对象的hashCode相同的时候，怎么获取值对象？ get方法先比较hashCode值，如果hashCode相等，就是用equal()方法比较。 == 号与equals()方法的区别:== 基本数据类型比较的是值，对象比较的是对象的地址值。equals()继承自Object类。在所有没有重写equals()方法的类中，equals()内部是==，也是比较的地址值。然而，Java提供的所有类中，绝大多数类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？ 默认的负载因子大小为0.75，初始容量是16，,也就是说，当一个map填满了75%的bucket时候，就会发生resize。简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。 重新调整HashMap大小存在什么问题？ 在多线程的情况下，整个HashMap中的元素都需要重新算一遍。rehash，成本非常大。链表中节点的转移可能会出现死循环的情况。 HashMap与HashTable的区别： HashTable不接受为null的键值(key)和值(value) Hashtable是线程安全的也是synchronized在单线程环境下它比HashMap要慢。 HashMap同步？ Map m = Collections.synchronizeMap(hashMap); ConcurrentHashMap 需要线程安全，那么就使用ConcurrentHashMap。 HashTable是使用synchronized来锁住整张Hash表来实现线程安全。 一个 ConcurrentHashMap 由一个个 Segment 组成，Segment代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。Segment 内部是由 数组+链表 组成的。 HashMap的工作原理]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>集合</tag>
      </tags>
  </entry>
</search>
