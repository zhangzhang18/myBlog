<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>萌</title>
  
  <subtitle>冲鸭\(0^v^0)/</subtitle>
  <link href="/myBlog/atom.xml" rel="self"/>
  
  <link href="https://zhangzhang18.github.io/myBlog/"/>
  <updated>2019-10-16T09:28:17.345Z</updated>
  <id>https://zhangzhang18.github.io/myBlog/</id>
  
  <author>
    <name>萌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/10/16/Optional/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/10/16/Optional/</id>
    <published>2019-10-16T09:27:05.531Z</published>
    <updated>2019-10-16T09:28:17.345Z</updated>
    
    <content type="html"><![CDATA[<p>title: 优雅的处理NullPointerExcepter<br>copyright: true<br>abbrlink: c664e20c<br>date: 2019-10-16 09:50:56<br>categories:</p><ul><li>NoteBook<br>tags:</li><li>JAVA<br>top: </li></ul><p>Optional是Java8提供的为了解决null安全问题的一个API。</p><h2 id="一：Optional类方法"><a href="#一：Optional类方法" class="headerlink" title="一：Optional类方法"></a>一：Optional类方法</h2><p><img src="/myBlog/2019/10/16/Optional/method.jpg" alt="Optional类方法"></p><h3 id="1-创建-Optional-相关方法"><a href="#1-创建-Optional-相关方法" class="headerlink" title="1. 创建 Optional 相关方法"></a><strong>1. 创建 Optional 相关方法</strong></h3><p>方法：Optional.of、Optional.ofNullable、Optional.empty()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`Optional emptyOptional = Optional.empty(); Optional nonEmptyOptional = Optional.of(&quot;name&quot;); Optional nonEmptyOptional = Optional.ofNullable(null); `</span><br></pre></td></tr></table></figure><h3 id="2-检查-Optional-值"><a href="#2-检查-Optional-值" class="headerlink" title="2. 检查 Optional 值"></a><strong>2. 检查 Optional 值</strong></h3><p>方法：Optional.isPresent()、Optional.ifPresent()</p><ul><li>如果 Optional有值，isPresent() 返回 true</li><li>ifPresent() 如果值存在，则执行代码块</li></ul><h3 id="3-通过-Optional-取值"><a href="#3-通过-Optional-取值" class="headerlink" title="3. 通过 Optional 取值"></a><strong>3. 通过 Optional 取值</strong></h3><ul><li>get() 返回值包含在 Optional 中返回，（建议配合isPresent() 使用，假如 Optional 不包含一个值, get() 将会抛出一个异常）</li><li>orElse() 如果值不存在，则返回默认值  </li><li>orElseGet() 与 orElse() 类似，如果 Optional 不包含值，用函数作为返回值</li><li>orElseThrow() 与 orElseGet() 类似，监测到值为 null 时抛出异常</li></ul><h3 id="4-map转换值：Stream和Optional-的map方法对比图"><a href="#4-map转换值：Stream和Optional-的map方法对比图" class="headerlink" title="4. map转换值：Stream和Optional 的map方法对比图"></a>4. map转换值：Stream和Optional 的map方法对比图</h3><ul><li>Stream和optional的fiatMap方法对比图<br><img src="/myBlog/2019/10/16/Optional/Map.png" alt="Optional-Map"><br><img src="/myBlog/2019/10/16/Optional/FlatMap.png" alt="Optional-FlatMap"><br><img src="/myBlog/2019/10/16/Optional/UseMap.png" alt="Optional-Use-Map"><br>可以把Optional看成包含一个元素的Stream对象。<h3 id="5-filter"><a href="#5-filter" class="headerlink" title="5. filter"></a>5. filter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`String name = &quot;Aa&quot;; Optional optionalName = Optional.of(name).filter(str -&gt; str.length() &gt; 2);`</span><br></pre></td></tr></table></figure></li></ul><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul><li><h3 id="无法序列化"><a href="#无法序列化" class="headerlink" title="无法序列化"></a>无法序列化</h3><p>由于Optional 类设计时就没特别考虑将其作为类的字段使用，所以它也并未实现Serializable；<br>把 Optional 类型用作属性或是方法参数在 IntelliJ IDEA 中更是强力不推荐的<br>用Optional 声明域模型中某些类型是不错的主意。<br>如果非要实现序列化的模型域，可以参考下例  </p></li><li><h3 id="基于值的类（说明：这是一个基于值的class类，对于同一性（特性）敏感的操作-（包含引用的相等性如-）-同一性的hashcode或者同步等等、对optional实例可能会产生不可预料的结果，这种结果应该被避免。）"><a href="#基于值的类（说明：这是一个基于值的class类，对于同一性（特性）敏感的操作-（包含引用的相等性如-）-同一性的hashcode或者同步等等、对optional实例可能会产生不可预料的结果，这种结果应该被避免。）" class="headerlink" title="基于值的类（说明：这是一个基于值的class类，对于同一性（特性）敏感的操作 （包含引用的相等性如:==）,同一性的hashcode或者同步等等、对optional实例可能会产生不可预料的结果，这种结果应该被避免。）"></a>基于值的类（说明：这是一个基于值的class类，对于同一性（特性）敏感的操作 （包含引用的相等性如:==）,同一性的hashcode或者同步等等、对optional实例可能会产生不可预料的结果，这种结果应该被避免。）</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/doc-files/ValueBased.html</a></p><p>这里说的是基于值的类需要满足以下几点：<br>1、 final类型和不可变的（可能会包含可变对象的引用）<br>2、 有equals、hashCode、toString方法的实现，它是通过实例的状态计算出来的，而并不会通过其它的对象或变量去计算。<br>3、 不会使用身份敏感的操作，比如在二个实例之间引用相等性、hashCode或者内在的锁。<br>4、 判断二个值相等仅仅通过equal方法，而不会通过==去判断。<br>5、 它不提供构造方法，它通过工厂方法创建它的实例，这不保证返回实例的一致性。<br>6、 当它们相等时，它是可以自由替换的。如果x和y 调用equal方法返回true，那么可以将x和y任意交换，它的结果不会产生任何变化。  </p></li></ul><h2 id="二：实战示例"><a href="#二：实战示例" class="headerlink" title="二：实战示例"></a>二：实战示例</h2><h3 id="1-用Optional封装可能为Null的值"><a href="#1-用Optional封装可能为Null的值" class="headerlink" title="1. 用Optional封装可能为Null的值"></a>1. 用Optional封装可能为Null的值</h3><ul><li><p>假设有一个Map&lt;String,Object&gt;方法； 如果map 没有关联的key，就会返回null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object value = map.get(&quot;key&quot;);</span><br></pre></td></tr></table></figure><p>可以替换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Object&gt; value = Optional.ofNullable(map.get(&quot;key&quot;));</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-作为返回值（不建议作为参数）"><a href="#2-作为返回值（不建议作为参数）" class="headerlink" title="2. 作为返回值（不建议作为参数）"></a>2. 作为返回值（不建议作为参数）</h3><h3 id="3-把所有内容整合起来"><a href="#3-把所有内容整合起来" class="headerlink" title="3. 把所有内容整合起来"></a>3. 把所有内容整合起来</h3><h2 id="三：增强"><a href="#三：增强" class="headerlink" title="三：增强"></a>三：增强</h2><ul><li><strong>Java 9</strong></li><li>or()：如果值存在，返回包含该值的 Optional 对象；否则，返回 or() 函数生成的 Optional 对象。</li><li>ifPresentOrElse(Consumer&lt;? super T&gt;action, Runnable emptyAction)：如果值存在，使用该值执行指定调用，否则使用空值执行调用。</li><li>stream()：如果值存在，返回该值的顺序流（Stream）；否则返回空流。</li><li><strong>Java 10</strong></li><li>orElseThrow()：如果值存在，返回该值；否则抛出NoSuchElementException。注意：与 Java 8 不同，不接受任何参数。</li><li><strong>Java 11</strong></li><li>isEmpty()：如果值不存在，返回 true；否则返回 false。</li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;title: 优雅的处理NullPointerExcepter&lt;br&gt;copyright: true&lt;br&gt;abbrlink: c664e20c&lt;br&gt;date: 2019-10-16 09:50:56&lt;br&gt;categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NoteBoo
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MQ归纳</title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/09/18/MQ%E5%BD%92%E7%BA%B3/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/09/18/MQ归纳/</id>
    <published>2019-09-18T02:00:47.000Z</published>
    <updated>2019-10-11T05:30:42.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><p><img src="/myBlog/2019/09/18/MQ归纳/mq.png" alt="Kafka"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MQ&quot;&gt;&lt;a href=&quot;#MQ&quot; class=&quot;headerlink&quot; title=&quot;MQ&quot;&gt;&lt;/a&gt;MQ&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/myBlog/2019/09/18/MQ归纳/mq.png&quot; alt=&quot;Kafka&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Redis" scheme="https://zhangzhang18.github.io/myBlog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis归纳</title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/08/18/Redis%E5%BD%92%E7%BA%B3/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/08/18/Redis归纳/</id>
    <published>2019-08-18T08:31:47.000Z</published>
    <updated>2019-10-11T05:33:25.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>一个基于内存的高性能的key-value数据库。</p><blockquote><p>数据结构：String字符串，Hash字典，List列表，Set集合，SortedSet有序集合。</p></blockquote><p><img src="/myBlog/2019/08/18/Redis归纳/Redis.png" alt="Redis"></p><a id="more"></a><ol><li><strong>使用Redis有哪些好处？</strong></li></ol><blockquote><ul><li>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li><li>(2) 支持丰富数据类型，支持string，list，set，sorted set，hash</li><li>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ul></blockquote><p>2.<strong>为什么redis需要把所有数据放到内存中?</strong></p><blockquote><p>　Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。<br>　　　如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p></blockquote><p>3.<strong>Redis是单进程单线程的为什么也那么快？</strong></p><blockquote><p>　Redis快的主要原因是：</p><ul><li>完全基于内存</li><li>数据结构简单，对数据操作也简单</li><li>使用多路 I/O 复用模型</li></ul><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p></blockquote><p>4.<strong>Redis锁的使用。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static Redisson redisson = RedissonManager.getRedisson();</span><br><span class="line"></span><br><span class="line">    private static final String LOCK_FLAG = &quot;mylock_&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据name对进行上锁操作，redissonLock 阻塞的，采用的机制发布/订阅</span><br><span class="line">     * @param key</span><br><span class="line">     */</span><br><span class="line">    public static void lock(String key)&#123;</span><br><span class="line">        String lockKey = LOCK_FLAG + key;</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        //lock提供带timeout参数，timeout结束强制解锁，防止死锁 ：1分钟</span><br><span class="line">        lock.lock(1, TimeUnit.MINUTES);</span><br><span class="line">        logger.info(&quot;lock key:&#123;&#125;&quot;,lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据name对进行解锁操作</span><br><span class="line">     * @param key</span><br><span class="line">     */</span><br><span class="line">    public static void unlock(String key)&#123;</span><br><span class="line">        String lockKey = LOCK_FLAG + key;</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        //如果锁被当前线程持有，则释放</span><br><span class="line">        if(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            logger.info(&quot;unlock key:&#123;&#125;&quot;,lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h2&gt;&lt;p&gt;一个基于内存的高性能的key-value数据库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据结构：String字符串，Hash字典，List列表，Set集合，SortedSet有序集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/myBlog/2019/08/18/Redis归纳/Redis.png&quot; alt=&quot;Redis&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Redis" scheme="https://zhangzhang18.github.io/myBlog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器 </title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/08/05/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/08/05/垃圾收集器/</id>
    <published>2019-08-05T11:09:08.000Z</published>
    <updated>2019-10-15T09:12:35.701Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2019/08/05/垃圾收集器/GC.jpg" alt="垃圾回收"><br>两个收集器之间存在连线，说明它们可以搭配使用。<br><a id="more"></a></p><h2 id="1-Serial-新生代收集器，单线程，复制算法"><a href="#1-Serial-新生代收集器，单线程，复制算法" class="headerlink" title="1. Serial 新生代收集器，单线程，复制算法"></a>1. Serial 新生代收集器，单线程，复制算法</h2><blockquote><p>单线程，不仅仅说明它只会用一个CPU或一条收集线程去完成垃圾手机工作，更重要的时进行垃圾收集时，必须暂停其他说有的工作线程，直至收集结束。Stop The World<br>优点：简单而高效，没有线程交互的开销。<br><img src="/myBlog/2019/08/05/垃圾收集器/serial.jpg" alt="Serial"></p></blockquote><h2 id="2-ParNew-是Serial的多线程版本，复制算法"><a href="#2-ParNew-是Serial的多线程版本，复制算法" class="headerlink" title="2. ParNew 是Serial的多线程版本，复制算法"></a>2. ParNew 是Serial的多线程版本，复制算法</h2><blockquote><p>与Serial可用的所有控制参数、收集算法、Stop The World、对象分配原则、回收策略完全一样，实现上，两种收集器共用了相当多的代码。</p></blockquote><p>ParNew在单CPU环境中绝对不会有比Serial更好的效果。<br>注：并发强调的是一起出发（交替执行），并行强调的是一起执行。<br><img src="/myBlog/2019/08/05/垃圾收集器/pn.jpg" alt="ParNew"></p><h2 id="3-Parallel-Scavenge-新生代收集器，多线程，复制算法"><a href="#3-Parallel-Scavenge-新生代收集器，多线程，复制算法" class="headerlink" title="3. Parallel Scavenge 新生代收集器，多线程，复制算法"></a>3. Parallel Scavenge 新生代收集器，多线程，复制算法</h2><blockquote><p>关注点与其他收集器不同，CMS关注尽可能缩短垃圾收集时用户线程停顿时间，而Parallel Scavenge目的时达到一个可控制的吞吐量。就是CPU用于运行用户线程的时间与CPU总消耗时间的比值，吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）<br> 停顿时间短适合与用户交互的程序，良好的响应速度能提升用户体验，高吞吐量可以高效的利用CPU时间，尽快完成运算任务，主要适合后台运算而不需要太多交互任务。</p></blockquote><h2 id="4-Serial-Old-是Serial老年代版本，单线程，标记-整理算法"><a href="#4-Serial-Old-是Serial老年代版本，单线程，标记-整理算法" class="headerlink" title="4. Serial Old 是Serial老年代版本，单线程，标记-整理算法"></a>4. Serial Old 是Serial老年代版本，单线程，标记-整理算法</h2><blockquote><p>主要意义是给Client模式下的虚拟机使用。<br><img src="/myBlog/2019/08/05/垃圾收集器/so.jpg" alt="Serial Old"></p></blockquote><h2 id="5-Parallel-Old-是Parallel-Scavenge老年代版本，多线程，标记整理"><a href="#5-Parallel-Old-是Parallel-Scavenge老年代版本，多线程，标记整理" class="headerlink" title="5. Parallel Old 是Parallel Scavenge老年代版本，多线程，标记整理"></a>5. Parallel Old 是Parallel Scavenge老年代版本，多线程，标记整理</h2><p><img src="/myBlog/2019/08/05/垃圾收集器/po.jpg" alt="Parallel Old"></p><h2 id="6-CMS-Concurrent-Mark-Sweep-标记-清除算法"><a href="#6-CMS-Concurrent-Mark-Sweep-标记-清除算法" class="headerlink" title="6. CMS(Concurrent Mark Sweep) 标记-清除算法"></a>6. CMS(Concurrent Mark Sweep) 标记-清除算法</h2><blockquote><p>互联网网站或者B/S系统服务端，注重服务的相应速度，希望系统停顿时间最短。  </p></blockquote><h3 id="分为四个步骤："><a href="#分为四个步骤：" class="headerlink" title="分为四个步骤："></a>分为四个步骤：</h3><ul><li>初始标记：标记一下GC Roots能直接关联到的对象，速度很快。</li><li>并发标记：进行GC Roots Tracing的过程。与用户线程同时运行。</li><li>重新标记：为了修正并发标记期间因为用户程序继续运行导致标记产生变动的那部分对象的标记记录，这个阶段停顿时间会比初始标记阶段稍长，但是比并发标记时间短。</li><li>并发清除：与用户线程同时运行。<br>由于整个过程耗时最长的并发标记和并发清楚过程收集器线程可以与用户线程一起工作，所以，总体上来说CMS收集器的内存回收过程是与用户线程一起并发执行的。<br><img src="/myBlog/2019/08/05/垃圾收集器/cms.png" alt="CMS"></li></ul><h3 id="三个明显缺点"><a href="#三个明显缺点" class="headerlink" title="三个明显缺点"></a>三个明显缺点</h3><ul><li>对CPU资源非常敏感。并发设计都对CPU资源敏感，并发阶段虽然不会导致用户线程变慢，但是会因为占用一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li>无法处理浮动垃圾。由于并发清理阶段用户线程还在运行，伴随程序运行就会有新的垃圾不断产生，这部分垃圾出现在标记过程之后，CMS午发在当次收集中处理掉它们，只好下次GC时清理，这部分垃圾称为“浮动垃圾”。</li><li>基于标记-清除算法实现的，就意味着收集结束会有大量的空间碎片，空间碎片多，会给大对象分配带来很大麻烦，往往会出现老年代空间还有很大空间剩余，但是无法找到足够大的空间来分配当前对象，不得不触发Full GC。<h2 id="7-G1-面向服务端引用，未来可以替代CMS的收集器"><a href="#7-G1-面向服务端引用，未来可以替代CMS的收集器" class="headerlink" title="7.G1 面向服务端引用，未来可以替代CMS的收集器"></a>7.G1 面向服务端引用，未来可以替代CMS的收集器</h2><h3 id="与其他GC收集器比较，特点"><a href="#与其他GC收集器比较，特点" class="headerlink" title="与其他GC收集器比较，特点"></a>与其他GC收集器比较，特点</h3></li><li>并行和并发</li><li>分代收集</li><li>空间整合</li><li>可预测的停顿<h2 id="运作步骤"><a href="#运作步骤" class="headerlink" title="运作步骤"></a>运作步骤</h2></li><li>初始标记(Initial Marking)</li><li>并发标记(Concurrent Marking)</li><li>最终标记(Final Marking)</li><li>筛选回收(Live Data Counting and Evacuation)</li></ul><p><img src="/myBlog/2019/08/05/垃圾收集器/G1.jpg" alt="G1"></p><hr><h1 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h1><ul><li><p>对象优先在Eden分配</p></li><li><p>大对象直接进入老年代：避免Eden区及两个Survivor区之间发生大量的内存复制</p></li><li><p>长期存活的对象将进入老年代：在Eden出生，经历过一次GC仍然存活，并且能被Survivor容纳，将被移动到Survivor空间，设置对象年龄为1，每熬过一次GC年龄增加一岁，年龄增加到一定程度（通常15岁），就会晋升老年代。MaxTenuringThreshold配置。</p></li><li><p>动态对象年龄判定：如果在Survivor空间相同年龄所有对象的大小总和打于Survivor空间大小的一半，年龄大于或者等于该对象年龄可以直接进入老年代，无需等到MaxTenuringThreshold。</p></li><li><p>空间分配担保：发生GC之前，虚拟机会检查老年代最大可用的连续空间是否打于新生代所有对象总空间，如果这个条件成立，就可以确保是安全的。（老年代能容纳Survivor晋升到老年代的对象）<br><img src="/myBlog/2019/08/05/垃圾收集器/memory.jpg" alt="堆内存模型"></p></li></ul><hr><p>选择server模式的VM。服务端常使用<br>  -Xms2g<br>  设置堆内存最小值2G<br>  -Xmx2g<br>  设置堆内存最大值2G<br>  -Xmn1g<br>  设置新生代大小1G<br>  -Xss1024K<br>  设置单线程栈空间大小1024K<br>  -XX:PermSize=256m<br>  设置永久代初始大小256m。JDK8中已移除<br>  -XX:MaxPermSize=512m<br>  设置永久代最大值512m。JDK8中已移除<br>  -XX:ParallelGCThreads=8<br>  设置并行收集器收集时使用的CPU数。并行收集线程数 8。<br>  -XX:+UseConcMarkSweepGC<br>  开启CMS收集器，默认新生代收集器 UseParNewGC。<br>  -XX:+UseParNewGC<br>  开启ParNew收集器。<br>  -XX:+UseCMSCompactAtFullCollection<br>  开启对老年代空间进行压缩整理（默认开启）。<br>  -XX:SurvivorRatio=4<br>  Eden与一个Surivivor的比值大小。默认为8:1:1，即Eden占8/10。<br>  -XX:MaxTenuringThreshold=10<br>  晋升老年代的最大年龄。默认为15，比如设为10，则对象在10次普通GC后将会被放入年老代。<br>  -XX:CMSInitiatingOccupancyFraction=80<br>    触发CMS收集器的内存比例。比如80%的意思就是说，当内存达到80%，就会开始进行CMS并发收集。<br>  -XX:NewRatio<br>    表示新生代与老年代所占的比值为1:4，Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置。</p><p>参考：<br><a href="https://www.jianshu.com/p/293eb2f1f74a" target="_blank" rel="noopener">java常用命令</a><br><a href="https://www.cnblogs.com/furaywww/p/8576682.html" target="_blank" rel="noopener">gc发生场景</a><br><a href="https://my.oschina.net/dslcode/blog/3007693" target="_blank" rel="noopener">jvm参数大全</a><br><a href="https://www.jianshu.com/p/088d71f20a47" target="_blank" rel="noopener">内存区域垃圾收集</a><br><a href="https://www.cnblogs.com/zhangfengshi/p/11343102.html" target="_blank" rel="noopener">JVM内存设置多大合适？</a><br><a href="https://www.jianshu.com/p/5946c0a414b5" target="_blank" rel="noopener">JVM 内存区域大小参数设置</a>   </p><p>​     </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2019/08/05/垃圾收集器/GC.jpg&quot; alt=&quot;垃圾回收&quot;&gt;&lt;br&gt;两个收集器之间存在连线，说明它们可以搭配使用。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://zhangzhang18.github.io/myBlog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>线程池 </title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/05/01/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/05/01/线程池/</id>
    <published>2019-05-01T04:07:09.000Z</published>
    <updated>2019-10-15T09:11:17.978Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h2><ol><li>降低资源消耗  -事先创建若干个线程放在容器中，当使用的时候不需要自行创建，使用完不是去销毁而是归还到容器，减少了线程创建和销毁的时间   </li><li>提高线程的可管理性  -无限制的创建线程，不仅消耗资源还降低系统稳定性，线程池可以进行统一分配，监控  </li><li>提高相应速度  -不需要等待线程创建<br>##　参数说明<br><code>ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable     workQueue)</code><a id="more"></a>  <strong>corePoolSize（最大核心线程数）：</strong> 线程池启动后，在池中保持的线程的最小数量<br><strong>maxinumPoolSize（线程池能容纳的最大线程数量）：</strong> 核心线程数 + 非核心线程数 = 最大线程数量<br><strong>unit：</strong> keepAliveTime的时间单位，可以是纳秒，毫秒，秒，分钟等<br><strong>keepAliveTime：</strong> 线程的最大生命周期<br><strong>workQueue：</strong>  任务队列<br><strong>threadFactory：</strong> 定义如何启动一个线程，可以设置线程的名称，并且可以确定是否是后台线程等。 <code>new ThreadFactoryBuilder().setNameFormat(&quot;XX-task-%d&quot;).build();</code><br><strong>RejectedExecutionHandler：</strong> 拒绝任务处理器。由于超出线程数量和队列容量而对继续增加的任务进行处理的程序。  </li></ol><p><strong>workQueue：</strong><br>　- ArrayBlockingQueue：基于数组结构的<strong>有界队列</strong>，先进先出（FIFO）原则对元素排序<br>　- LinkedBlockingQueue：基于链表结构的阻塞队列，先进先出排序元素，吞吐量高于数组结构。<code>Executors.newFixedThreadPool()</code> 使用这个队列<br>　- SynchronousQueue：不存储元素的阻塞队列，每个插入操作必须等到下一个线程调用一处操作，否则插入操作一直处于阻塞状态，吞吐量高于2，<code>Executors.newCachedThreadPool()</code>使用这个队列</p><ul><li>PriorityBlockQueue：具有优先级的无线阻塞队列<br>　- DelayQueue（延时队列）：任务到来时，首先先加入到队列中，只有达到了指定的延时时间，才会执行任务<br><strong>RejectedExecutionHandler：</strong> </li><li>AbortPolicy（默认策略）:直接拒绝抛异常（RejectedExecutionException）</li><li>CallerRunsPolicy:不抛弃任务，只有调用者所在线程来运行任务</li><li>DiscardOldestPolicy:丢弃队列最近的任务，并执行当前任务</li><li>DiscardPolicy:不处理，丢弃掉，不抛异常<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>线程数量未达到 corePoolSize，则新建一个线程（核心线程）执行任务。</li><li>线程数量达到了 corePoolsSize，则将任务移入队列等待。</li><li>队列已满，新建非核心线程（先进先出）执行任务。</li><li>队列已满，总线程数又达到了 maximumPoolSize，就会由 RejectedExecutionHandler 抛出异常。</li></ol></li></ul><h2 id="阿里巴巴JAVA开发手册"><a href="#阿里巴巴JAVA开发手册" class="headerlink" title="阿里巴巴JAVA开发手册"></a>阿里巴巴JAVA开发手册</h2><p>【3】. 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<br>说明：使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决<br>资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或<br>者“过度切换”的问题。<br>【4】. 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样<br>的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br>说明：Executors 返回的线程池对象的弊端如下： 1）FixedThreadPool 和 SingleThreadPool:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 2）CachedThreadPool 和 ScheduledThreadPool:<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p><h2 id="合理的配置线程池"><a href="#合理的配置线程池" class="headerlink" title="合理的配置线程池"></a>合理的配置线程池</h2><p>可以从以下几个角度分析：</p><ol><li>任务的性质：CPU密集型任务、IO密集型任务、混合型任务。</li><li>任务的优先级：高、中、低。</li><li>任务的执行时间：长、中、短。</li><li>任务的依赖性：是否依赖其他系统资源，如数据库连接等。<ul><li>最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目<br>可以得出一个结论：<br>线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程。 </li><li>CPU密集型时，任务可以少配置线程数，大概和机器的cpu核数相当，这样可以使得每个线程都在执行任务</li><li>IO密集型时，大部分线程都阻塞，故需要多配置线程数，2*cpu核数</li></ul></li><li>建议使用有界队列：增加系统稳定性和预警能力。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么使用多线程&quot;&gt;&lt;a href=&quot;#为什么使用多线程&quot; class=&quot;headerlink&quot; title=&quot;为什么使用多线程&quot;&gt;&lt;/a&gt;为什么使用多线程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;降低资源消耗  -事先创建若干个线程放在容器中，当使用的时候不需要自行创建，使用完不是去销毁而是归还到容器，减少了线程创建和销毁的时间   &lt;/li&gt;
&lt;li&gt;提高线程的可管理性  -无限制的创建线程，不仅消耗资源还降低系统稳定性，线程池可以进行统一分配，监控  &lt;/li&gt;
&lt;li&gt;提高相应速度  -不需要等待线程创建&lt;br&gt;##　参数说明&lt;br&gt;&lt;code&gt;ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&amp;lt;Runnable     workQueue)&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>并发多线程</title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/04/20/%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/04/20/并发学习/</id>
    <published>2019-04-20T13:56:25.000Z</published>
    <updated>2019-10-15T09:12:07.014Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一：JAVA内存模型（JMM）"><a href="#一：JAVA内存模型（JMM）" class="headerlink" title="一：JAVA内存模型（JMM）"></a>一：JAVA内存模型（JMM）</h2><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><a id="more"></a>   <h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><h4 id="实现机制-1"><a href="#实现机制-1" class="headerlink" title="实现机制"></a>实现机制</h4><h2 id="二：并发基础"><a href="#二：并发基础" class="headerlink" title="二：并发基础"></a>二：并发基础</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h2 id="三：锁"><a href="#三：锁" class="headerlink" title="三：锁"></a>三：锁</h2><h3 id="ReenTrantLock可重入锁"><a href="#ReenTrantLock可重入锁" class="headerlink" title="ReenTrantLock可重入锁"></a>ReenTrantLock可重入锁</h3><h3 id="ReenTrantReadWriteLock读写锁"><a href="#ReenTrantReadWriteLock读写锁" class="headerlink" title="ReenTrantReadWriteLock读写锁"></a>ReenTrantReadWriteLock读写锁</h3><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><h2 id="四：并发工具类"><a href="#四：并发工具类" class="headerlink" title="四：并发工具类"></a>四：并发工具类</h2><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><h2 id="五：其他"><a href="#五：其他" class="headerlink" title="五：其他"></a>五：其他</h2><h2 id="六：并发集合"><a href="#六：并发集合" class="headerlink" title="六：并发集合"></a>六：并发集合</h2><h2 id="七：atomic原子"><a href="#七：atomic原子" class="headerlink" title="七：atomic原子"></a>七：atomic原子</h2><h2 id="八：阻塞队列"><a href="#八：阻塞队列" class="headerlink" title="八：阻塞队列"></a>八：阻塞队列</h2><h2 id="九：线程池"><a href="#九：线程池" class="headerlink" title="九：线程池"></a>九：线程池</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一：JAVA内存模型（JMM）&quot;&gt;&lt;a href=&quot;#一：JAVA内存模型（JMM）&quot; class=&quot;headerlink&quot; title=&quot;一：JAVA内存模型（JMM）&quot;&gt;&lt;/a&gt;一：JAVA内存模型（JMM）&lt;/h2&gt;&lt;h3 id=&quot;线程通信&quot;&gt;&lt;a href=&quot;#线程通信&quot; class=&quot;headerlink&quot; title=&quot;线程通信&quot;&gt;&lt;/a&gt;线程通信&lt;/h3&gt;&lt;h3 id=&quot;内存模型&quot;&gt;&lt;a href=&quot;#内存模型&quot; class=&quot;headerlink&quot; title=&quot;内存模型&quot;&gt;&lt;/a&gt;内存模型&lt;/h3&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Boot</title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/03/11/Spring-Boot/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/03/11/Spring-Boot/</id>
    <published>2019-03-11T01:24:22.000Z</published>
    <updated>2019-10-11T11:04:37.847Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot解决得问题</p><blockquote><p>配置、部署、监控变得简单。</p></blockquote><blockquote><p>Boot只需要很少得配置（@Configuration），项目快速搭建，主流框架无配置集成。</p></blockquote><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li>独立运行Spring项目</li><li>内嵌servlet容器 - SpringApplication.run()</li><li>提供starter简化maven配置</li><li>自动装配Spring</li><li>准生产的应用监控</li><li>无代码生产和xml配置</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring Boot解决得问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置、部署、监控变得简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Boot只需要很少得配置（@Configuration），项目快速搭建，主流框架无配置集成。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Spring" scheme="https://zhangzhang18.github.io/myBlog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>AB测技术 </title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/02/13/AB%E6%B5%8B%E6%8A%80%E6%9C%AF/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/02/13/AB测技术/</id>
    <published>2019-02-13T02:17:26.000Z</published>
    <updated>2019-02-15T09:45:10.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单来说，就是为同一个目标制定两个方案（比如两个页面）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简单来说，就是为同一个目标制定两个方案（比如两个页面）&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
  </entry>
  
  <entry>
    <title>CAP原则-Base理论 </title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/02/10/CAP%E5%8E%9F%E5%88%99-Base%E7%90%86%E8%AE%BA/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/02/10/CAP原则-Base理论/</id>
    <published>2019-02-10T07:57:16.000Z</published>
    <updated>2019-10-15T07:37:39.466Z</updated>
    
    <content type="html"><![CDATA[<p>CAP原则：分布式的三个指标， 这三个指标不可能同时做到。这个结论就叫做 CAP 定理。 </p><ul><li><p>Consistency（一致性）： 写操作之后的读操作，必须返回该值 </p></li><li><p>Availability（可用性）： 意思是只要收到用户的请求，服务器就必须给出回应 </p></li><li><p>Partition tolerance（分区容错）： 大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区容错的意思是，区间通信可能失败   </p><p> 一般来说，分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。 </p><p>CA为什么不能同时成立？因为可能通信失败（分区容错）</p></li></ul><p>Base理论：BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）的简写 </p><ul><li>基本可用： 指分布式系统在出现故障的时候，允许损失部分可用性（例如响应时间、功能上的可用性），允许损失部分可用性。需要注意的是，基本可用绝不等价于系统不可用。 </li><li>最终一致性：最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</li><li><p>软状态：指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据会有多个副本，允许不同副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</p><p>总的来说，BASE理论面向的是大型高可用可扩展的分布式系统，和传统事务的ACID特性使相反的，它完全不同于ACID的强一致性模型，而是提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。但同时，在实际的分布式场景中，不同业务单元和组件对数据一致性的要求是不同的，因此在具体的分布式系统架构设计过程中，ACID特性与BASE理论往往又会结合在一起使用。</p></li></ul><p><a href="http://raft.taillog.cn//" target="_blank" rel="noopener">聊聊分布式存储——轻松理解Raft</a></p><h3 id="一：Eureka"><a href="#一：Eureka" class="headerlink" title="一：Eureka"></a>一：Eureka</h3><h3 id="二：Zookeeper"><a href="#二：Zookeeper" class="headerlink" title="二：Zookeeper"></a>二：Zookeeper</h3><h3 id="三：Consul"><a href="#三：Consul" class="headerlink" title="三：Consul"></a>三：Consul</h3><p> Eureka 典型的 AP,作为分布式场景下的服务发现的产品较为合适，服务发现场景的可用性优先级较高，一致性并不是特别致命。其次 CA 类型的场景 Consul,也能提供较高的可用性，并能 k-v store 服务保证一致性。 而Zookeeper,Etcd则是CP类型 牺牲可用性，在服务发现场景并没太大优势；</p><table><thead><tr><th></th><th style="text-align:left">Eureka</th><th style="text-align:left">Zookeeper</th><th>Consul</th></tr></thead><tbody><tr><td>GitHub</td><td style="text-align:left"><a href="https://github.com/apache/zookeeper" target="_blank" rel="noopener">https:/</a><a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">/github.com/Netflix/eureka</a></td><td style="text-align:left"><a href="https://github.com/apache/zookeeper" target="_blank" rel="noopener">https://github.com/apache/zookeeper</a></td><td><a href="https://github.com/hashicorp/consul" target="_blank" rel="noopener">https://github.com/hashicorp/consul</a></td></tr><tr><td>服务健康度检查</td><td style="text-align:left">服务状态，内存，硬盘等</td><td style="text-align:left">(弱)长连接，keepalive</td><td>连接心跳</td></tr><tr><td>多数据中心</td><td style="text-align:left">—</td><td style="text-align:left">支持</td><td>支持</td></tr><tr><td>k-v存储服务</td><td style="text-align:left">—</td><td style="text-align:left">支持</td><td>支持</td></tr><tr><td>一致性</td><td style="text-align:left">—</td><td style="text-align:left">paxos（Paxos算法是保证在分布式系统中写操作能够顺利进行，保证系统中大多数状态是一致的，没有机会看到不一致，因此，Paxos算法的特点是一致性&gt;可用性。）</td><td>raft<a href="http://raft.taillog.cn/" target="_blank" rel="noopener">http://raft.taillog.cn/</a></td></tr><tr><td>cap</td><td style="text-align:left">ap</td><td style="text-align:left">cp</td><td>ca</td></tr><tr><td>多语言能力</td><td style="text-align:left">http（sidecar）</td><td style="text-align:left">客户端</td><td>支持http和dns</td></tr><tr><td>watch支持</td><td style="text-align:left">支持 long polling/大部分增量</td><td style="text-align:left">—</td><td>metrics</td></tr><tr><td>自身监控</td><td style="text-align:left">metrics</td><td style="text-align:left">—</td><td>metrics</td></tr><tr><td>安全</td><td style="text-align:left">—</td><td style="text-align:left">acl</td><td>acl /https</td></tr></tbody></table><table><thead><tr><th>SpringCloud集成</th><th>以支持</th><th>以支持</th><th>以支持</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CAP原则：分布式的三个指标， 这三个指标不可能同时做到。这个结论就叫做 CAP 定理。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Consistency（一致性）： 写操作之后的读操作，必须返回该值 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Availability（可用性）： 意思是
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud</title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/01/24/Spring-Cloud/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/01/24/Spring-Cloud/</id>
    <published>2019-01-24T08:21:58.000Z</published>
    <updated>2019-10-14T05:04:18.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud简介"><a href="#Spring-Cloud简介" class="headerlink" title="Spring Cloud简介"></a>Spring Cloud简介</h1><blockquote><p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p></blockquote><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><blockquote><p>简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。</p></blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>每个服务都比较简单，只关注一个业务功能</li><li>微服务架构方式是松耦合的，可以提供更高的灵活性</li><li>每个微服务可由不同团队独立开发，互不影响，加快推出市场速度<br>4.允许在频繁发布不同服务的同时，保持其他部分的可用性和稳定性<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2></li><li>运维开销的成本增加</li><li>系统复杂度变高</li><li>部署的速度变慢</li><li>分布式系统的冗余问题</li><li>分布式系统的复杂性</li></ol><h1 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h1><p><img src="/myBlog/2019/01/24/Spring-Cloud/register.png" alt="服务注册中心对比"></p><ul><li>Spring Cloud应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper</li><li>Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。</li></ul><ol start="2"><li><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。</p></li><li><p>Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Cloud简介&quot;&gt;&lt;a href=&quot;#Spring-Cloud简介&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud简介&quot;&gt;&lt;/a&gt;Spring Cloud简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Spring Cl
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Spring" scheme="https://zhangzhang18.github.io/myBlog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/12/26/ZooKeeper/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/12/26/ZooKeeper/</id>
    <published>2018-12-26T02:50:47.000Z</published>
    <updated>2019-10-14T05:04:18.600Z</updated>
    
    <content type="html"><![CDATA[<p>分布式协调服务-可以在分布式系统中共享配置，协调锁资源，提供命名服务</p><p>Zookeeper的数据模型：像数据结构中的树，也像文件系统中的目录<br>  <a id="more"></a></p><ul><li>Znode：包含数据，子节点引用，访问权限等。每个节点的数据最大不能超过1MB<br>Zookeeper包含的基本操作<ul><li>create：创建节点</li><li>delete：删除节点</li><li>exists：判断节点是否存在</li><li>getData：获得一个节点的数据</li><li>setData：设置一个节点的数据</li><li>getChildren：获取节点下的所有子节点</li></ul></li></ul><p>Zookeeper一致性</p><ul><li>Zookeeper Service集群是一主多从结构，更新数据时，首先跟新到主节点，在同步从节点。读取数据的时候可以读取任意节点</li></ul><p>Zookeeper应用场景：</p><ul><li>分布式协调服务</li><li>分布式锁</li><li>服务注册与发现</li><li>共享配置和状态信息</li></ul><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/index.html" target="_blank" rel="noopener">Zookeeper IBM</a><br><a href="https://juejin.im/post/5b037d5c518825426e024473" target="_blank" rel="noopener">小灰 什么是ZooKeeper？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式协调服务-可以在分布式系统中共享配置，协调锁资源，提供命名服务&lt;/p&gt;
&lt;p&gt;Zookeeper的数据模型：像数据结构中的树，也像文件系统中的目录&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="分布式" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="ZK" scheme="https://zhangzhang18.github.io/myBlog/tags/ZK/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/12/06/Elasticsearch/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/12/06/Elasticsearch/</id>
    <published>2018-12-06T06:31:02.000Z</published>
    <updated>2019-10-11T10:55:51.960Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_document_oriented.html" target="_blank" rel="noopener">elasticsearch权威指南</a></p><p><strong>面向文档</strong><br>在应用程序中对象很少只是一个简单的键和值的列表。通常，它们拥有更复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。<br><a id="more"></a><br>Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。这种理解数据的方式与以往完全不同，这也是Elasticsearch能够执行复杂的全文搜索的原因之一。</p><p><strong>JSON</strong><br>Elasticsearch 使用 JavaScript Object Notation 或者 JSON 作为文档的序列化格式。</p><p>Elasticsearch集群可以包含多个索引(indices)（数据库），每一个索引可以包含多个类型(types)（表），每一个类型包含多个文档(documents)（行），然后每个文档包含多个字段(Fields)（列）。</p><p>所以为了创建员工目录，我们将进行如下操作：</p><p>为每个员工的文档(document)建立索引，每个文档包含了相应员工的所有信息。</p><p>每个文档的类型为employee。</p><p>employee类型归属于索引megacorp。</p><p>megacorp索引存储在Elasticsearch集群中。</p><p><a href="http://git.daojia-inc.com/jiazheng/jzup-brain.git" target="_blank" rel="noopener">http://git.daojia-inc.com/jiazheng/jzup-brain.git</a><br>实际上这些都是很容易的（尽管看起来有许多步骤）。我们能通过一个命令执行完成的操作：<br><code>PUT /megacorp/employee/1</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"first_name"</span>: <span class="string">"John"</span>,</span><br><span class="line"><span class="attr">"last_name"</span>: <span class="string">"Smith"</span>,</span><br><span class="line"><span class="attr">"age"</span>: <span class="number">25</span>,</span><br><span class="line"><span class="attr">"about"</span>: <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line"><span class="attr">"interests"</span>: [<span class="string">"sports"</span>, <span class="string">"music"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到path:/megacorp/employee/1包含三部分信息：名字说明megacorp索引名employee类型名1这个员工的ID</p><p>我们通过HTTP方法GET来检索文档，同样的，我们可以使用DELETE方法删除文档，使用HEAD方法检查某文档是否存在。如果想更新已存在的文档，我们只需再PUT一次。</p><p>我们尝试一个最简单的搜索全部员工的请求：</p><p><code>GET /megacorp/employee/_search</code></p><p>这种方法常被称作查询字符串(query string)搜索，因为我们像传递URL参数一样去传递查询语句：</p><p><code>GET /megacorp/employee/_search?q=last_name:Smith</code></p><p>使用DSL语句查询<br>DSL(Domain Specific Language特定领域语言)以JSON请求体的形式出现。我们可以这样表示之前关于“Smith”的查询:</p><p><code>GET /megacorp/employee/_search</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"query"</span>: &#123;</span><br><span class="line"><span class="attr">"match"</span>: &#123;</span><br><span class="line"><span class="attr">"last_name"</span>: <span class="string">"Smith"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这会返回与之前查询相同的结果。</p><p>更复杂的搜索</p><p>我们的语句将添加过滤器(filter),它使得我们高效率的执行一个结构化搜索：</p><p><code>GET /megacorp/employee/_search</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"query"</span>: &#123;</span><br><span class="line"><span class="attr">"filtered"</span>: &#123;</span><br><span class="line"><span class="attr">"filter"</span>: &#123;</span><br><span class="line"><span class="attr">"range"</span>: &#123;</span><br><span class="line"><span class="attr">"age"</span>: &#123;</span><br><span class="line"><span class="attr">"gt"</span>: <span class="number">30</span> //<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"query"</span>: &#123;</span><br><span class="line"><span class="attr">"match"</span>: &#123;</span><br><span class="line"><span class="attr">"last_name"</span>: <span class="string">"smith"</span>//<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><1> 这部分查询属于区间过滤器(range filter),它用于查找所有年龄大于30岁的数据——gt为”greater than”的缩写。</1></p><p><2> 这部分查询与之前的match语句(query)一致。</2></p><p>现在我们的搜索结果只显示了一个32岁且名字是“Jane Smith”的员工：<br>全文搜索<br>到目前为止搜索都很简单：搜索特定的名字，通过年龄筛选。让我们尝试一种更高级的搜索，全文搜索——一种传统数据库很难实现的功能。<br>我们将会搜索所有喜欢“rock climbing”的员工：</p><p><code>GET /megacorp/employee/_search</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解释了Elasticsearch如何在各种文本字段中进行全文搜索，并且返回相关性最大的结果集。相关性(relevance)的概念在Elasticsearch中非常重要，而这个概念在传统关系型数据库中是不可想象的，因为传统数据库对记录的查询只有匹配或者不匹配。</p><p>短语搜索<br>目前我们可以在字段中搜索单独的一个词，这挺好的，但是有时候你想要确切的匹配若干个单词或者短语(phrases)。例如我们想要查询同时包含”rock”和”climbing”（并且是相邻的）的员工记录。<br>要做到这个，我们只要将match查询变更为match_phrase查询即可:</p><p><code>GET /megacorp/employee/_search</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"query"</span>: &#123;</span><br><span class="line"><span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line"><span class="attr">"about"</span>: <span class="string">"rock climbing"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>高亮我们的搜索<br>很多应用喜欢从每个搜索结果中高亮(highlight)匹配到的关键字，这样用户可以知道为什么这些文档和查询相匹配。在Elasticsearch中高亮片段是非常容易的。<br>让我们在之前的语句上增加highlight参数：</p><p><code>GET /megacorp/employee/_search</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"query"</span>: &#123;</span><br><span class="line"><span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line"><span class="attr">"about"</span>: <span class="string">"rock climbing"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"highlight"</span>: &#123;</span><br><span class="line"><span class="attr">"fields"</span>: &#123;</span><br><span class="line"><span class="attr">"about"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们运行这个语句时，会命中与之前相同的结果，但是在返回结果中会有一个新的部分叫做highlight，这里包含了来自about字段中的文本，并且用<em></em>来标识匹配到的单词。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/cn/elasticsearch/guide/current/_document_oriented.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;elasticsearch权威指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向文档&lt;/strong&gt;&lt;br&gt;在应用程序中对象很少只是一个简单的键和值的列表。通常，它们拥有更复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="ES" scheme="https://zhangzhang18.github.io/myBlog/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/11/10/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/11/10/分布式锁/</id>
    <published>2018-11-10T07:14:43.000Z</published>
    <updated>2019-10-15T05:26:58.526Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2018/11/10/分布式锁/suo.jpg" alt="image"></p><h3 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h3><p>将系统差分成不同的服务然后将这些服务放在不同服务器减轻单台服务的压力，提高性能和并发量。<br><a id="more"></a></p><blockquote><p>并发并行？</p></blockquote><p><img src="/myBlog/2018/11/10/分布式锁/concurrency.jpg" alt="concurrency"><br><img src="/myBlog/2018/11/10/分布式锁/parallel.jpg" alt="parallel"></p><pre><code>顺序执行：你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。    并行：你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。    并发：你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。    并发强调的是一起出发（交替执行），并行强调的是一起执行。    并发的反义是顺序，并行的反义是串行。并发并行并不是互斥概念，只不过并发强调任务的抽象调度，并行强调任务的实际执行。    </code></pre><blockquote><p>分布式=高并发=多线程？</p></blockquote><pre><code>分布式：是为了解决单个物理服务器容量和性能瓶颈问题而采用的优化手段。            该领域需要解决的问题极多，在不同技术层面上，包括：分布式文件系统、缓存、数据库、计算等。           水平拓展：当一台机器扛不住流量时，通过添加机器的方式，将流量均分。            垂直拆分：前端有多种需求时，一台机器扛不住，可以将不同需求分发到不同机器上。    高并发：反应的是 [同时有多少量]，例如直播服务，同时可能有上万人观看。            高并发可以用分布式技术去解决，将并发流量分到不同物理机器上。            例如使用缓存技术和前端将静态资源放在CDN等；还可以用多线程技术将一台服务器的能力最大化。    多线程：是指从软件或硬件上实现多个线程并发执行的技术。            多线程聚焦于如何使用编程语言将CPU能力最大化。    </code></pre><h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>为了实现多个线程在同一时刻同一代码块只能有一个线程可执行，需要在某个地方做标记，这个标记必须满足所有的线程可见，标记不存在的时候设置标记，后续的线程发现已标记则等待拥有标记的线程结束，同步代码块取消标记后，在尝试设置标记，这个标记可以理解为锁。</p><h3 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h3><p>单体单机部署的系统被演化成分布式集群系统后，系统可能会有多份并且部署在不同的机器上，这些资源已经不是在线程之间共享了，而是属于进程之间共享的资源。<br>指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。</p><p>分布式的 CAP 理论：</p><blockquote><p>任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。</p></blockquote><h3 id="分布式锁要满足哪些要求呢"><a href="#分布式锁要满足哪些要求呢" class="headerlink" title="分布式锁要满足哪些要求呢"></a>分布式锁要满足哪些要求呢</h3><ul><li>互斥性：在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>容错性：获取或释放锁的机制必须高可用且性能佳</li><li>解铃还须系铃人：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ul><h3 id="分布式锁实现方式"><a href="#分布式锁实现方式" class="headerlink" title="分布式锁实现方式"></a>分布式锁实现方式</h3><p>为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。</p><blockquote><p>基于数据库实现分布式锁；<br>基于缓存（Redis等）实现分布式锁；<br>基于Zookeeper实现分布式锁；</p></blockquote><h4 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h4><p>思路：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p><h4 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XttblogLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validParam</span><span class="params">(JedisPool jedisPool, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"jedisPool obj is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == lockKey || <span class="string">""</span>.equals(lockKey)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"lock key  is blank"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == requestId || <span class="string">""</span>.equals(requestId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"requestId is blank"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expireTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"expireTime is not allowed less zero"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(JedisPool jedisPool, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        validParam(jedisPool, lockKey, requestId, expireTime);</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">            <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">unLock</span><span class="params">(JedisPool jedisPool, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        validParam(jedisPool, lockKey, requestId, <span class="number">1</span>);</span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            Object result = jedis.eval(script, Collections.singletonList(lockKey),Collections.singletonList(requestId));</span><br><span class="line">            <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.core.RLock;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonLockUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RedissonLockUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Redisson redisson = RedissonManager.getRedisson();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_FLAG = <span class="string">"recruitlock_"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据name对进行上锁操作，redissonLock 阻塞的，采用的机制发布/订阅</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        String lockKey = LOCK_FLAG + key;</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        <span class="comment">//lock提供带timeout参数，timeout结束强制解锁，防止死锁 ：1分钟</span></span><br><span class="line">        lock.lock(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">        logger.info(<span class="string">"lock key:&#123;&#125;"</span>,lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据name对进行解锁操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        String lockKey = LOCK_FLAG + key;</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (lock.isHeldByCurrentThread())</span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            logger.info(<span class="string">"unlock , key:&#123;&#125;"</span>+lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> millisToWait 等待获取锁的时间--单位：秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String key, <span class="keyword">long</span> millisToWait)</span> </span>&#123;</span><br><span class="line">        String lockKey = LOCK_FLAG + key;</span><br><span class="line">        logger.info(<span class="string">"get redis lock start , key:&#123;&#125;"</span>+lockKey);</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        logger.info(<span class="string">"get redis lock end , key:"</span>+lockKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  lock.tryLock(millisToWait,<span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"try lock error,key is:&#123;&#125;"</span>, lockKey, e);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"get redis lock false , key:"</span>+lockKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line"> if (result == 1) &#123;</span><br><span class="line">     // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span><br><span class="line">     jedis.expire(lockKey, expireTime);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www.cnblogs.com/seesun2012/p/9214653.html" target="_blank" rel="noopener">https://www.cnblogs.com/seesun2012/p/9214653.html</a></p><p><a href="http://www.cnblogs.com/linjiqin/p/8003838.html" target="_blank" rel="noopener">http://www.cnblogs.com/linjiqin/p/8003838.html</a></p><p><a href="https://www.xttblog.com/?p=3171" target="_blank" rel="noopener">https://www.xttblog.com/?p=3171</a></p><p><a href="https://juejin.im/post/5c01532ef265da61362232ed" target="_blank" rel="noopener">https://juejin.im/post/5c01532ef265da61362232ed</a></p><p><img src="/myBlog/2018/11/10/分布式锁/bye.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2018/11/10/分布式锁/suo.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是分布式&quot;&gt;&lt;a href=&quot;#什么是分布式&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式&quot;&gt;&lt;/a&gt;什么是分布式&lt;/h3&gt;&lt;p&gt;将系统差分成不同的服务然后将这些服务放在不同服务器减轻单台服务的压力，提高性能和并发量。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="分布式" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/10/15/Dubbo/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/10/15/Dubbo/</id>
    <published>2018-10-15T03:35:25.000Z</published>
    <updated>2019-05-24T06:17:12.617Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo 工作原理：服务注册、注册中心、消费者、代理通信、负载均衡；</p><p><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">Dubbo</a></p><p><a href="https://www.cnblogs.com/hd3013779515/p/6896942.html" target="_blank" rel="noopener">Dubbo集群容错</a></p><p>一般的mvc项目 包含 Controller、Servicei、ServiceImpl、dao三层<br>使用doubbo我们可以把项目拆分：<br>Controller 作为 “消费着” 一个项目<br>ServiceImpl +dao 作为 “提供者” 一个项目</p><p>Service “接口” 可以作为一个项目</p><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-operating-principle.md" target="_blank" rel="noopener">https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-operating-principle.md</a></p><p><img src="/myBlog/2018/10/15/Dubbo/dubbo-operating-principle.png" alt="dubbo-operating-principle"></p><p>Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</p><p><strong>节点角色说明：</strong></p><pre><code>*  Provider: 暴露服务的服务提供方。*  Consumer: 调用远程服务的服务消费方。*  Registry: 服务注册与发现的注册中心。*  Monitor: 统计服务的调用次调和调用时间的监控中心。*  Container: 服务运行容器。</code></pre><a id="more"></a><p><img src="/myBlog/2018/10/15/Dubbo/dubbo.jpg" alt="Dubbo"></p><p>###　<strong>工作流程</strong></p><pre><code>第一步：provider向注册中心注册服务第二部：consumer从注册中心订阅服务，注册中心会通知consumer注册好的服务第三部：consumer调用provider第四步：provider和consumer都异步通知监控中心</code></pre><h3 id="调用关系说明："><a href="#调用关系说明：" class="headerlink" title="调用关系说明："></a><strong>调用关系说明：</strong></h3><pre><code>* 服务容器负责启动，加载，运行服务提供者。* 服务提供者在启动时，向注册中心注册自己提供的服务。* 服务消费者在启动时，向注册中心订阅自己所需的服务。* 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。* 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。* 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</code></pre><h3 id="Dubbo-负载均衡策略"><a href="#Dubbo-负载均衡策略" class="headerlink" title="Dubbo 负载均衡策略"></a><strong>Dubbo 负载均衡策略</strong></h3><p>  1.random load balance：<strong>随机</strong>调用实现负载均衡，可以对 provider不同实例<strong>设置不同的权重</strong>，会按照权重来负载均衡，权重越大分配流量越高。<br>  2.roundrobin loadbalance:<strong>均匀</strong>的打到各个机器，可以将性能差的机器权重小一点。<br>  3.leastactive loadbalance：<strong>自动感知</strong>，如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给<strong>不活跃的性能差的机器更少的请求</strong>。<br>  4.consistanthash loadbalance：一致性 Hash 算法，<strong>相同参数的请求</strong>一定分发到一个 provider 上去，provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。如果需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性 Hash 策略。</p><h3 id="Dubbo-集群容错策略"><a href="#Dubbo-集群容错策略" class="headerlink" title="Dubbo 集群容错策略"></a><strong>Dubbo 集群容错策略</strong></h3><p>  1.failover cluster ：<strong>失败自动切换</strong>，自动重试其他机器，默认就是这个，常见于<strong>读操作</strong>。（失败重试其它机器）<code>&lt;dubbo:service retries=&quot;2&quot; /&gt;</code><br>  2.failfast cluster ：一次调用失败就立即失败，常见于<strong>幂等性写操作</strong>。（调用失败就立即失败）<br>  3.failsafe cluster ：出现异常时忽略掉，常用于不重要的接口调用，比如<strong>记录日志</strong>。<br>  4.failback cluster ：失败了后台自动记录请求，然后定时重发，比较适合于<strong>写消息队列</strong>这种。<br>  5.forking  cluster ：并行调用多个 provider，只要一个成功就立即返回。常用于<strong>实时性要求比较高的读操作</strong>，但是会浪费资源。<br>  6.broadcast cluster：逐个调用所有的 provider。通常用于<strong>通知</strong>所有提供者更新缓存或日志等本地资源信息。</p><p>用 Spring 配置声明暴露服务<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"hello-world-app"</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.dubbo.demo.provider.DemoServiceImpl"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>加载Spring配置Provider.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"http://10.20.160.198/wiki/display/dubbo/provider.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line"></span><br><span class="line">        System.in.read(); <span class="comment">// 按任意键退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务消费者<br>通过Spring配置引用远程服务<br>consumer.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"consumer-of-helloworld-app"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> /&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>加载Spring配置，并调用远程服务<br>Consumer.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"http://10.20.160.198/wiki/display/dubbo/consumer.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line"></span><br><span class="line">        DemoService demoService = (DemoService)context.getBean(<span class="string">"demoService"</span>); <span class="comment">// 获取远程服务代理</span></span><br><span class="line">        String hello = demoService.sayHello(<span class="string">"world"</span>); <span class="comment">// 执行远程方法</span></span><br><span class="line"></span><br><span class="line">        System.out.println( hello ); <span class="comment">// 显示调用结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注册中心挂了还可以继续通信：因为刚开始初始化的时候，消费者会将服务提供者的地址拉取到本地。</p><p>通信协议：<br>    dubbo：单一长连接，进行NIO异步通信，基于<strong>hessian</strong>序列化协议。（长连接，通俗说就是建立连接之后可以持续发送请求，无需再建立连接）<br>               使用场景是传输数据量小（100kb以内），并发量高。<br>    rmi：java 的二进制序列化，适用于文件传输。<br>    hessian：hessian序列化<br>    http：json序列化<br>    webservice：soap文本序列化</p><p>服务治理：1.调用链路自动生成 2.服务访问压力及时长<br>服务降级：服务A调用服务B，B挂掉了，A重试几次还是不行，降级，走一个备用逻辑返回给用户。<br>失败重试超时重试：consumer调用provider失败了，可以重试，或者调用超时了也可以重试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dubbo 工作原理：服务注册、注册中心、消费者、代理通信、负载均衡；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dubbo.apache.org/zh-cn/docs/user/quick-start.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dubbo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hd3013779515/p/6896942.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dubbo集群容错&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一般的mvc项目 包含 Controller、Servicei、ServiceImpl、dao三层&lt;br&gt;使用doubbo我们可以把项目拆分：&lt;br&gt;Controller 作为 “消费着” 一个项目&lt;br&gt;ServiceImpl +dao 作为 “提供者” 一个项目&lt;/p&gt;
&lt;p&gt;Service “接口” 可以作为一个项目&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-operating-principle.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-operating-principle.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/myBlog/2018/10/15/Dubbo/dubbo-operating-principle.png&quot; alt=&quot;dubbo-operating-principle&quot;&gt;&lt;/p&gt;
&lt;p&gt;Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点角色说明：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*  Provider: 暴露服务的服务提供方。
*  Consumer: 调用远程服务的服务消费方。
*  Registry: 服务注册与发现的注册中心。
*  Monitor: 统计服务的调用次调和调用时间的监控中心。
*  Container: 服务运行容器。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="分布式" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Dubbo" scheme="https://zhangzhang18.github.io/myBlog/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Spring+Shiro+Redis实践</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/08/08/Spring+Shiro+Redis%E5%AE%9E%E8%B7%B5/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/08/08/Spring+Shiro+Redis实践/</id>
    <published>2018-08-08T06:32:27.000Z</published>
    <updated>2019-01-18T10:56:24.772Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Shiro是Java的一个安全框架。<br>使用Spring+Shiro+Redis完成登录注册，权限认证的功能。<br><img src="/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro-core.png" alt="core"><br><a id="more"></a><br>Subject本质上就是当前访问用户的抽象描述。所有</p><p><img src="/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro.png" alt="shiro"></p><p><img src="/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro-action.png" alt="action"><br><img src="/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro-diagram.png" alt="diagram"></p><p><a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">参考张开涛《跟我学Shiro教程》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache Shiro是Java的一个安全框架。&lt;br&gt;使用Spring+Shiro+Redis完成登录注册，权限认证的功能。&lt;br&gt;&lt;img src=&quot;/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro-core.png&quot; alt=&quot;core&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="Spring" scheme="https://zhangzhang18.github.io/myBlog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JAVA-IO</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/05/18/JAVA-IO/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/05/18/JAVA-IO/</id>
    <published>2018-05-18T07:44:56.000Z</published>
    <updated>2019-02-18T10:16:04.380Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式：装饰者模式<br><img src="/myBlog/2018/05/18/JAVA-IO/iostream.png" alt="iostream"></p><a id="more"></a><p><strong>NIO</strong><br><a href="https://link.juejin.im/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU4NDQ4MzU5OA%3D%3D%26mid%3D2247483956%26idx%3D1%26sn%3D57692bc5b7c2c6dfb812489baadc29c9%26chksm%3Dfd985455caefdd4331d828d8e89b22f19b304aa87d6da73c5d8c66fcef16e4c0b448b1a6f791%23rd" target="_blank" rel="noopener">Snailclimb Java NIO 概览</a></p><ul><li>IO是面向流的，NIO是面向缓冲区的</li><li>IO流是阻塞的，NIO流是不阻塞的。</li><li>NIO有选择器，而IO没有。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式：装饰者模式&lt;br&gt;&lt;img src=&quot;/myBlog/2018/05/18/JAVA-IO/iostream.png&quot; alt=&quot;iostream&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="IO" scheme="https://zhangzhang18.github.io/myBlog/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Spring-事物</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/02/16/Spring-%E4%BA%8B%E7%89%A9/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/02/16/Spring-事物/</id>
    <published>2018-02-16T04:50:21.000Z</published>
    <updated>2019-10-11T05:58:35.750Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2018/02/16/Spring-事物/shiwu.png" alt="事物"><br><a id="more"></a></p><ol><li>原子性：要么全部执行成功，要么全部执行失败</li><li>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏</li><li>隔离性：并发的食物是互相隔离的，一个事物执行不被其他事物影响</li><li><p>持久性：事物一旦提交，对数据库的改变是永久性的</p></li><li><p>脏读：指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p></li><li>不可重复读：一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li><li>幻读：同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。幻读和不可重复读都是读取了另一条已经提交的事务</li></ol><p>MySQL数据库提供的四种隔离级别：</p><p>　　① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</p><p>　　② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</p><p>　　③ Read committed (读已提交)：可避免脏读的发生。</p><p>　　④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p><p><a href="https://blog.csdn.net/bao19901210/article/details/41724355" target="_blank" rel="noopener">spring事物配置</a><br>事务隔离级别</p><p><strong>隔离级别是指若干个并发的事务之间的隔离程度</strong>。TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><blockquote><ul><li>TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。</li><li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。</li><li>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li><li>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。</li><li>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul></blockquote><hr><p>事务传播行为</p><p>所谓事务的传播行为是指，<strong>如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。</strong> 在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p><blockquote><ul><li>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</li><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul></blockquote><hr><p>数据库范式</p><p>第一范式：所有字段值都是不可分解的原子值（属性不可分）</p><p>第二范式：也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。（符合1NF，并且，非主属性完全依赖于码。）</p><p>第三范式：每一列数据都和主键直接相关，而不能间接相关。（符合2NF，并且，消除传递依赖）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2018/02/16/Spring-事物/shiwu.png&quot; alt=&quot;事物&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring-AOP</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/01/20/Spring-AOP/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/01/20/Spring-AOP/</id>
    <published>2018-01-20T09:27:23.000Z</published>
    <updated>2019-09-26T02:42:05.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-AOP面向切面编程"><a href="#3-AOP面向切面编程" class="headerlink" title="3.AOP面向切面编程"></a>3.AOP面向切面编程</h1><blockquote><p>OOP面向对象编程的基本单位是<strong>类</strong>，AOP的基本单位是<strong>方法</strong><br>适用于具有横切逻辑的应用场景，例如性能检测、范文控制、事物管理、及日志管理</p></blockquote><p>AOP希望将分散在各个业务逻辑代码中的相同代码通过横向切割的方式抽取到一个独立独立的模块中。<br><a id="more"></a></p><h2 id="3-1概念和术语"><a href="#3-1概念和术语" class="headerlink" title="3.1概念和术语"></a>3.1概念和术语</h2><ol><li>Aspect(切面):切面通常是指一个类，是通知和切入点的结合，@Aspect类注解。</li><li>Join point(连接点):程序执行的某个特定位置，例如类初始化前，类初始化后，方法执行前，方法执行后，方法抛出异常时等，Spring只支持方法级别的连接点，即方法执行前，方法执行后，方法抛出异常时，</li><li>Advice(增强):增强是织入到目标类连接点上的一段程序代码</li><li>Pointcut(切点):每个程序类都拥有多个连接点，如一个拥有两个方法的类，这两个方法都是连接点，即连接点是程序类中客观存在的事物 @Pointcut(“”)</li><li>Introduction(引介):允许向现有的类添加新方法或属性</li><li>Target object(目标对象):增强逻辑的织入目标类</li><li>AOP proxy(代理):一个类被AOP织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类</li><li>Weaving(织入):织入是将增强添加对目标类具体连接点上的过程<br>AOP有三种织入的方式：<ul><li>a、编译期织入，这要求使用特殊的Java编译器。</li><li>b、类装载期织入，这要求使用特殊的类装载器ClassLoader。</li><li>c、动态代理织入，在运行期为目标类添加增强生成子类的方式。<br>Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。</li></ul></li></ol><h3 id="3-1-1实现"><a href="#3-1-1实现" class="headerlink" title="3.1.1实现"></a>3.1.1实现</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>  <span class="attr">poxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"testAspect"</span> <span class="attr">class</span>=<span class="string">"com.test.company.aop.TestAspect"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切面就是切点和通知的组合体</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 切点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(*com.test.company.service.Impl.TestImpl.insert(..))"</span>)<span class="comment">//Pointcut 使用pointcut定义切点</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertPointcut</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 环绕通知</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"insertPointcut()"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">insert</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable</span>&#123;&#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 前置通知</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(*com.test.company.service.Impl.TestImpl.insert(..))"</span>)<span class="comment">//execution(*insert(..)) 切点表达式“execution”为关键字，“*insert(..)”为操作参数</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Before</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * returnVal,切点方法执行后的返回值</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="meta">@AfterReturning</span>(value=<span class="string">"execution(*com.test.company.service.Impl.TestImpl.insert(..))"</span>,returning = <span class="string">"returnVal"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">(Object returnVal)</span></span>&#123; &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知有5种类型如下：</p><pre><code>before 目标方法执行前执行，前置通知after 目标方法执行后执行，后置通知after returning 目标方法返回时执行 ，后置返回通知after throwing 目标方法抛出异常时执行 异常通知around 在目标函数执行中执行，可控制目标函数是否执行，环绕通知</code></pre><h3 id="3-1-2-相关Java基础知识"><a href="#3-1-2-相关Java基础知识" class="headerlink" title="3.1.2 相关Java基础知识"></a>3.1.2 相关Java基础知识</h3><ol><li>代理模式<blockquote><p>为某对象提供一个代理，从而通过代理来访问这个对象。</p></blockquote></li></ol><p>代理模式有三种角色组成:</p><pre><code>抽象角色(卖票)：接口代理角色(车票代售点)：Proxy真实角色(火车站)：实现</code></pre><ol><li><p>动态代理<br>代理类在程序运行前就已经存在，那么这种代理方式被成为 静态代理<br>静态代理：是在编译class文件时生成得代码逻辑。</p></li><li><p>JDK动态代理 </p><blockquote><p>jdk动态代理是由java内部的反射机制来实现的</p></blockquote></li></ol><p>主要涉及java.lang.reflect 包中：Proxy和InvocationHandler</p><p>使用动态代理需要定义一个位于代理类与委托类之间的中介类,中介类需要实现InvocationHandler定义的横切逻辑，通过反射机制调用目标类的方法，动态的将横切逻辑和业务逻辑编织在一起，InvocationHandler接口只定义了一个invoke方法<br>通过”Proxy”类提供的一个newProxyInstance方法用来创建一个对象的代理对象</p><p>JDK动态代理：是JDK自带的功能;是java.lang.reflect.*包提供的方式，它必须借助一个接口才能产生代理对象。<br>    实现代理逻辑类必须去实现InvocationHandler类</p><pre><code>1. 建立代理对象和真实对象的关系（blind()）2. 实现代理逻辑方法（invoke()）</code></pre><p>CGLIB：是第三方提供的技术;不需要提供接口，只要有一个非抽象类就可以实现。</p><p>二者都是通过getProxy()生成代理对象。<br>Spring常用这两种，Mybatis还使用Javassist。<br>拦截器是JDK动态代理。</p><p><a href="https://zhuanlan.zhihu.com/p/25522841" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25522841</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3-AOP面向切面编程&quot;&gt;&lt;a href=&quot;#3-AOP面向切面编程&quot; class=&quot;headerlink&quot; title=&quot;3.AOP面向切面编程&quot;&gt;&lt;/a&gt;3.AOP面向切面编程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;OOP面向对象编程的基本单位是&lt;strong&gt;类&lt;/strong&gt;，AOP的基本单位是&lt;strong&gt;方法&lt;/strong&gt;&lt;br&gt;适用于具有横切逻辑的应用场景，例如性能检测、范文控制、事物管理、及日志管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AOP希望将分散在各个业务逻辑代码中的相同代码通过横向切割的方式抽取到一个独立独立的模块中。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Spring" scheme="https://zhangzhang18.github.io/myBlog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-IOC</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/01/16/Spring-IOC/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/01/16/Spring-IOC/</id>
    <published>2018-01-16T09:27:23.000Z</published>
    <updated>2019-01-21T08:46:13.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Spring框架简介"><a href="#1-Spring框架简介" class="headerlink" title="1.Spring框架简介"></a>1.Spring框架简介</h1><p>Spring框架是基于Java平台的，它为开发Java应用提供了全方位的基础设施支持，并且它很好地处理了这些基础设施，所以你只需要关注你的应用本身即可。</p><p>Spring可以使用POJO（普通的Java对象，plain old java objects）创建应用，并且可以将企业服务非侵入式地应用到POJO。这项功能适用于Java SE编程模型以及全部或部分的Java EE。<br><a id="more"></a></p><h1 id="2-Spring模块结构"><a href="#2-Spring模块结构" class="headerlink" title="2.Spring模块结构"></a>2.Spring模块结构</h1><p><img src="/myBlog/2018/01/16/Spring-IOC/core.jpg" alt="core"></p><h2 id="2-1-IOC-控制反转"><a href="#2-1-IOC-控制反转" class="headerlink" title="2.1 IOC 控制反转"></a>2.1 IOC 控制反转</h2><blockquote><p>IoC也称为依赖注入（DI）<br>是为了解决对象之间的耦合度过高的问题</p></blockquote><p>钟表拥有多个独立的齿轮，这些齿轮相互啮合在一起，齿轮相互啮合在一起，协同工作，共同完成某项任务。如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。与软件系统中对象之间的耦合关系非常相似</p><p>软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”。</p><p>借助于“第三方”实现具有依赖关系的对象之间的解耦，这个“第三方”也就是IOC容器。</p><p><strong>哪些方面的控制被反转了呢</strong></p><ul><li>获得依赖对象的过程被反转了</li></ul><p>所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p><p>把依赖注入应用到软件系统中，再来描述一下这个过程：</p><ul><li>对象A依赖于对象B,当对象 A需要用到对象B的时候，IOC容器就会立即创建一个对象B送给对象A。</li><li>IOC容器就是一个对象制造工厂，你需要什么，它会给你送去，你直接使用就行了，而再也不用去关心你所用的东西是如何制成的，也不用关心最后是怎么被销毁的，这一切全部由IOC容器包办。</li></ul><h3 id="2-1-1-相关Java基础知识"><a href="#2-1-1-相关Java基础知识" class="headerlink" title="2.1.1 相关Java基础知识"></a>2.1.1 相关Java基础知识</h3><p>IOC流程<br><img src="/myBlog/2018/01/16/Spring-IOC/ioc.png" alt="ioc"></p><p><strong>反射</strong>：Java语言允许通过程序化的方式间接对class操作，Class文件由类加载器转载后，JVM形成一份描述Class结构的元信息，通过元信息对象可以获取到构造函数，属性和方法等。<br>      通过这个元信息对象间接的调用Class对象的功能。</p><p>几个重要的反射类：</p><blockquote><p>ClassLoader，Class，Constructor，和Method </p></blockquote><p>ClassLoader：类装载器，把一个类装入到JVM。<br>   需要经过：</p><pre><code>- 1.装载- 2.链接 校验 准备  解析- 3.初始化</code></pre><h3 id="2-1-2-IOC容器中转配Bean"><a href="#2-1-2-IOC容器中转配Bean" class="headerlink" title="2.1.2 IOC容器中转配Bean"></a>2.1.2 IOC容器中转配Bean</h3><ol><li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views/"</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Spring 支持两种依赖注入方式：属性注入和构造函数注入，还支持工厂方法注入方式。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SpringBeanFactory.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BeanFactory.class) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String path = Config.getConfigFolder();</span><br><span class="line">                    <span class="keyword">if</span> (beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        beanFactory = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"/"</span> + path + <span class="string">"aplication-spring-dubbo.xml"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"初始化SpringDubbo Error"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"><span class="number">3</span>. **自动装配 - autowire=<span class="string">"自动装配类型"</span>**</span><br><span class="line">   - byName：根据名称自动匹配</span><br><span class="line">   - byType：根据类型自动匹配</span><br><span class="line">   - constructor：与byType类似，它只针对构造函数注入的</span><br><span class="line">   - autodetect：</span><br><span class="line"><span class="number">4</span>. **bean作用域 - scope=<span class="string">"作用域"</span>**</span><br><span class="line">   - singleton：在IOC容器中只存在一个实例，以单例的方式存在,默认值</span><br><span class="line">   - prototype：每次从容器调用Bean时，都返回一个新的实例</span><br><span class="line">   - request：每次HTTP请求都会创建一个新的Bean，只适用于WebApplicationContext环境</span><br><span class="line">   - session：同一个HTTP Session共享一个Bean，只适用于WebApplicationContext环境</span><br><span class="line">   - global-session：</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. **基于注解定义Bean**</span><br><span class="line"></span><br><span class="line"><span class="meta">@component</span>可以替代下面三种注解，为了清晰化，建议使用特定的注解</span><br><span class="line">   - <span class="meta">@Repository</span>：DAO层实现类</span><br><span class="line">   - <span class="meta">@Service</span>：Service实现类</span><br><span class="line">   - <span class="meta">@Controller</span>：Service实现类</span><br><span class="line">扫描包以应用注解的Bean</span><br><span class="line">```xml</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.test.company.*"</span> /&gt;</span><br></pre></td></tr></table></figure><p>Spring使用@Autowired注解实现Bean依赖注入<br>@Autowired默认按照byType匹配在容器中查找Bean<br>若想希望找不到Bean也不报NoSuchBeanDefinitionException异常，可以使用@Autowired(require=false)<br>@Qualifier注解可以限定Bean的名字</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Qualifier(&quot;userDaop&quot;)</span><br><span class="line">private UserDao userDao;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/wang-meng/p/5597490.html" target="_blank" rel="noopener">https://www.cnblogs.com/wang-meng/p/5597490.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Spring框架简介&quot;&gt;&lt;a href=&quot;#1-Spring框架简介&quot; class=&quot;headerlink&quot; title=&quot;1.Spring框架简介&quot;&gt;&lt;/a&gt;1.Spring框架简介&lt;/h1&gt;&lt;p&gt;Spring框架是基于Java平台的，它为开发Java应用提供了全方位的基础设施支持，并且它很好地处理了这些基础设施，所以你只需要关注你的应用本身即可。&lt;/p&gt;
&lt;p&gt;Spring可以使用POJO（普通的Java对象，plain old java objects）创建应用，并且可以将企业服务非侵入式地应用到POJO。这项功能适用于Java SE编程模型以及全部或部分的Java EE。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Spring" scheme="https://zhangzhang18.github.io/myBlog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>面试常用手写代码</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/10/12/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/10/12/面试常用手写代码/</id>
    <published>2017-10-12T13:07:31.000Z</published>
    <updated>2019-10-16T12:33:03.693Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,t,temp;</span><br><span class="line">  <span class="keyword">if</span>(left &gt;right)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  temp=a[left];</span><br><span class="line">  i=left;</span><br><span class="line">  j=right;</span><br><span class="line">  <span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(a[j]&gt;=temp&amp;&amp;i&lt;j)&#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a[i]&gt;=temp&amp;&amp;i&lt;j)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">        t=a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a[left]=a[i];</span><br><span class="line">  a[i]=temp;</span><br><span class="line">  quicpSort(left,i-<span class="number">1</span>);</span><br><span class="line">  quickSort(i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/myBlog/2017/10/12/面试常用手写代码/qs.png" alt="快速排序步骤"><br><img src="/myBlog/2017/10/12/面试常用手写代码/qs2.png" alt="快速排序理解"></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">           <span class="comment">//折半成两个小集合，分别进行递归</span></span><br><span class="line">           <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">           mergeSort(arr, start, mid);</span><br><span class="line">           mergeSort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">           <span class="comment">//把有序小集合，归并成大集合</span></span><br><span class="line">           merge(arr, start, mid, end);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//开辟额外大集合</span></span><br><span class="line">       <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">int</span> p1 = start, p2 = mid + <span class="number">1</span>, p = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//比较两个小集合放入大集合</span></span><br><span class="line">       <span class="keyword">while</span> (p1 &lt; mid &amp;&amp; p2 &lt; end) &#123;</span><br><span class="line">           <span class="keyword">if</span> (arr[p1] &lt;= arr[p2]) &#123;</span><br><span class="line">               temp[p++] = arr[p1++];</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               temp[p++] = arr[p2++];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//左侧有剩余</span></span><br><span class="line">       <span class="keyword">while</span> (p1 &lt; mid) &#123;</span><br><span class="line">           temp[p++] = arr[p1++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//右侧有剩余</span></span><br><span class="line">       <span class="keyword">while</span> (p2 &lt; end) &#123;</span><br><span class="line">           temp[p++] = arr[p2++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//复制回原数组</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">           arr[i + start] = temp[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/myBlog/2017/10/12/面试常用手写代码/ms.jpg" alt="归并图解"></p><p><img src="/myBlog/2017/10/12/面试常用手写代码/allSort.png" alt="排序对比"></p><h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><h2 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h2><p>volatile 的一个语义禁止指令重排优化。在读取变量的时候直接从内存读取，保证所有线程看到的变量值都是相同的，<br>synchronized关键字锁住类<br>进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//检查实例，如果不存在，就进入同步代码块</span></span><br><span class="line">      <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;<span class="comment">//  双重检测机制  </span></span><br><span class="line">          <span class="keyword">synchronized</span>(Singleton.class)&#123;<span class="comment">//1  同步锁 类对象加锁</span></span><br><span class="line">              <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;<span class="comment">//2  双重检测机制</span></span><br><span class="line">                  instance = <span class="keyword">new</span> Singleton();<span class="comment">//3  </span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/myBlog/2017/10/12/面试常用手写代码/single.jpg" alt="single"></p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JVM会组织反射获取枚举类的私有构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/myBlog/2017/10/12/面试常用手写代码/compare.jpg" alt="compare"></p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="单链表反转"><a href="#单链表反转" class="headerlink" title="单链表反转"></a>单链表反转</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">Node <span class="title">reverse</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node prev = <span class="keyword">null</span>;</span><br><span class="line">    Node now = head;</span><br><span class="line">    <span class="keyword">while</span> (now != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = now.next;</span><br><span class="line">        now.next = prev;</span><br><span class="line">        prev = now;</span><br><span class="line">        now = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除重复值"><a href="#删除重复值" class="headerlink" title="删除重复值"></a>删除重复值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">Node <span class="title">deleteRepeat</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == head || <span class="keyword">null</span> == head.next) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node pre = head;</span><br><span class="line">    Node cur = head.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == pre.val) &#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">meetingNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    <span class="keyword">if</span> (slow == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node fast = slow.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表中环入口节点"><a href="#链表中环入口节点" class="headerlink" title="链表中环入口节点"></a>链表中环入口节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">nodeOfLoop</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到相遇节点</span></span><br><span class="line">    Node meetingNode = meetingNode(head);</span><br><span class="line">    <span class="keyword">if</span> (meetingNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到环节点数</span></span><br><span class="line">    <span class="keyword">int</span> nodeInLoopNum = <span class="number">1</span>;</span><br><span class="line">    Node p1 = meetingNode;</span><br><span class="line">    <span class="keyword">while</span> (p1.next != meetingNode) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        ++nodeInLoopNum;</span><br><span class="line">    &#125;</span><br><span class="line">    p1 = head;</span><br><span class="line">    Node p2 = head;</span><br><span class="line">    <span class="comment">//p1先移动环节点数nodeInLoopNum步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeInLoopNum; i++) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后p1,p2以相同速度移动</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断两个链表是否相交"><a href="#判断两个链表是否相交" class="headerlink" title="判断两个链表是否相交"></a>判断两个链表是否相交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isIntersert</span><span class="params">(Node h1, Node h2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="keyword">null</span> || h2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node tail = h1;</span><br><span class="line">    Node tail2 = h2;</span><br><span class="line">    <span class="keyword">while</span> (tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (tail2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tail2 = tail2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail == tail2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="非递归遍历二叉树"><a href="#非递归遍历二叉树" class="headerlink" title="非递归遍历二叉树"></a>非递归遍历二叉树</h2><blockquote><p>栈：先入后出</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">           stack.push(head);</span><br><span class="line">           <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">               head = stack.pop();</span><br><span class="line">               System.out.print(head.val);</span><br><span class="line">               <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)</span><br><span class="line">                   stack.push(head.right);</span><br><span class="line">               <span class="keyword">if</span> (head.left != <span class="keyword">null</span>)</span><br><span class="line">                   stack.push(head.left);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">findDeep</span><span class="params">(BiTree root)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> deep = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;  </span><br><span class="line">        <span class="keyword">int</span> lchilddeep = findDeep(root.left);  </span><br><span class="line">        <span class="keyword">int</span> rchilddeep = findDeep(root.right);  </span><br><span class="line">        deep = lchilddeep &gt; rchilddeep ? lchilddeep + <span class="number">1</span> : rchilddeep + <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> deep;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断tree2是否为tree1子结构"><a href="#判断tree2是否为tree1子结构" class="headerlink" title="判断tree2是否为tree1子结构"></a>判断tree2是否为tree1子结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasSubTree</span><span class="params">(Tree root1, Tree root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1.value == root2.value) &#123;</span><br><span class="line">        result = tree1hasTree2(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = hasSubTree(root1.left, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        result = hasSubTree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tree1hasTree2</span><span class="params">(Tree root1, Tree root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root2 == <span class="keyword">null</span> || root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root1.value != root2.value) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree1hasTree2(root1.left, root2.left) &amp;&amp; tree1hasTree2(root1.right, root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="合并两个有序数据，结果任然有序"><a href="#合并两个有序数据，结果任然有序" class="headerlink" title="合并两个有序数据，结果任然有序"></a>合并两个有序数据，结果任然有序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result;</span><br><span class="line">    result = <span class="keyword">new</span> <span class="keyword">int</span>[a.length + b.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.length &amp;&amp; j &lt; b.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; b[j]) &#123;</span><br><span class="line">            result[k++] = a[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[k++] = b[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.length) &#123;</span><br><span class="line">        result[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; b.length) &#123;</span><br><span class="line">        result[k++] = b[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">         <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span> (key == arr[mid]) &#123;</span><br><span class="line">             <span class="keyword">return</span> mid;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; arr[mid]) &#123;</span><br><span class="line">             low = mid + <span class="number">1</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             high = mid - <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h2><h1 id="剪绳子求最大乘积"><a href="#剪绳子求最大乘积" class="headerlink" title="剪绳子求最大乘积"></a>剪绳子求最大乘积</h1><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ul><li>求问题的最优解</li><li>整体问题的最优解是依赖各个子问题的最优解</li><li>把大问题分解成若干小问题，小问题之间还有互相重叠的更小的子问题</li><li>从上往下分析问题，从下往上解决问题<br>  为了避免重复求解子问题通常先计算小问题的最优解并存储下来，在以此基础求取大问题最优解。　 　</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxCuttingSolution</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (length == <span class="number">3</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span>[] products = <span class="keyword">new</span> <span class="keyword">int</span>[length + <span class="number">1</span>];</span><br><span class="line">     products[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">     products[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">     products[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">     products[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">     <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">//i是顺序递增的，计算的顺序是自下而上的</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= length; i++) &#123;</span><br><span class="line">         max = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++) &#123;</span><br><span class="line">             <span class="comment">//在求f(i)之前，对于每一个j而言，f(j)都已经求解出来了</span></span><br><span class="line">             <span class="keyword">int</span> product = products[j] * products[i - j];</span><br><span class="line">             <span class="keyword">if</span> (max &lt; product) &#123;</span><br><span class="line">                 max = product;</span><br><span class="line">             &#125;</span><br><span class="line">             products[i] = max;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> products[length];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="贪婪算法"><a href="#贪婪算法" class="headerlink" title="贪婪算法"></a>贪婪算法</h2><p>每一步都做最贪婪得选择，基于这个选择，能够得到最优解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当长度&gt;=5时，尽可能多剪长度为3得绳子，当剩下绳子长度为4时，把绳子剪成长度为2得绳子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">maxCuttingSolution1</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尽可能剪去长度为3的绳子段</span></span><br><span class="line">    <span class="keyword">int</span> cutThree = length / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (length - cutThree * <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        cutThree -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cutTwo = (length - cutThree * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// pow(x, y) 返回 x 的 y 次幂。</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) Math.pow(<span class="number">3</span>, cutThree) * (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, cutTwo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;],n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quickSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; left,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; right)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i,j,t,temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(left &amp;gt;right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  temp=a[left];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  i=left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  j=right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(i!=j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(a[j]&amp;gt;=temp&amp;amp;&amp;amp;i&amp;lt;j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(a[i]&amp;gt;=temp&amp;amp;&amp;amp;i&amp;lt;j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i&amp;lt;j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t=a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[i]=a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[j]=t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a[left]=a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a[i]=temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  quicpSort(left,i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  quickSort(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="面试" scheme="https://zhangzhang18.github.io/myBlog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/10/01/synchronized/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/10/01/synchronized/</id>
    <published>2017-10-01T02:47:54.000Z</published>
    <updated>2019-01-21T07:41:29.966Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2017/10/01/synchronized/syn.jpg" alt="synchronized"><br>synchronized是一种同步锁<br>同一时刻只能有一个线程能获取到锁</p><ol><li>修饰代码块：同步代码块，作用域是{}里面的代码，作用的对象是调用这个代码块的对象。</li><li>修饰方法：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。</li><li>修饰静态的方法：作用范围是整个方法，作用对象是这个类的所有对象。</li><li>修饰类：作用范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。<a id="more"></a></li></ol><hr><p>1.<strong>synchronized 代码块</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">   synchronized(obj) &#123;</span><br><span class="line">   //一次只能有一个线程进入</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>synchronized锁住的是括号里的对象，不是代码。<br>当synchronized锁住一个对象时，别的线程也想拿到这个对象的锁，必须等待这个线程执行完释放锁，才能再次给这个对象加锁。</p><blockquote><p>example</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String lock=<span class="keyword">new</span> String();</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//1 synchronized (lock) 2//synchronized (SyncThread.class)3</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":a begin"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":a   end"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1,2,3</span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line"></span><br><span class="line">        SyncThread a = new SyncThread();</span><br><span class="line">        Thread t1 = new Thread(a);</span><br><span class="line">        Thread t2 = new Thread(a);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//3</span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line"></span><br><span class="line">        SyncThread a = new SyncThread();</span><br><span class="line">        SyncThread b = new SyncThread();</span><br><span class="line">        Thread t1 = new Thread(a);</span><br><span class="line">        Thread t2 = new Thread(b);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1,3输出</p><ul><li>t1—:a begin</li><li>t1—:a   end</li><li>t2—:a begin</li><li>t2—:a   end</li></ul><p>2输出</p><ul><li>t2—:a begin</li><li>t1—:a begin</li><li>t1—:a   end</li><li>t2—:a   end</li></ul><p>1是对类的当前实例加锁<br>2是对锁特定的实例加锁<br>3是对该类的所有对象都加了锁，该类所有的对象同一把锁。</p><p>1.<strong>synchronized 方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>example</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"funA-"</span>+Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException ie)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"funB-"</span>+Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ie)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cSync</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"cSync"</span>+Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ie)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg)&#123;</span><br><span class="line">//4</span><br><span class="line">       SyncThread a = new SyncThread();</span><br><span class="line">       Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               a.isSyncA();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">       Thread t2 =new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               a.isSyncB();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出</p><ul><li>funA-t1 : 4</li><li>funA-t1 : 3</li><li>funA-t1 : 2</li><li>funA-t1 : 1</li><li>funA-t1 : 0</li><li>funB-t2 : 4</li><li>funB-t2 : 3</li><li>funB-t2 : 2</li><li>funB-t2 : 1</li><li>funB-t2 : 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg)&#123;</span><br><span class="line"> //5</span><br><span class="line">       SyncThread a = new SyncThread();</span><br><span class="line">       Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               SyncThread.cSync();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">       Thread t2 =new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               SyncThread.cSync();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>cSynct1 : 4</li><li>cSynct1 : 3</li><li>cSynct1 : 2</li><li>cSynct1 : 1</li><li>cSynct1 : 0</li><li>cSynct2 : 4</li><li>cSynct2 : 3</li><li>cSynct2 : 2</li><li>cSynct2 : 1</li><li>cSynct2 : 0</li></ul><p>4是对象锁<br>3,5得到的锁是类的锁</p><p>4是防止多线程同时访问这个对象的synchronized方法，（如果这个对象有多个synchronized方法，只要有一个线程访问了一个synchronized方法，其他的线程不能访问这个对象的任一synchronized方法），不同对象的synchronized方法互不影响。</p><p>5是防止多线程中不同实例对象同时访问方法，它对类的所有实例起作用。</p><hr><p>synchronized的实现原理 </p><p>1,synchronized代码块 monitorenter //进入同步方法 monitorexit //退出同步方法 2,synchronized方法 ACC_SYNCHRONIZED指明该方法为同步方法</p><p><a href="https://www.cnblogs.com/lixuwu/p/5676143.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2017/10/01/synchronized/syn.jpg&quot; alt=&quot;synchronized&quot;&gt;&lt;br&gt;synchronized是一种同步锁&lt;br&gt;同一时刻只能有一个线程能获取到锁&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修饰代码块：同步代码块，作用域是{}里面的代码，作用的对象是调用这个代码块的对象。&lt;/li&gt;
&lt;li&gt;修饰方法：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。&lt;/li&gt;
&lt;li&gt;修饰静态的方法：作用范围是整个方法，作用对象是这个类的所有对象。&lt;/li&gt;
&lt;li&gt;修饰类：作用范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>编程规约 </title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/08/13/%E7%BC%96%E7%A0%81%E8%A7%84%E7%BA%A6/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/08/13/编码规约/</id>
    <published>2017-08-13T00:54:12.000Z</published>
    <updated>2019-10-15T09:15:21.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程规约"><a href="#编程规约" class="headerlink" title="编程规约"></a>编程规约</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ol start="7"><li>【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator<br>方式，如果并发操作，需要对 Iterator 对象加锁。<br>正例：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      list.add(<span class="string">"1"</span>);</span><br><span class="line">      list.add(<span class="string">"2"</span>);</span><br><span class="line">      Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">      <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">          String item = iterator.next();</span><br><span class="line">          <span class="keyword">if</span> (删除元素的条件) &#123;</span><br><span class="line">              iterator.remove();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ol><p>##　OOP规约</p><ol start="18"><li><p>【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。<br>说明：下例中，反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，<br>然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。<br>反例：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"start"</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; </span><br><span class="line">        str = str + <span class="string">"hello"</span>; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：  </p><ul><li>不允许被继承的类，如：String 类。  </li><li>不允许修改引用的域对象。  </li><li>不允许被重写的方法，如：POJO 类的 setter 方法。  </li><li>不允许运行过程中重新赋值的局部变量。  </li><li>避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构。  </li></ul><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><ol start="3"><li>【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件。<br>说明：如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间判断条件来代替。<br>反例：判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变成了负数，这样的话，活动无法终止。<h2 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h2></li></ol></li><li>【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*<em>内容</em>/格式，不得使用// xxx 方式。<br> 说明：在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。   </li><li>【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。<br> 说明：对子类的实现要求，或者调用注意事项，请一并说明。</li><li>【强制】所有的类都必须添加创建者和创建日期。  </li><li>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。  <h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2></li><li>【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</li><li>【推荐】及时清理不再使用的代码段或配置信息。<br>说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。<br>正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。   <h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2></li><li>【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。   </li><li>【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。<br>说明：本手册明确防止 NPE 是调用者的责任。   </li><li>【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：<br>1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。<br>反例：<code>public int f() { return Integer 对象}</code>， 如果为 null，自动解箱抛 NPE。<br>2） 数据库的查询结果可能为 null。<br>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。<br>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。<br>5） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。<br>6） 级联调用 <code>obj.getA().getB().getC()；</code>一连串调用，易产生 NPE。<br>正例：使用 JDK8 的 Optional 类来防止 NPE 问题。  </li><li>【参考】对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；<br>跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。<br>说明：关于 RPC 方法返回方式使用 Result 方式的理由：<br>1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。<br>2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。  </li><li>【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。<br>说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。<br>正例：一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br><code>private boolean checkParam(DTO dto) {...}</code>  <h2 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h2></li><li>【强制】日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。  </li><li>【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：<br><code>appName_logType_logName.log</code>。<br>logType:日志类型，如 <code>stats/monitor/access</code> 等；logName:日志描述。这种命名的好处：<br>通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。<br>正例：mppserver 应用中单独监控时区转换异常，如：<br><code>mppserver_monitor_timeZoneConvert.log</code><br>说明：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。   </li><li>【强制】避免重复打印日志，浪费磁盘空间，务必在 <code>log4j.xml</code> 中设置 <code>additivity=false</code>。<br>正例：<code>&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code>  </li><li>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。<br>正例：<code>logger.error(各类参数或者对象 toString() + &quot;_&quot; + e.getMessage(), e);</code>  <h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2></li><li>【强制】表单、AJAX 提交必须执行 CSRF 安全验证。<br>说明：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情的情况下对数据库中用户参数进行相应修改。  </li><li>【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。<br>说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。  <h1 id="MySql数据库"><a href="#MySql数据库" class="headerlink" title="MySql数据库"></a>MySql数据库</h1><h2 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h2></li><li>【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否）。<br>说明：任何字段如果为非负数，必须是 unsigned。<br>注意：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在<resultmap>设置从 is_xxx 到 Xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。<br>正例：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。   </resultmap></li><li>【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。  </li><li>【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。<br>说明：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。  </li><li>【强制】小数类型为 decimal，禁止使用 float 和 double。<br>说明：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。  </li><li>【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。  </li><li>【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。   </li><li>【强制】表必备三字段：id, gmt_create, gmt_modified。<br>说明：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 datetime 类型，前者现在时表示主动创建，后者过去分词表示被动更新。   </li><li>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。<br>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。  <h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2></li><li>【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<br>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。   </li><li>【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。<br>说明：即使双表 join 也要注意表索引、SQL 性能。  </li><li>【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。<br>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。  </li><li>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br>说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。  </li><li>【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。<br>正例：where a=? and b=? order by c; 索引：a_b_c<br>反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引a_b 无法排序。  </li><li>【推荐】利用覆盖索引来进行查询操作，避免回表。<br>说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。<br>正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index。  </li><li>【推荐】利用延迟关联或者子查询优化超多分页场景。<br>说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。<br>正例：先快速定位需要获取的 id 段，然后再关联：SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id  </li><li>【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts最好。<br>说明：<br>1）<strong>consts</strong> 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。<br>2）<strong>ref</strong> 指的是使用普通的索引（normal index）。<br>3）range 对索引进行范围检索。<br>反例：explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。  </li><li>【推荐】建组合索引的时候，区分度最高的在最左边。<br>正例：如果 where a=? and b=? ，如果 a 列的几乎接近于唯一值，那么只需要单建 idx_a索引即可。<br>说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：<code>where c&gt;? and d=?</code> 那么即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 idx_d_c。  </li></ol><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><ol><li>【强制】不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<br>说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。  </li><li>【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 <code>count(distinctcol1, col2)</code> 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。  </li><li>【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。  </li><li>【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。  </li><li>【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。  </li><li>【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。<br>说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。  <h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2></li><li>【参考】分层领域模型规约：<br> DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。  DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。  BO（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。  AO（Application Object）：应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。  VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。<br> Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。  </li><li>【强制】定义 GAV 遵从以下规则：<br>1） GroupID 格式：com.{公司/BU }.业务线 [.子业务线]，最多 4 级。<br>说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。<br>正例：com.taobao.jstorm 或 com.alibaba.dubbo.register<br>2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。<br>正例：dubbo-client / fastjson-api / jstorm-tool<br>3） Version：详细规定参考下方。  </li><li>【强制】二方库版本号命名方式：主版本号.次版本号.修订号<br>1） 主版本号：产品方向改变，或者大规模 API 不兼容，或者架构不兼容升级。 2） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的 API 不兼容修改。<br>3） 修订号：保持完全兼容性，修复 BUG、新增次要功能特性等。<br>说明：注意起始版本号必须为：1.0.0，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0  </li><li>【强制】线上应用不要依赖 SNAPSHOT 版本（安全包除外）。<br>说明：不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。  </li><li>【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变，必须明确评估和验证，建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一致，那么通过 dependency:tree 命令，找出差异点，进行<excludes>排除 jar 包。  </excludes></li><li>【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。  </li><li>【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。<br>说明：依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。  </li><li>【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的Version。<br>说明：在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。  </li><li>【推荐】所有 pom 文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在<dependencymanagement>语句块中。<br>说明：<dependencymanagement>里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version 和 scope 都读取自父 pom。而<dependencies>所有声明在主 pom 的 <dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。  <h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2></dependencies></dependencies></dependencymanagement></dependencymanagement></dependencies></li><li>【推荐】给 JVM 环境参数设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出 dump 信息。<br>说明：OOM 的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。  </li><li>【推荐】在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。  </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编程规约&quot;&gt;&lt;a href=&quot;#编程规约&quot; class=&quot;headerlink&quot; title=&quot;编程规约&quot;&gt;&lt;/a&gt;编程规约&lt;/h1&gt;&lt;h2 id=&quot;集合&quot;&gt;&lt;a href=&quot;#集合&quot; class=&quot;headerlink&quot; title=&quot;集合&quot;&gt;&lt;/a&gt;集合&lt;/h
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
  </entry>
  
  <entry>
    <title>Volatile关键字</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/08/01/volatile/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/08/01/volatile/</id>
    <published>2017-08-01T02:56:41.000Z</published>
    <updated>2019-10-15T07:19:57.459Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2017/08/01/volatile/vol.jpg" alt="volatile"></p><p><strong>Volatile 能够保证可见性。</strong></p><blockquote><p> volatile的两大特性：禁止重排序、内存可见性。</p></blockquote><pre><code>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。2）禁止进行指令重排序。</code></pre><a id="more"></a><p>并发编程中三大概念：<strong>原子性，有序性，可见性。</strong></p><hr><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>一个操作或者多个操作，要么全部执行并且执行过程中不会被任何一个因素打扰，要么就不会执行。<br>Java中，对于基本数据类型的变量读取和赋值操作是原子的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=10;   //1</span><br><span class="line">y=x;    //2</span><br><span class="line">x++;    //3</span><br><span class="line">x=x+1;  //4</span><br></pre></td></tr></table></figure><p>只有1是原子的操作。</p><p>2是两个操作，先读取x的值，在把x的值写入工作内存，这两个操作都是原子操作，放在一起就不是原子操作了。</p><p>3和4都是先读取x的值，在进行加一的操作，写入新的值。</p><p>只有简单的读取、赋值（变量之间赋值不是）才是原子操作。</p><p>可以通过synchronized和Lock解决原子性问题。</p><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>线程之间的可见性，一个线程修改共享变量的值，其他的线程能够得知这个修改。</p><p>Java中，volatile关键字来保证可见性。<br>被volatile修饰的变量，变量修改的值会立即更新到主内存，每次使用前立即从主内存刷新，当其他线程需要读取的时候。就会读取主存的值。</p><p>普通变量被修改的时候，什么时候写入主存是不确定的。当其他线程读取的时候可能还是原来的值，因此无法保证可见性。</p><p>synchronized和final能实现可见性</p><p>​    同步块：对一个变量执行unLock之前，必须把此变量同步回主内存中。</p><p>​    final：被final修饰的字段在构造器中一旦初始化完成， 并且构造器没有把“this”引用传递出去，其他线程就能看见这个final字段的值。</p><h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>程序执行的顺序按照代码先后执行。</p><p>指令重排序不会影响单个线程的执行，会影响到线程并发执行的正确性。</p><p>Java中允许编译器和处理器对指令进行重排序，volatile、和synchronized都可以保证有序性，</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1.状态标记量</p><h2 id="2-double-check"><a href="#2-double-check" class="headerlink" title="2.double check"></a>2.double check</h2><p>volatile实现原理</p><p>happen-before （先行发生原则）：判断数据是否存在竞争，线程是否安全的主要依据。</p><p>如果操作A先行发生于B，发生操作B之前，操作A产生的影响能被B观察到。</p><p>插入内存屏障：如果一个操作的执行结果对另一个操作可见，那么这两个操作之间必须要存在内存屏障(写之前StoreStore ，写之后StoreLoad)</p><p>volatile读操作性能消耗和普通变量几乎没差别，写操作可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令保证处理器不会发生乱序执行。</p><p>大多数场景下volatile总开销要比锁低。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2017/08/01/volatile/vol.jpg&quot; alt=&quot;volatile&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Volatile 能够保证可见性。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; volatile的两大特性：禁止重排序、内存可见性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的。
2）禁止进行指令重排序。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集算法</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/07/20/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/07/20/垃圾收集算法/</id>
    <published>2017-07-20T15:46:25.000Z</published>
    <updated>2019-10-15T06:09:51.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1.标记-清除算法"></a>1.标记-清除算法</h2><p>最基础的收集算法。<br>分为两个阶段：标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。<br>不足：效率，空间，标记清除后会产生大量不连续的内存碎片。<br><img src="/myBlog/2017/07/20/垃圾收集算法/ms.jpg" alt="标记-清除"><br><a id="more"></a></p><h2 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h2><p>解决效率问题。<br>将可用的内存按容量分为大小相等的两块，每次只使用一块。当一块用完了，将还存活的对象复制到另一块，然后再把已使用过的内存空间一次清理掉。<br><img src="/myBlog/2017/07/20/垃圾收集算法/copy.jpg" alt="复制算法"></p><h2 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3.标记-整理算法"></a>3.标记-整理算法</h2><p>复制算法有较多复制操作，效率问题。<br>根据老年代的特点，标记过程与标记-清除算法一样，后续操作让所有存活对象都像一端移动，然后直接清理掉边界以外的内存。<br><img src="/myBlog/2017/07/20/垃圾收集算法/mc.jpg" alt="标记-整理"></p><h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h2><p>在新生代中有大批对象死去，少量存活：复制算法。复制成本少。<br>老年代中对象存活率高，没有额外的空间对他进行担保：就必须使用 标记-清理 或 标记-整理 算法回收。</p><hr><p>一共有两种算法，一种是引用计数算法，每被引用一次计数器就+1，当引用为0就回收，不过这种算法有一个弊端就是，当对象之间互相引用的时候就永远不会回收，<br>所以用的最多的还是GC ROOTS可达性分析，看对象是否被GC ROOTS引用，那么哪些可以作为GC ROOTS呢？<br>有以下四种：1.栈里面的局部变量表，方法区的2.类静态属性引用的对象3.方法区中常量引用的对象，4.JNI本地变量栈中引用的对象<br><a href="http://www.importnew.com/13493.html" target="_blank" rel="noopener">http://www.importnew.com/13493.html</a><br><img src="/myBlog/2017/07/20/垃圾收集算法/root.jpg" alt="ROOTS引用"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-标记-清除算法&quot;&gt;&lt;a href=&quot;#1-标记-清除算法&quot; class=&quot;headerlink&quot; title=&quot;1.标记-清除算法&quot;&gt;&lt;/a&gt;1.标记-清除算法&lt;/h2&gt;&lt;p&gt;最基础的收集算法。&lt;br&gt;分为两个阶段：标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。&lt;br&gt;不足：效率，空间，标记清除后会产生大量不连续的内存碎片。&lt;br&gt;&lt;img src=&quot;/myBlog/2017/07/20/垃圾收集算法/ms.jpg&quot; alt=&quot;标记-清除&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://zhangzhang18.github.io/myBlog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/07/16/JAVA-%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/07/16/JAVA-类加载/</id>
    <published>2017-07-16T08:49:44.000Z</published>
    <updated>2019-10-15T07:23:42.463Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2017/07/16/JAVA-类加载/load.jpg" alt="类加载"></p><p>Java虚拟机加载类的全过程包括，加载，验证，准备，解析和初始化。<br><a id="more"></a></p><ul><li>加载：根据路径找到对应的class文件，导入</li><li>验证：检验加载的class文件正确性</li><li>准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</li><li>解析：给符号引用转换为直接引用(解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。)</li><li>初始化：对静态变量和静态代码块执行初始化工作</li></ul><p>何时触发初始化</p><ol><li>为一个类型创建一个新的对象实例时（比如new、反射、序列化）</li><li>调用一个类型的静态方法时（即在字节码中执行invokestatic指令）</li><li>调用一个类型或接口的静态字段，或者对这些静态字段执行赋值操作时（即在字节码中，执行getstatic或者putstatic指令），不过用final修饰的静态字段除外，它被初始化为一个编译时常量表达式</li><li>调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法）</li><li>初始化一个类的派生类时（Java虚拟机规范明确要求初始化一个类时，它的超类必须提前完成初始化操作，接口例外）</li><li>JVM启动包含main方法的启动类时。</li></ol><p>类加载器：</p><ul><li>Bootstrap ClassLoader(启动类加载器):负责加载系统类(jre/lib/rt.jar)</li><li>Extension ClassLoader(扩展类加载器):负责加载扩展类(jre/lib/ext/*.jar)</li><li>Applicaiton ClassLoader(应用程序类加载器):用于加载自己定义编写的类(classpath指定目录或jar中类)</li><li>User ClassLoader （用户自己实现的加载器）</li></ul><p>“双亲委派模型”简单来说就是：</p><ol><li>先检查需要加载的类是否已经被加载，如果没有被加载，则委托父加载器加载，父类继续检查，尝试请父类加载，这个过程是从下——-&gt; 上;</li><li>如果走到顶层发现类没有被加载过，那么会从顶层开始往下逐层尝试加载，这个过程是从上 ——&gt; 下;</li></ol><p><img src="/myBlog/2017/07/16/JAVA-类加载/parents.jpg" alt="parents"><br><img src="/myBlog/2017/07/16/JAVA-类加载/parents1.jpg" alt="parents1"></p><p>JAVA热部署实现<br>首先谈一下何为热部署（hotswap），热部署是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为。Java 类是通过 Java 虚拟机加载的，某个类的 class 文件在被 classloader 加载后，会生成对应的 Class 对象，之后就可以创建该类的实例。默认的虚拟机行为只会在启动时加载类，如果后期有一个类需要更新的话，单纯替换编译的 class 文件，Java 虚拟机是不会更新正在运行的 class。如果要实现热部署，最根本的方式是修改虚拟机的源代码，改变 classloader 的加载行为，使虚拟机能监听 class 文件的更新，重新加载 class 文件，这样的行为破坏性很大，为后续的 JVM 升级埋下了一个大坑。</p><p>另一种友好的方法是创建自己的 classloader 来加载需要监听的 class，这样就能控制类加载的时机，从而实现热部署。 </p><p> 热部署步骤：</p><p>1、销毁自定义classloader(被该加载器加载的class也会自动卸载)；</p><p>2、更新class</p><p>3、使用新的ClassLoader去加载class </p><p>JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）：</p><ul><li>该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。</li><li>加载该类的ClassLoader已经被GC。</li><li>该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法</li></ul><p><a href="https://juejin.im/post/57c66f386be3ff005851de05" target="_blank" rel="noopener">https://juejin.im/post/57c66f386be3ff005851de05</a><br><a href="https://juejin.im/post/5a1fad585188252ae93ab953" target="_blank" rel="noopener">https://juejin.im/post/5a1fad585188252ae93ab953</a><br><a href="https://www.cnblogs.com/aspirant/p/7200523.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/7200523.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2017/07/16/JAVA-类加载/load.jpg&quot; alt=&quot;类加载&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java虚拟机加载类的全过程包括，加载，验证，准备，解析和初始化。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://zhangzhang18.github.io/myBlog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存分配</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/07/13/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/07/13/JVM内存分配/</id>
    <published>2017-07-13T12:46:25.000Z</published>
    <updated>2019-10-15T05:59:51.501Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2017/07/13/JVM内存分配/jvm.jpg" alt="jvm"></p><h1 id="线程私有的："><a href="#线程私有的：" class="headerlink" title="线程私有的："></a>线程私有的：</h1><blockquote><p> 程序计数器  虚拟机栈  本地方法栈</p></blockquote><p>线程共享的：</p><blockquote><p>  堆  方法区  直接内存<br><a id="more"></a></p></blockquote><h2 id="1-程序计数器（PCR）【线程私有】"><a href="#1-程序计数器（PCR）【线程私有】" class="headerlink" title="1.程序计数器（PCR）【线程私有】"></a>1.程序计数器（PCR）【线程私有】</h2><p>可以看做当前线程所执行的<strong>字节码的行号指示器</strong>。(通过计数器得值选取下一条需要执行得字节码指令)<br>为了线程切换后能够恢复到正确执行位置，每条线程都需要独立的程序计数器，独立存储。  </p><h2 id="2-栈（JVM-stack）【线程私有】"><a href="#2-栈（JVM-stack）【线程私有】" class="headerlink" title="2.栈（JVM stack）【线程私有】"></a>2.栈（JVM stack）【线程私有】</h2><p>生命周期与线程相同。<br>描述的是<strong>Java方法</strong>执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储<strong>局部变量表，操作数栈，动态链接方法出口</strong>。<br>局部变量表存放了编译期可知得各种基本数据类型（boolean，byte，char，short，int，float，long，double），对象引用和returnAddress类型。<br>每个方法执行到完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。  </p><ul><li>StackOverflowError异常：如果线程请求得栈深度大于虚拟机允许得深度，抛出该异常。  </li><li>OutOfMemoryError异常：如果拓展时无法申请到足够内存，抛出该异常。  <h2 id="3-本地方法栈（Native-Method-Stack）【线程私有】"><a href="#3-本地方法栈（Native-Method-Stack）【线程私有】" class="headerlink" title="3.本地方法栈（Native Method Stack）【线程私有】"></a>3.本地方法栈（Native Method Stack）【线程私有】</h2>与JVM栈相似，本地方法栈是用的是虚拟机的native方法<br>与JVM栈一样会抛出StackOverflowError，OutOfMemoryError异常  <h2 id="4-堆（heap-【线程共享】"><a href="#4-堆（heap-【线程共享】" class="headerlink" title="4.堆（heap)【线程共享】"></a>4.堆（heap)【线程共享】</h2>是Java虚拟机管理内存中最大的一块。<br>是被所有线程共享的一块内存区域，此内存区域唯一目的是存放对象实例，几乎所有的对象及数组都要在这里分配内存。<br>是垃圾回收器管理的主要区域，因此很多时候也被称作“GC堆”。<br>现在收集器采用分代收集算法，所以Java堆还可以细分为：新生代，老年代；在细分（Eden空间，From Survivor空间，To Survivor空间），从内存分配角度来看，线程共享的Java堆可能划分出多个线程私有的分配缓存区（Thread Local Allocation Buffer, TLAB）。<br>Java堆可以位于物理上不连续的空间，但是逻辑上要连续。  </li><li>OutOfMemoryError：如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。<h2 id="5-方法区（Method）【线程共享】"><a href="#5-方法区（Method）【线程共享】" class="headerlink" title="5.方法区（Method）【线程共享】"></a>5.方法区（Method）【线程共享】</h2>域Java堆一样。是各个线程共享的内存区域，用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。<h2 id="6-运行时常量池（Runtime-Constant-Pool）"><a href="#6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="6.运行时常量池（Runtime Constant Pool）"></a>6.运行时常量池（Runtime Constant Pool）</h2>是方法区的一部分。<br>Class文件不仅有类的版本，字段，方法，接口描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。<h2 id="7-直接内存（Direct-Memory）"><a href="#7-直接内存（Direct-Memory）" class="headerlink" title="7.直接内存（Direct Memory）"></a>7.直接内存（Direct Memory）</h2>不是虚拟机运行数据区的一部分。<br>NIO（New Input/Output）类，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存。通过一个Java堆DirectByteBuffer对象作为这块内存的引用进行操作。<br>显著提高性能，因为避免了Java堆和Native堆来回复制数据。<h2 id="8、永久代、方法区和元空间之间的关系"><a href="#8、永久代、方法区和元空间之间的关系" class="headerlink" title="8、永久代、方法区和元空间之间的关系"></a>8、永久代、方法区和元空间之间的关系</h2> 《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。<br> 在1.7之前在(JDK1.2 ~ JDK6)的实现中，HotSpot 使用永久代实现方法区。<br> 在JDK1.8中，元空间取代了永久代，来实现方法区。</li></ul><hr><p><img src="/myBlog/2017/07/13/JVM内存分配/java内存.png" alt="java内存梳理图"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2017/07/13/JVM内存分配/jvm.jpg&quot; alt=&quot;jvm&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;线程私有的：&quot;&gt;&lt;a href=&quot;#线程私有的：&quot; class=&quot;headerlink&quot; title=&quot;线程私有的：&quot;&gt;&lt;/a&gt;线程私有的：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 程序计数器  虚拟机栈  本地方法栈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线程共享的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  堆  方法区  直接内存&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://zhangzhang18.github.io/myBlog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>HashMap归纳总结</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/05/12/HashMap%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/05/12/HashMap归纳总结/</id>
    <published>2017-05-12T13:49:01.000Z</published>
    <updated>2019-10-12T13:19:03.173Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2017/05/12/HashMap归纳总结/hashMap.jpg" alt="hashMap"></p><a id="more"></a><hr><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ol><li><strong>了解HashMap吗？</strong></li></ol><blockquote><ul><li>HashMap是一种键值对（Key-Value）形式的存储结构。</li><li>key和value都允许为null。</li><li>当key重复的时候会覆盖，value允许重复。</li><li>是无序的，不会按照put的顺序排序。</li><li>是非线程安全的。</li><li>HashMap的Entry是一个单向链表</li><li>默认初始长度是16</li></ul></blockquote><p><img src="/myBlog/2017/05/12/HashMap归纳总结/base.jpg" alt="base"></p><ol start="2"><li><strong>知道HashMap的工作原理吗？</strong></li></ol><blockquote><ul><li>内部是一个数组，数组元素Node是实现了Map.Entry(hash,key,value,next)，next非null的时候指向定位相同的另一个Entry。</li><li>使用put()传递键和值，先对键调用hashCode()方法，通过hashCode确定bucket位置存储Entry对象。当发生碰撞的时候，使用<strong>散列法</strong>处理碰撞节点，将旧的Entry的引用赋值给新的Entry的next上，就是一个链表，冲突的节点从<strong>链表头部插入</strong>，这样插入新的Entry就不需要遍历链表。</li><li>通过get()获取对象。</li></ul></blockquote><ol start="3"><li><strong>当两个对象的hashCode相同的时候，怎么获取值对象？</strong></li></ol><blockquote><ul><li>get方法先比较hashCode值，如果hashCode相等，就是用equal()方法比较。</li><li>== 号与equals()方法的区别:== 基本数据类型比较的是值，对象比较的是对象的地址值。<br>equals()继承自Object类。在所有没有重写equals()方法的类中，equals()内部是==，也是比较的地址值。然而，Java提供的所有类中，绝大多数类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值</li></ul></blockquote><ol start="4"><li><strong>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong></li></ol><blockquote><p>默认的负载因子大小为<strong>0.75</strong>，初始容量是16，,也就是说，当一个map填满了<strong>75%</strong>的bucket时候，就会发生resize。简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。</p></blockquote><ol start="5"><li><strong>重新调整HashMap大小存在什么问题？</strong></li></ol><blockquote><p>在多线程的情况下，整个HashMap中的元素都需要重新算一遍。rehash，成本非常大。<br>链表中节点的转移可能会出现死循环的情况。</p></blockquote><ol start="6"><li><strong>HashMap与HashTable的区别：</strong></li></ol><blockquote><ul><li>HashTable不接受为null的键值(key)和值(value)</li><li>Hashtable是线程安全的也是synchronized在单线程环境下它比HashMap要慢。</li></ul></blockquote><ol start="7"><li><strong>HashMap同步？</strong></li></ol><blockquote><p>Map m = Collections.synchronizeMap(hashMap);</p></blockquote><ol start="8"><li>高并发下的HashMap</li></ol><p>Rehash是HashMap在扩容时的一个步骤，HashMap的容量是有限的。使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。<br>这时候，HashMap需要扩展它的长度，也就是进行Resize。</p><p>Resize的条件是:HashMap.Size &gt;= Capacity * LoadFactor。</p><p>Resize要经过两个过程：扩容和ReHash</p><ol><li><p>扩容：创建一个新的Entry空数组，长度是原数组的2倍。</p></li><li><p>ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。</p></li></ol><p>Hash公式：index = HashCode（Key） &amp; （Length - 1）</p><p><img src="/myBlog/2017/05/12/HashMap归纳总结/ConcurrentHashMap.png" alt="ConcurrentHashMap"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/myBlog/2017/05/12/HashMap归纳总结/HashMap.jpg" alt="HashMap"></h2><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><blockquote><p>需要线程安全，那么就使用ConcurrentHashMap。</p></blockquote><p>HashTable是使用synchronized来锁住整张Hash表来实现线程安全。</p><p>一个 ConcurrentHashMap 由一个个 Segment 组成，Segment代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。<br>Segment 内部是由 数组+链表 组成的。<br>(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)<br><img src="/myBlog/2017/05/12/HashMap归纳总结/ConcurrentHashMap.jpg" alt="ConcurrentHashMap"></p><blockquote><p>（1）ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢</p><p>（2）LinkedList以链表形式实现，顺序插入、查找较慢，插入、删除方便</p></blockquote><p><a href="https://mp.weixin.qq.com/s/SyKckwLfV2ypJOzTFA7R_g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SyKckwLfV2ypJOzTFA7R_g</a></p><p><a href="https://mp.weixin.qq.com/s/__ZnkPAF6ucUqN8CVSVQeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/__ZnkPAF6ucUqN8CVSVQeA</a></p><p><a href="https://juejin.im/post/5a224e1551882535c56cb940" target="_blank" rel="noopener">https://juejin.im/post/5a224e1551882535c56cb940</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2017/05/12/HashMap归纳总结/hashMap.jpg&quot; alt=&quot;hashMap&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://zhangzhang18.github.io/myBlog/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>准备面试基础</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/03/01/%E9%9D%A2%E7%BB%8F%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/03/01/面经基础/</id>
    <published>2017-03-01T03:14:08.000Z</published>
    <updated>2019-10-15T08:15:10.716Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java内存区域-各个模块的作用"><a href="#java内存区域-各个模块的作用" class="headerlink" title="java内存区域, 各个模块的作用"></a>java内存区域, 各个模块的作用</h3><pre><code>线程共享：堆，方法区，直接内存  线程私有的：程序计数器，虚拟机栈，本地方法栈  程序计数器：记录线程执行的位置行数，为了线程切换后能恢复正确的执行位置  虚拟机栈：存储局部变量表，常量池的引用，方法的出口等，一个方法的执行意味着一个栈帧入栈出栈的过程  本地方法栈：与栈类似，它用的是虚拟机的native方法为保证线程中局部变量不被其他线程访问到，所以虚拟机栈和本地方法栈是线程私有的堆：是java虚拟机管理内存最大的一块，存储实例对象和数组，是垃圾回收管理主要区域  方法区：存储类信息，常量和静态变量，接口，变量，方法名等描述信息  </code></pre><a id="more"></a>    <h6 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h6><pre><code>1.引用计数法      给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。        不能解决项目引用的问题。    2.可达性分析法     利用JVM对象引用图，从根节点遍历对象应用图，同时标记遍历到的对象。遍历结束后未被标记的对象就是不在使用的对象了       可作为GC Roots的对象包括下面几种:         虚拟机栈(栈帧中的本地变量表)中引用的对象。          方法区中类静态属性引用的对象。         方法区中常量引用的对象。         本地方法栈中JNI(即一般说的Native方法)引用的对象。      1.标记-清除算法          算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。      它是最基础的收集算法，效率也很高，但是会带来两个明显的问题： 效率问题 空间问题（标记清除后会产生大量不连续的碎片）      2.复制算法        它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。3.标记-整理算法          根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。4.分代收集算法         根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</code></pre><h6 id="堆溢出-栈溢出举例-内存溢出与泄漏的区别并举例"><a href="#堆溢出-栈溢出举例-内存溢出与泄漏的区别并举例" class="headerlink" title="堆溢出,栈溢出举例, 内存溢出与泄漏的区别并举例"></a>堆溢出,栈溢出举例, 内存溢出与泄漏的区别并举例</h6><pre><code>堆OutOfMemoryError(Java heap space)：堆中主要存储的是对象。如果不断的new对象则会导致堆中的空间溢出 -Xms 去调整堆的大小  栈StackOverflowError：创建的栈帧超过了栈的深度，**死循环或递归调用**，-Xss 去调整栈的大小  内存泄露memory leak：1.在堆中申请的空间没有被释放，2。对象已经不在使用还在内存中保留   -Xms10M -Xmx10M控制           原因：1.静态集合类 2.各种连接不显示的close 3.监听器没有删除 4.变量不合理的作用域     内存溢出OutOfMemory：新建对象，对象所需要的内存大于堆剩余空间   -调大-Xmx          原因：代码中存在死循环或循环产生过多重复的对象实体              内存中加载的数据量过于庞大，如一次从数据库取出过多数据         </code></pre><h6 id="双亲委派模型-java类加载过程-每个过程做了什么"><a href="#双亲委派模型-java类加载过程-每个过程做了什么" class="headerlink" title="双亲委派模型, java类加载过程,每个过程做了什么"></a>双亲委派模型, java类加载过程,每个过程做了什么</h6><pre><code>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化  加载：找到class文件导入  验证：验证class文件正确性  准备：为类变量（静态变量）分配内存和设置初始值，（在方法区分配内存）`public static int value=123;`  解析：给符号引用转变为直接引用  初始化：对静态变量和静态代码块执行初始化工作双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。只有当父加载器在自己的搜索范围内找不到指定的类时，子加载器才会尝试自己去加载。     启动类加载器(Bootstrap ClassLoader)-&gt;扩展类加载器(Extension ClassLoader)-&gt;应用程序类加载器(Application ClassLoader)-&gt;自定义classLoader</code></pre><h6 id="java中的锁-乐观锁-悲观锁-自旋锁等等"><a href="#java中的锁-乐观锁-悲观锁-自旋锁等等" class="headerlink" title="java中的锁, 乐观锁,悲观锁, 自旋锁等等"></a>java中的锁, 乐观锁,悲观锁, 自旋锁等等</h6><pre><code>乐观锁：读取数据时不加锁，在更新操作的时候才对冲突检测  悲观锁：操作数据的时候就上锁，所以整个处理过程数据都是被锁住的，synchronized就是悲观锁自旋锁：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。可重入锁:又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。 ReentrantLock  Synchronized  独享锁:是指该锁一次只能被一个线程所持有。    ReentrantLock Synchronized共享锁:是指该锁可被多个线程所持有。     ReadWriteLock，其读锁是共享锁，其写锁是独享锁分段锁:其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作https://www.cnblogs.com/lxmyhappy/p/7380073.html</code></pre><h6 id="ReentrantLock与synchronized"><a href="#ReentrantLock与synchronized" class="headerlink" title="ReentrantLock与synchronized"></a>ReentrantLock与synchronized</h6><pre><code>都是可重入锁    ReentrantLock是JDK实现的，synchronized是基于JVM实现的synchronized由编译器加锁和释放锁，ReentrantLock需要手动ReentrantLock是公平锁，就是先等待的线程可以先获得锁ReentrantLock可以分组唤醒线程ReentrantLock提供中断等待锁的机制lock.lockInterruptibly()</code></pre><h6 id="volatile的作用-CAS的原理-在java中哪些地方有用到"><a href="#volatile的作用-CAS的原理-在java中哪些地方有用到" class="headerlink" title="volatile的作用, CAS的原理, 在java中哪些地方有用到"></a>volatile的作用, CAS的原理, 在java中哪些地方有用到</h6><pre><code>volatile：保证线程可见性，一个线程修改了变量值，对其他线程是立即可见的CAS(比较并交换) 解决原子性；操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。   如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。   CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”https://blog.csdn.net/v123411739/article/details/79561458</code></pre><h6 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h6><pre><code>https://www.cnblogs.com/XHJT/p/3897440.htmlvolatile synchronized ReentrantLock</code></pre><h6 id="ConcurrentHashMap的原理-是如何保证多线程安全的"><a href="#ConcurrentHashMap的原理-是如何保证多线程安全的" class="headerlink" title="ConcurrentHashMap的原理,是如何保证多线程安全的"></a>ConcurrentHashMap的原理,是如何保证多线程安全的</h6><pre><code>https://www.cnblogs.com/ITtangtang/p/3948786.html</code></pre><h6 id="多线程的应用，理解"><a href="#多线程的应用，理解" class="headerlink" title="多线程的应用，理解"></a>多线程的应用，理解</h6><pre><code>多个线程同时运行，减少线程上下文切换的时间利用多线程可以提高系统整体并发能力及性能Java的内存模式：是从主存读取变量，线程吧变量保存在本地内存（寄存器）中，不是直接从主存进行读写，               一个线程修改主存的变量值，另一起还在使用寄存器中拷贝的值，造成数据不一致  volatile变量–多线程间可见 （每次都从主存进行读取）   synchronized-一时刻只能有一个线程能获取到锁  原子性：Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。  同步异步：   举例同步，你喊我吃饭，如果听见了，就一起去吃饭，如果没听见，你就不停喊，知道我听见才一起去吃饭，   异步，你喊我吃饭，然后自己去吃饭，我听到消息可能立刻走也可能等下班才去吃饭。</code></pre><h6 id="LRU原理-LinkedHashMap是如何实现的-LinkedHashMap数据结构源码"><a href="#LRU原理-LinkedHashMap是如何实现的-LinkedHashMap数据结构源码" class="headerlink" title="LRU原理, LinkedHashMap是如何实现的, LinkedHashMap数据结构源码"></a>LRU原理, LinkedHashMap是如何实现的, LinkedHashMap数据结构源码</h6><h6 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h6><pre><code>https://blog.csdn.net/ls5718/article/details/51896159   互斥条件，不剥夺条件，请求等待条件，循环等待</code></pre><h6 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h6><pre><code>索引就是个目录，字典的目录，有了目录就能更快的定位为了方便我们查找，提高查询的效率。缺点：索引需要维护成本，索引文件是单独存在的，数据的增删改 会产生会索引的额外操作，可能会影响增删改的速度原理：没有索引就是遍历整张表去查找      把无序的数据变成有序的查询，把随机变成顺序          1、把创建了索引的列的内容进行排序          2、对排序结果生成倒排表          3、在倒排表内容上拼上数据地址链          4、在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据      使用树形索引，还有哈希索引它适合单条查询    </code></pre><h6 id="联合索引查询优化-什么情况会失效-a-b-c分别建索引失效情况"><a href="#联合索引查询优化-什么情况会失效-a-b-c分别建索引失效情况" class="headerlink" title="联合索引查询优化, 什么情况会失效, a,b,c分别建索引失效情况"></a>联合索引查询优化, 什么情况会失效, a,b,c分别建索引失效情况</h6><h6 id="mysql存储引擎的对比-为什么用B-树实现"><a href="#mysql存储引擎的对比-为什么用B-树实现" class="headerlink" title="mysql存储引擎的对比, 为什么用B+树实现"></a>mysql存储引擎的对比, 为什么用B+树实现</h6><h6 id="事物的隔离级别，事物的实际应用"><a href="#事物的隔离级别，事物的实际应用" class="headerlink" title="事物的隔离级别，事物的实际应用"></a>事物的隔离级别，事物的实际应用</h6><pre><code>1.脏读：指在一个事务处理过程里读取了另一个未提交的事务中的数据。   2.不可重复读：一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。    3.幻读：同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。幻读和不可重复读都是读取了另一条已经提交的事务</code></pre><p>  <code>@Transactional(value = &quot;transactionManager&quot;, propagation = Propagation.REQUIRED,isolation = Isolation.READ_COMMITTED)</code></p><pre><code>隔离级别是指若干个并发的事务之间的隔离程度DEFAULT :默认的，     READ_UNCOMMITTED：读未提交，这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用     READ_COMMITED：读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读     REPEATABLE_READ：重复读取，明确数据读取出来就是为了更新用的，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决    SERLALIZABLE：串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题    </code></pre><h6 id="HAVING-用法，join用法"><a href="#HAVING-用法，join用法" class="headerlink" title="HAVING 用法，join用法"></a>HAVING 用法，join用法</h6><pre><code>WHERE 子句用来筛选 FROM 子句中指定的操作所产生的行。 GROUP BY 子句用来分组 WHERE 子句的输出。  HAVING 子句用来从分组的结果中筛选行。 HAVING 语法与 WHERE 语法类似，但 HAVING 可以包含聚合函数。 JOIN（inner join） 只有两个表格都满足条件，才会列出 LEFT JOIN 关键字会从左表那里返回所有的行，即使在右表中没有匹配的行。(RIGHT JOIN同理)</code></pre><h6 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h6><pre><code>确认应答（三次四次）,超时重传，流量控制，拥塞控制校验和：TCP将保持它首部和数据的检验和。</code></pre><p>######　解决幂等性问题</p><pre><code>幂等性：其任意多次执行对资源本身所产生的影响均与一次执行的影响相同，比如支付，下单。处理方式：每个请求有唯一标识，订单支付请求，订单id            处理完请求后，用一个纪录标识这个请求处理过了，常见方案是在数据库中记录状态             每次接受请求进行判断，比如订单已支付，数据库存在数据就不在处理了         redis请求加锁 乐观悲观锁</code></pre><p>######　表单的重复提交</p><pre><code>在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。              </code></pre><p>######　过滤器拦截器应用，区别</p><pre><code>filter-&gt;servlet-&gt;intercept-&gt;controller过滤器：Filter是实现了javax.servlet.Filter接口的服务器端程序过滤器用途：设置字符集，控制权限，过滤掉非法url，拦截器： SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor 来实现的拦截器用途：权限检查，如登录检查 创建一个Filter只需两个步骤    创建Filter处理类    web.xml文件中配置Filter 当web应用重新启动或销毁时，Filter也被销毁  void init(FilterConfig config):用于完成Filter的初始化。 void destory():用于Filter销毁前，完成某些资源的回收。 void doFilter(ServletRequest request,ServletResponse response,FilterChain chain):实现过滤功能拦截器实现 preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法，该方法将在请求处理之前进行调用。当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行； postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView) 方法，就是在当前请求进行处理之后，也就是Controller 方法调用之后执行 afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex) 方法，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。 过滤器和拦截器的区别： 　　①拦截器是基于java的反射机制的，而过滤器是基于函数回调。 　　②拦截器不依赖servlet容器，过滤器依赖servlet容器。 　　③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。 　　④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。 　　⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。 　　⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。 原文：https://blog.csdn.net/chenleixing/article/details/44573495 </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java内存区域-各个模块的作用&quot;&gt;&lt;a href=&quot;#java内存区域-各个模块的作用&quot; class=&quot;headerlink&quot; title=&quot;java内存区域, 各个模块的作用&quot;&gt;&lt;/a&gt;java内存区域, 各个模块的作用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;线程共享：堆，方法区，直接内存  
线程私有的：程序计数器，虚拟机栈，本地方法栈  

程序计数器：记录线程执行的位置行数，为了线程切换后能恢复正确的执行位置  
虚拟机栈：存储局部变量表，常量池的引用，方法的出口等，一个方法的执行意味着一个栈帧入栈出栈的过程  
本地方法栈：与栈类似，它用的是虚拟机的native方法
为保证线程中局部变量不被其他线程访问到，所以虚拟机栈和本地方法栈是线程私有的
堆：是java虚拟机管理内存最大的一块，存储实例对象和数组，是垃圾回收管理主要区域  
方法区：存储类信息，常量和静态变量，接口，变量，方法名等描述信息  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="面试" scheme="https://zhangzhang18.github.io/myBlog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>准备面试升级</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/03/01/%E9%9D%A2%E7%BB%8F%E5%8D%87%E7%BA%A7/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/03/01/面经升级/</id>
    <published>2017-03-01T03:14:08.000Z</published>
    <updated>2019-10-15T09:22:54.466Z</updated>
    
    <content type="html"><![CDATA[<h6 id="spring事务传播特性"><a href="#spring事务传播特性" class="headerlink" title="spring事务传播特性"></a>spring事务传播特性</h6><pre><code>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。   propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。    propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。    propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。     propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。    propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。     propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。     propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 </code></pre><h6 id="了解Spring使用到的设计模式吗？"><a href="#了解Spring使用到的设计模式吗？" class="headerlink" title="了解Spring使用到的设计模式吗？"></a>了解Spring使用到的设计模式吗？</h6><h6 id="说说对MQ理解"><a href="#说说对MQ理解" class="headerlink" title="说说对MQ理解"></a>说说对MQ理解</h6><pre><code>https://github.com/doocs/advanced-java作用：解耦、消峰、异步、广播如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。保证消息消费幂等性（重复消费问题）   1.写库时，先跟进主键确认是否已存在 2.redis的set 处理消息丢失问题 生产者   1.使用事物，如果失败就回滚，重试发送消息，成功便提交事务   2.开启confirm模式，持久化queue元数据，将消息持久化到磁盘，消息被持久化到磁盘，再通知生产者，</code></pre><h6 id="了解MQ-底层吗"><a href="#了解MQ-底层吗" class="headerlink" title="了解MQ 底层吗"></a>了解MQ 底层吗</h6><h6 id="为什么要用缓存"><a href="#为什么要用缓存" class="headerlink" title="为什么要用缓存"></a>为什么要用缓存</h6><pre><code>用缓存，主要有两个用途：高性能、高并发。高性能：就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。高并发：缓存是走内存的，内存天然就支撑高并发。</code></pre><h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><pre><code>缓存雪崩：缓存挂了，所有请求都打到数据库    缓存雪崩的事前事中事后的解决方案如下。     事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。     事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。     事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。缓存穿透：缓存中查不到，每次去数据库里查，也查不到。就会直接把数据库给打死    解决方式：从数据库中只要没查到，就写一个空值到缓存里去              然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。缓存击穿：就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。     解决方式：可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</code></pre><h6 id="Redis-过期策略"><a href="#Redis-过期策略" class="headerlink" title="Redis 过期策略"></a>Redis 过期策略</h6><pre><code>1.定期删除+惰性删除。所谓定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。惰性删除，获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。2.走内存淘汰机制---在内存不足容纳新的数据的的时候    a).noeviction :    新写入数据报错    b).allkeys-lru：   在所有键中，删除最近最少使用的键    c).allkeys-random：在所有键中，随机删除某个键    d).volatile-lru：  在设置过期时间的键中，删除最近最少使用的键    e).volatile-random:在设置过期时间的键中，随机删除某个键    f).volatile-ttl：  在设置过期时间的键中，删除最早过期的键</code></pre><h6 id="Redis-主从架构-哨兵集群实现高可用"><a href="#Redis-主从架构-哨兵集群实现高可用" class="headerlink" title="Redis 主从架构 哨兵集群实现高可用"></a>Redis 主从架构 哨兵集群实现高可用</h6><pre><code>一:主从架构   一主多从： 主负责写，并且将数据复制到从节点，从节点负责读</code></pre><h6 id="mysql-读写分离"><a href="#mysql-读写分离" class="headerlink" title="mysql 读写分离"></a>mysql 读写分离</h6><pre><code>主库将变更写到binlog中，当从库连接到主库后，从库有一个IO线程，将主库的binlog日志copy到自己本地，执行binlog中的日志内容，写入relay log，就是在自己本地再执行一遍sql。从库同步主库的数据过程是串行化的，也就是主库并行的操作，在从库会串行执行。高并发场景下，从库数据就会比主库慢，有延时如果主库突然宕机，数据还没同步到从库时，MySql有两个机制半同步复制和并行复制1:主库写入binlog后，强制立即将数据同步到从库，从库写入relay log后，从库会返回ask给主库，主库接收至少一个从库的ask才会认为写操作完成。2：从库开启多个线程，并行取relay log中不同库的数据，并行重放不同库的日志。</code></pre><h6 id="高并发系统设计"><a href="#高并发系统设计" class="headerlink" title="高并发系统设计"></a>高并发系统设计</h6><pre><code>1.系统拆分 2.缓存 3.MQ 4.分库分表 5.读写分离 6.ElasticSearch</code></pre><h6 id="说说一次-rpc-请求的流程？"><a href="#说说一次-rpc-请求的流程？" class="headerlink" title="说说一次 rpc 请求的流程？"></a>说说一次 rpc 请求的流程？</h6><pre><code>第一步：provider 向注册中心去注册第二步：consumer 从注册中心订阅服务，注册中心会通知 consumer 注册好的服务第三步：consumer 调用 provider第四步：consumer 和 provider 都异步通知监控中心Dubbo 传输协议：Dubbo缺省协议采用单一长连接和NIO异步通讯，</code></pre><p>注册中心挂了可以继续通信吗？</p><pre><code>可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。    </code></pre><h6 id="说说对zk的理解？"><a href="#说说对zk的理解？" class="headerlink" title="说说对zk的理解？"></a>说说对zk的理解？</h6><h5 id="注解的理解"><a href="#注解的理解" class="headerlink" title="注解的理解"></a>注解的理解</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;spring事务传播特性&quot;&gt;&lt;a href=&quot;#spring事务传播特性&quot; class=&quot;headerlink&quot; title=&quot;spring事务传播特性&quot;&gt;&lt;/a&gt;spring事务传播特性&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;事务传播行为就是多个事务方法相互调用时，事务
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="面试" scheme="https://zhangzhang18.github.io/myBlog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>常用Linux命令</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/01/16/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/01/16/常用Linux命令/</id>
    <published>2017-01-16T09:29:15.000Z</published>
    <updated>2019-10-11T09:58:34.923Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>ls　&ensp;&ensp;&ensp;&ensp;　        显示文件或目录</p><pre><code>-l           列出文件详细信息l(list)-a          列出当前目录下所有文件及目录，包括隐藏的a(all)</code></pre><p>mkdir  &ensp;&ensp;&ensp;&ensp;　       创建目录</p><pre><code>-p           创建目录，若无父目录，则创建p(parent)</code></pre><p>cd   &ensp;&ensp;&ensp;&ensp;　            切换目录</p><p>touch   &ensp;&ensp;&ensp;&ensp;　       创建空文件</p><p>echo   &ensp;&ensp;&ensp;&ensp;　         创建带有内容的文件。</p><p>cat    &ensp;&ensp;&ensp;&ensp;　          查看文件内容</p><p>cp     &ensp;&ensp;&ensp;&ensp;　           拷贝   cp [选项]… [-T] 源 目的</p><p>mv    &ensp;&ensp;&ensp;&ensp;　           移动或重命名</p><p>rm     &ensp;&ensp;&ensp;&ensp;　          删除文件</p><pre><code>-r            递归删除，可删除子目录及文件-f            强制删除</code></pre><p>find    &ensp;&ensp;&ensp;&ensp;　          在文件系统中搜索某文件</p><p>wc      &ensp;&ensp;&ensp;&ensp;　          统计文本中行数、字数、字符数</p><p>grep    &ensp;&ensp;&ensp;&ensp;　         在文本文件中查找某个字符串</p><p>rmdir    &ensp;&ensp;&ensp;&ensp;　       删除空目录</p><p>tree     &ensp;&ensp;&ensp;&ensp;　        树形结构显示目录，需要安装tree包</p><p>pwd      &ensp;&ensp;&ensp;&ensp;　        显示当前目录</p><p>ln      &ensp;&ensp;&ensp;&ensp;　            创建链接文件</p><p>more、less &ensp;&ensp;&ensp;&ensp;　 分页显示文本文件内容</p><p>head、tail   &ensp;&ensp;&ensp;&ensp;　 显示文件头、尾内容</p><p>ctrl+alt+F1 &ensp;&ensp;&ensp;&ensp;　 命令行全屏模式</p><p>##　打包压缩相关命令</p><p>gzip：</p><p>bzip2：</p><p>tar:                打包压缩</p><pre><code>-c              归档文件-x              压缩文件-z              gzip压缩文件-j              bzip2压缩文件-v              显示压缩或解压缩过程 v(view)-f              使用档名</code></pre><p>例：<br>tar -cvf /home/abc.tar /home/abc              只打包，不压缩</p><p>tar -zcvf /home/abc.tar.gz /home/abc        打包，并用gzip压缩</p><p>tar -jcvf /home/abc.tar.bz2 /home/abc      打包，并用bzip2压缩</p><p>当然，如果想解压缩，就直接替换上面的命令  tar -cvf  / tar -zcvf  / tar -jcvf 中的“c” 换成“x” 就可以了。</p><p>##　系统管理命令</p><p>stat    &ensp;&ensp;&ensp;&ensp;　          显示指定文件的详细信息，比ls更详细</p><p>who     &ensp;&ensp;&ensp;&ensp;　          显示在线登陆用户</p><p>whoami   &ensp;&ensp;&ensp;&ensp;　       显示当前操作用户</p><p>hostname  &ensp;&ensp;&ensp;&ensp;　    显示主机名</p><p>uname     &ensp;&ensp;&ensp;&ensp;　      显示系统信息</p><p>top     &ensp;&ensp;&ensp;&ensp;　           动态显示当前耗费资源最多进程信息</p><p>ps     &ensp;&ensp;&ensp;&ensp;　             显示瞬间进程状态 ps -aux</p><p>du    &ensp;&ensp;&ensp;&ensp;　              查看目录大小 du -h /home带有单位显示目录信息</p><p>df    &ensp;&ensp;&ensp;&ensp;　              查看磁盘大小 df -h 带有单位显示磁盘信息</p><p>ifconfig   &ensp;&ensp;&ensp;&ensp;　       查看网络情况</p><p>ping      &ensp;&ensp;&ensp;&ensp;　          测试网络连通</p><p>netstat    &ensp;&ensp;&ensp;&ensp;　      显示网络状态信息</p><p>man        &ensp;&ensp;&ensp;&ensp;　        命令不会用了，找男人  如：man ls</p><p>clear      &ensp;&ensp;&ensp;&ensp;　        清屏</p><p>alias     &ensp;&ensp;&ensp;&ensp;　          对命令重命名 如：alias showmeit=”ps -aux” ，另外解除使用unaliax showmeit</p><p>kill      &ensp;&ensp;&ensp;&ensp;　           杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;常用指令&quot;&gt;&lt;a href=&quot;#常用指令&quot; class=&quot;headerlink&quot; title=&quot;常用指令&quot;&gt;&lt;/a&gt;常用指令&lt;/h2&gt;&lt;p&gt;ls　&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;　        显示文件或目录&lt;
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Linux" scheme="https://zhangzhang18.github.io/myBlog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>leetcode</title>
    <link href="https://zhangzhang18.github.io/myBlog/2016/10/15/leetcode/"/>
    <id>https://zhangzhang18.github.io/myBlog/2016/10/15/leetcode/</id>
    <published>2016-10-15T03:35:25.000Z</published>
    <updated>2019-10-11T10:55:51.950Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="leetcode" scheme="https://zhangzhang18.github.io/myBlog/tags/leetcode/"/>
    
      <category term="算法" scheme="https://zhangzhang18.github.io/myBlog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
