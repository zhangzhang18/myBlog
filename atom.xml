<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>萌</title>
  
  <subtitle>冲鸭\(0^v^0)/</subtitle>
  <link href="/myBlog/atom.xml" rel="self"/>
  
  <link href="https://zhangzhang18.github.io/myBlog/"/>
  <updated>2019-01-18T07:54:15.079Z</updated>
  <id>https://zhangzhang18.github.io/myBlog/</id>
  
  <author>
    <name>萌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ZooKeeper</title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/01/16/ZooKeeper/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/01/16/ZooKeeper/</id>
    <published>2019-01-16T09:50:47.000Z</published>
    <updated>2019-01-18T07:54:15.079Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/11/10/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/11/10/分布式锁/</id>
    <published>2018-11-10T07:14:43.000Z</published>
    <updated>2019-01-16T07:30:18.240Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2018/11/10/分布式锁/suo.jpg" alt="image"></p><h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>为了实现多个线程在同一时刻同一代码块只能有一个线程可执行，需要在某个地方做标记，这个标记必须满足所有的线程可见，标记不存在的时候设置标记，后续的线程发现已标记则等待拥有标记的线程结束，同步代码块取消标记后，在尝试设置标记，这个标记可以理解为锁。</p><h3 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h3><p>单体单机部署的系统被演化成分布式集群系统后，系统可能会有多份并且部署在不同的机器上，这些资源已经不是在线程之间共享了，而是属于进程之间共享的资源。<br>指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。<br><a id="more"></a><br>分布式的 CAP 理论：</p><blockquote><p>任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。</p></blockquote><h3 id="分布式锁要满足哪些要求呢"><a href="#分布式锁要满足哪些要求呢" class="headerlink" title="分布式锁要满足哪些要求呢"></a>分布式锁要满足哪些要求呢</h3><ul><li>互斥性：在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>容错性：获取或释放锁的机制必须高可用且性能佳</li><li>解铃还须系铃人：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ul><h3 id="分布式锁实现方式"><a href="#分布式锁实现方式" class="headerlink" title="分布式锁实现方式"></a>分布式锁实现方式</h3><p>为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。</p><blockquote><p>基于数据库实现分布式锁；<br>基于缓存（Redis等）实现分布式锁；<br>基于Zookeeper实现分布式锁；</p></blockquote><h4 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h4><p>思路：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p><h4 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">public</span> class XttblogLock &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1</span>L;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> validParam(JedisPool jedisPool, <span class="keyword">String</span> lockKey, <span class="keyword">String</span> requestId, <span class="built_in">int</span> expireTime) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"jedisPool obj is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == lockKey || <span class="string">""</span>.equals(lockKey)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"lock key  is blank"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == requestId || <span class="string">""</span>.equals(requestId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"requestId is blank"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expireTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"expireTime is not allowed less zero"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> tryLock(JedisPool jedisPool, <span class="keyword">String</span> lockKey, <span class="keyword">String</span> requestId, <span class="built_in">int</span> expireTime) &#123;</span><br><span class="line">        validParam(jedisPool, lockKey, requestId, expireTime);</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            <span class="keyword">String</span> result = jedis.<span class="built_in">set</span>(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">            <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> unLock(JedisPool jedisPool, <span class="keyword">String</span> lockKey, <span class="keyword">String</span> requestId) &#123;</span><br><span class="line">        validParam(jedisPool, lockKey, requestId, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">String</span> script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            <span class="keyword">Object</span> result = jedis.eval(script, Collections.singletonList(lockKey),Collections.singletonList(requestId));</span><br><span class="line">            <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.core.RLock;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class RedissonLockUtil &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RedissonLockUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Redisson redisson = RedissonManager.getRedisson();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> LOCK_FLAG = <span class="string">"recruitlock_"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据name对进行上锁操作，redissonLock 阻塞的，采用的机制发布/订阅</span></span><br><span class="line"><span class="comment">     * @param key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> lock(<span class="keyword">String</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">        <span class="keyword">String</span> lockKey = LOCK_FLAG + <span class="built_in">key</span>;</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        <span class="comment">//lock提供带timeout参数，timeout结束强制解锁，防止死锁 ：1分钟</span></span><br><span class="line">        lock.lock(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">        logger.info(<span class="string">"lock key:&#123;&#125;"</span>,lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据name对进行解锁操作</span></span><br><span class="line"><span class="comment">     * @param key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> unlock(<span class="keyword">String</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">        <span class="keyword">String</span> lockKey = LOCK_FLAG + <span class="built_in">key</span>;</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (lock.isHeldByCurrentThread())</span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            logger.info(<span class="string">"unlock , key:&#123;&#125;"</span>+lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param key</span></span><br><span class="line"><span class="comment">     * @param millisToWait 等待获取锁的时间--单位：秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">boolean</span> tryLock(<span class="keyword">String</span> <span class="built_in">key</span>, <span class="keyword">long</span> millisToWait) &#123;</span><br><span class="line">        <span class="keyword">String</span> lockKey = LOCK_FLAG + <span class="built_in">key</span>;</span><br><span class="line">        logger.info(<span class="string">"get redis lock start , key:&#123;&#125;"</span>+lockKey);</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        logger.info(<span class="string">"get redis lock end , key:"</span>+lockKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  lock.tryLock(millisToWait,<span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"try lock error,key is:&#123;&#125;"</span>, lockKey, e);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"get redis lock false , key:"</span>+lockKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示例<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Long</span> result = jedis.setnx(lockKey, requestId);</span><br><span class="line"> <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">// 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span></span><br><span class="line">     jedis.expire(lockKey, expireTime);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www.cnblogs.com/seesun2012/p/9214653.html" target="_blank" rel="noopener">https://www.cnblogs.com/seesun2012/p/9214653.html</a></p><p><a href="http://www.cnblogs.com/linjiqin/p/8003838.html" target="_blank" rel="noopener">http://www.cnblogs.com/linjiqin/p/8003838.html</a></p><p><a href="https://www.xttblog.com/?p=3171" target="_blank" rel="noopener">https://www.xttblog.com/?p=3171</a></p><p><img src="/myBlog/2018/11/10/分布式锁/bye.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2018/11/10/分布式锁/suo.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是锁&quot;&gt;&lt;a href=&quot;#什么是锁&quot; class=&quot;headerlink&quot; title=&quot;什么是锁&quot;&gt;&lt;/a&gt;什么是锁&lt;/h3&gt;&lt;p&gt;为了实现多个线程在同一时刻同一代码块只能有一个线程可执行，需要在某个地方做标记，这个标记必须满足所有的线程可见，标记不存在的时候设置标记，后续的线程发现已标记则等待拥有标记的线程结束，同步代码块取消标记后，在尝试设置标记，这个标记可以理解为锁。&lt;/p&gt;
&lt;h3 id=&quot;什么是分布式锁&quot;&gt;&lt;a href=&quot;#什么是分布式锁&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式锁&quot;&gt;&lt;/a&gt;什么是分布式锁&lt;/h3&gt;&lt;p&gt;单体单机部署的系统被演化成分布式集群系统后，系统可能会有多份并且部署在不同的机器上，这些资源已经不是在线程之间共享了，而是属于进程之间共享的资源。&lt;br&gt;指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="分布式" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/10/15/Dubbo/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/10/15/Dubbo/</id>
    <published>2018-10-15T03:35:25.000Z</published>
    <updated>2019-01-18T10:51:31.197Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Redis归纳</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/08/18/Redis%E5%BD%92%E7%BA%B3/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/08/18/Redis归纳/</id>
    <published>2018-08-18T08:31:47.000Z</published>
    <updated>2019-01-16T09:22:40.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>一个基于内存的高性能的key-value数据库。</p><blockquote><p>数据结构：String字符串，Hash字典，List列表，Set集合，SortedSet有序集合。<br><a id="more"></a></p><ol><li><strong>使用Redis有哪些好处？</strong></li></ol></blockquote><blockquote><ul><li>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li><li>(2) 支持丰富数据类型，支持string，list，set，sorted set，hash</li><li>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ul></blockquote><p>2.<strong>为什么redis需要把所有数据放到内存中?</strong></p><blockquote><p>　Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。<br>　　　如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p></blockquote><p>3.<strong>Redis是单进程单线程的为什么也那么快？</strong></p><blockquote><p>　Redis快的主要原因是：</p><ul><li>完全基于内存</li><li>数据结构简单，对数据操作也简单</li><li>使用多路 I/O 复用模型</li></ul><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p></blockquote><p>4.<strong>Redis锁的使用。</strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Redisson redisson = RedissonManager.getRedisson();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> LOCK_FLAG = <span class="string">"mylock_"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据name对进行上锁操作，redissonLock 阻塞的，采用的机制发布/订阅</span></span><br><span class="line"><span class="comment">     * @param key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> lock(<span class="keyword">String</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">        <span class="keyword">String</span> lockKey = LOCK_FLAG + <span class="built_in">key</span>;</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        <span class="comment">//lock提供带timeout参数，timeout结束强制解锁，防止死锁 ：1分钟</span></span><br><span class="line">        lock.lock(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">        logger.info(<span class="string">"lock key:&#123;&#125;"</span>,lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据name对进行解锁操作</span></span><br><span class="line"><span class="comment">     * @param key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> unlock(<span class="keyword">String</span> <span class="built_in">key</span>)&#123;</span><br><span class="line">        <span class="keyword">String</span> lockKey = LOCK_FLAG + <span class="built_in">key</span>;</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        <span class="comment">//如果锁被当前线程持有，则释放</span></span><br><span class="line">        <span class="keyword">if</span>(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            logger.info(<span class="string">"unlock key:&#123;&#125;"</span>,lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h2&gt;&lt;p&gt;一个基于内存的高性能的key-value数据库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据结构：String字符串，Hash字典，List列表，Set集合，SortedSet有序集合。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Redis" scheme="https://zhangzhang18.github.io/myBlog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Spring+Shiro+Redis实践</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/08/08/Spring+Shiro+Redis%E5%AE%9E%E8%B7%B5/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/08/08/Spring+Shiro+Redis实践/</id>
    <published>2018-08-08T06:32:27.000Z</published>
    <updated>2019-01-16T07:30:51.023Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Shiro是Java的一个安全框架。<br>使用Spring+Shiro+Redis完成登录注册，权限认证的功能。<br><img src="/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro-core.png" alt="core"><br><a id="more"></a><br>Subject本质上就是当前访问用户的抽象描述。所有</p><p><img src="/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro.png" alt="shiro"></p><p><img src="/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro-action.png" alt="action"><br><img src="/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro-diagram.png" alt="diagram"></p><p><a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">参考张开涛《跟我学Shiro教程》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache Shiro是Java的一个安全框架。&lt;br&gt;使用Spring+Shiro+Redis完成登录注册，权限认证的功能。&lt;br&gt;&lt;img src=&quot;/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro-core.png&quot; alt=&quot;core&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="框架" scheme="https://zhangzhang18.github.io/myBlog/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/01/16/Elasticsearch/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/01/16/Elasticsearch/</id>
    <published>2018-01-16T09:51:02.000Z</published>
    <updated>2019-01-18T10:51:31.146Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/01/16/Spring/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/01/16/Spring/</id>
    <published>2018-01-16T09:27:23.000Z</published>
    <updated>2019-01-18T10:51:48.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Spring框架简介"><a href="#1-Spring框架简介" class="headerlink" title="1.Spring框架简介"></a>1.Spring框架简介</h1><p>Spring框架是基于Java平台的，它为开发Java应用提供了全方位的基础设施支持，并且它很好地处理了这些基础设施，所以你只需要关注你的应用本身即可。</p><p>Spring可以使用POJO（普通的Java对象，plain old java objects）创建应用，并且可以将企业服务非侵入式地应用到POJO。这项功能适用于Java SE编程模型以及全部或部分的Java EE。<br><a id="more"></a></p><h1 id="2-Spring模块结构"><a href="#2-Spring模块结构" class="headerlink" title="2.Spring模块结构"></a>2.Spring模块结构</h1><p><img src="/myBlog/2018/01/16/Spring/core.jpg" alt="core"></p><h2 id="2-1-IOC-控制反转"><a href="#2-1-IOC-控制反转" class="headerlink" title="2.1 IOC 控制反转"></a>2.1 IOC 控制反转</h2><blockquote><p>IoC也称为依赖注入（DI）<br>是为了解决对象之间的耦合度过高的问题</p></blockquote><p>钟表拥有多个独立的齿轮，这些齿轮相互啮合在一起，齿轮相互啮合在一起，协同工作，共同完成某项任务。如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。与软件系统中对象之间的耦合关系非常相似</p><p>软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”。</p><p>借助于“第三方”实现具有依赖关系的对象之间的解耦，这个“第三方”也就是IOC容器。</p><p><strong>哪些方面的控制被反转了呢</strong></p><ul><li>获得依赖对象的过程被反转了</li></ul><p>所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p><p>把依赖注入应用到软件系统中，再来描述一下这个过程：</p><ul><li>对象A依赖于对象B,当对象 A需要用到对象B的时候，IOC容器就会立即创建一个对象B送给对象A。</li><li>IOC容器就是一个对象制造工厂，你需要什么，它会给你送去，你直接使用就行了，而再也不用去关心你所用的东西是如何制成的，也不用关心最后是怎么被销毁的，这一切全部由IOC容器包办。</li></ul><h3 id="2-1-1-相关Java基础知识"><a href="#2-1-1-相关Java基础知识" class="headerlink" title="2.1.1 相关Java基础知识"></a>2.1.1 相关Java基础知识</h3><p>IOC流程<br><img src="/myBlog/2018/01/16/Spring/ioc.jpg" alt="ioc"></p><p><strong>反射</strong>：Java语言允许通过程序化的方式间接对class操作，Class文件由类加载器转载后，JVM形成一份描述Class结构的元信息，通过元信息对象可以获取到构造函数，属性和方法等。<br>      通过这个元信息对象间接的调用Class对象的功能。</p><p>几个重要的反射类：</p><blockquote><p>ClassLoader，Class，Constructor，和Method </p></blockquote><p>ClassLoader：类装载器，把一个类装入到JVM。<br>需要经过：</p><ul><li>1.装载</li><li>2.链接 校验 准备  解析</li><li>3.初始化</li></ul><h3 id="2-1-2-举个例子"><a href="#2-1-2-举个例子" class="headerlink" title="2.1.2 举个例子"></a>2.1.2 举个例子</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBeanFactory</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SpringBeanFactory.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> BeanFactory getBeanFactory() &#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BeanFactory.<span class="keyword">class</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String path = Config.getConfigFolder();</span><br><span class="line">                    <span class="keyword">if</span> (beanFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">                        beanFactory = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"/"</span> + path + <span class="string">"aplication-spring-dubbo.xml"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"初始化SpringDubbo Error"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/wang-meng/p/5597490.html" target="_blank" rel="noopener">https://www.cnblogs.com/wang-meng/p/5597490.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Spring框架简介&quot;&gt;&lt;a href=&quot;#1-Spring框架简介&quot; class=&quot;headerlink&quot; title=&quot;1.Spring框架简介&quot;&gt;&lt;/a&gt;1.Spring框架简介&lt;/h1&gt;&lt;p&gt;Spring框架是基于Java平台的，它为开发Java应用提供了全方位的基础设施支持，并且它很好地处理了这些基础设施，所以你只需要关注你的应用本身即可。&lt;/p&gt;
&lt;p&gt;Spring可以使用POJO（普通的Java对象，plain old java objects）创建应用，并且可以将企业服务非侵入式地应用到POJO。这项功能适用于Java SE编程模型以及全部或部分的Java EE。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="Spring" scheme="https://zhangzhang18.github.io/myBlog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/01/16/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/01/16/Java类加载/</id>
    <published>2018-01-16T08:49:44.000Z</published>
    <updated>2019-01-18T07:28:06.504Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://zhangzhang18.github.io/myBlog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>面试常用手写代码</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/10/12/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/10/12/面试常用手写代码/</id>
    <published>2017-10-12T13:07:31.000Z</published>
    <updated>2019-01-16T08:41:10.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int a[<span class="number">10</span>],n<span class="comment">;</span></span><br><span class="line">void quickSort(int left,int right)&#123;</span><br><span class="line">  int i,<span class="keyword">j,t,temp;</span></span><br><span class="line"><span class="keyword"> </span> if(left &gt;right)&#123;</span><br><span class="line">    return<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">  temp=a[left]<span class="comment">;</span></span><br><span class="line">  i=left<span class="comment">;</span></span><br><span class="line">  <span class="keyword">j=right;</span></span><br><span class="line"><span class="keyword"> </span> while(i!=<span class="keyword">j)&#123;</span></span><br><span class="line"><span class="keyword"> </span>   while(a[<span class="keyword">j]&gt;=temp&amp;&amp;i&lt;j)&#123;</span></span><br><span class="line"><span class="keyword"> </span>       <span class="keyword">j--;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">    while(a[i]&gt;=temp&amp;&amp;i&lt;<span class="keyword">j)&#123;</span></span><br><span class="line"><span class="keyword"> </span>       i++<span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line">    if(i&lt;<span class="keyword">j)&#123;</span></span><br><span class="line"><span class="keyword"> </span>       t=a[i]<span class="comment">;</span></span><br><span class="line">        a[i]=a[<span class="keyword">j];</span></span><br><span class="line"><span class="keyword"> </span>       a[<span class="keyword">j]=t;</span></span><br><span class="line"><span class="keyword"> </span>   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a[left]=a[i]<span class="comment">;</span></span><br><span class="line">  a[i]=temp<span class="comment">;</span></span><br><span class="line">  quicpSort(left,i-1)<span class="comment">;</span></span><br><span class="line">  quickSort(i+<span class="number">1</span>,right)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>volatile 的一个语义禁止指令重排优化。<br>synchronized关键字锁住类<br>进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance=<span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//检查实例，如果不存在，就进入同步代码块</span></span><br><span class="line">      <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;<span class="comment">//  双重检测机制</span></span><br><span class="line">          <span class="keyword">synchronized</span>(Singleton.class)&#123;<span class="comment">//1  同步锁</span></span><br><span class="line">              <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;<span class="comment">//2  双重检测机制</span></span><br><span class="line">                  instance=<span class="keyword">new</span> Singleton();<span class="comment">//3  </span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/myBlog/2017/10/12/面试常用手写代码/single.jpg" alt="single"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//enum JVM会组织反射获取枚举类的私有构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/myBlog/2017/10/12/面试常用手写代码/compare.jpg" alt="compare"></p><h2 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">typedef struct <span class="keyword">node</span><span class="title">&#123;  </span></span><br><span class="line"><span class="title">    char</span> data ;  </span><br><span class="line">    <span class="keyword">node</span> <span class="title">* next</span> ;  </span><br><span class="line">&#125;<span class="keyword">Node</span><span class="title">;  </span></span><br><span class="line"><span class="title">bool</span> exitLoop(<span class="keyword">Node</span> <span class="title">*head</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="keyword">Node</span> <span class="title">*fast</span>, *slow ;  </span><br><span class="line">    slow = fast = head ;  </span><br><span class="line">  </span><br><span class="line">    while (slow != NULL &amp;&amp; fast -&gt; next != NULL)  </span><br><span class="line">    &#123;  </span><br><span class="line">        slow = slow -&gt; next ;  </span><br><span class="line">        fast = fast -&gt; next -&gt; next ;  </span><br><span class="line">        if (slow == fast)  </span><br><span class="line">            return <span class="literal">true</span> ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return <span class="literal">false</span> ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单链表反转"><a href="#单链表反转" class="headerlink" title="单链表反转"></a>单链表反转</h2><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">Node</span> <span class="title">reverse</span>(<span class="keyword">Node</span> <span class="title">node</span>) &#123;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">prev</span> = null;</span><br><span class="line">    <span class="keyword">Node</span> <span class="title">now</span> = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">    while</span> (now != null) &#123;</span><br><span class="line">      <span class="keyword">Node</span> <span class="title">next</span> = now.next;</span><br><span class="line">      now.next = prev;</span><br><span class="line">      prev = now;</span><br><span class="line">      now = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return prev;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int a[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;],n&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void quickSort(int left,int right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  int i,&lt;span class=&quot;keyword&quot;&gt;j,t,temp;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt; if(left &amp;gt;right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  temp=a[left]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  i=left&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;j=right;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt; while(i!=&lt;span class=&quot;keyword&quot;&gt;j)&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;   while(a[&lt;span class=&quot;keyword&quot;&gt;j]&amp;gt;=temp&amp;amp;&amp;amp;i&amp;lt;j)&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;       &lt;span class=&quot;keyword&quot;&gt;j--;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    while(a[i]&amp;gt;=temp&amp;amp;&amp;amp;i&amp;lt;&lt;span class=&quot;keyword&quot;&gt;j)&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;       i++&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if(i&amp;lt;&lt;span class=&quot;keyword&quot;&gt;j)&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;       t=a[i]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[i]=a[&lt;span class=&quot;keyword&quot;&gt;j];&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;       a[&lt;span class=&quot;keyword&quot;&gt;j]=t;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt; &lt;/span&gt;   &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a[left]=a[i]&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a[i]=temp&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  quicpSort(left,i-1)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  quickSort(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,right)&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="面试" scheme="https://zhangzhang18.github.io/myBlog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/10/01/synchronized/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/10/01/synchronized/</id>
    <published>2017-10-01T02:47:54.000Z</published>
    <updated>2019-01-16T09:22:40.673Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2017/10/01/synchronized/syn.jpg" alt="synchronized"><br>synchronized是一种同步锁<br>同一时刻只能有一个线程能获取到锁</p><ol><li>修饰代码块：同步代码块，作用域是{}里面的代码，作用的对象是调用这个代码块的对象。</li><li>修饰方法：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。</li><li>修饰静态的方法：作用范围是整个方法，作用对象是这个类的所有对象。</li><li>修饰类：作用范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。<a id="more"></a></li></ol><hr><p>1.<strong>synchronized 代码块</strong><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(obj) &#123;</span><br><span class="line">   <span class="comment">//一次只能有一个线程进入</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>synchronized锁住的是括号里的对象，不是代码。<br>当synchronized锁住一个对象时，别的线程也想拿到这个对象的锁，必须等待这个线程执行完释放锁，才能再次给这个对象加锁。</p><blockquote><p>example</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String lock=<span class="keyword">new</span> String();</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//1 synchronized (lock) 2//synchronized (SyncThread.class)3</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":a begin"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":a   end"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1,2,3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] arg)&#123;</span><br><span class="line"></span><br><span class="line">        SyncThread a = <span class="keyword">new</span> <span class="type">SyncThread</span>();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> <span class="type">Thread</span>(a);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> <span class="type">Thread</span>(a);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] arg)&#123;</span><br><span class="line"></span><br><span class="line">        SyncThread a = <span class="keyword">new</span> <span class="type">SyncThread</span>();</span><br><span class="line">        SyncThread b = <span class="keyword">new</span> <span class="type">SyncThread</span>();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> <span class="type">Thread</span>(a);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> <span class="type">Thread</span>(b);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1,3输出</p><ul><li>t1—:a begin</li><li>t1—:a   end</li><li>t2—:a begin</li><li>t2—:a   end</li></ul><p>2输出</p><ul><li>t2—:a begin</li><li>t1—:a begin</li><li>t1—:a   end</li><li>t2—:a   end</li></ul><p>1是对类的当前实例加锁<br>2是对锁特定的实例加锁<br>3是对该类的所有对象都加了锁，该类所有的对象同一把锁。</p><p>1.<strong>synchronized 方法</strong><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">syncAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="function"><span class="keyword">void</span> <span class="title">syncAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>example</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SyncThread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> synchronized <span class="keyword">void</span> <span class="title">isSyncA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"funA-"</span>+Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException ie)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  synchronized <span class="keyword">void</span> <span class="title">isSyncB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"funB-"</span>+Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ie)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> synchronized <span class="keyword">void</span> <span class="title">cSync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"cSync"</span>+Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ie)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line"><span class="comment">//4</span></span><br><span class="line">       SyncThread a = <span class="keyword">new</span> SyncThread();</span><br><span class="line">       Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               a.isSyncA();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">       Thread t2 =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               a.isSyncB();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出</p><ul><li>funA-t1 : 4</li><li>funA-t1 : 3</li><li>funA-t1 : 2</li><li>funA-t1 : 1</li><li>funA-t1 : 0</li><li>funB-t2 : 4</li><li>funB-t2 : 3</li><li>funB-t2 : 2</li><li>funB-t2 : 1</li><li>funB-t2 : 0</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span></span>&#123;</span><br><span class="line"> <span class="comment">//5</span></span><br><span class="line">       SyncThread a = <span class="keyword">new</span> SyncThread();</span><br><span class="line">       Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               SyncThread.cSync();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">       Thread t2 =<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               SyncThread.cSync();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>cSynct1 : 4</li><li>cSynct1 : 3</li><li>cSynct1 : 2</li><li>cSynct1 : 1</li><li>cSynct1 : 0</li><li>cSynct2 : 4</li><li>cSynct2 : 3</li><li>cSynct2 : 2</li><li>cSynct2 : 1</li><li>cSynct2 : 0</li></ul><p>4是对象锁<br>3,5得到的锁是类的锁</p><p>4是防止多线程同时访问这个对象的synchronized方法，（如果这个对象有多个synchronized方法，只要有一个线程访问了一个synchronized方法，其他的线程不能访问这个对象的任一synchronized方法），不同对象的synchronized方法互不影响。</p><p>5是防止多线程中不同实例对象同时访问方法，它对类的所有实例起作用。</p><hr><p>synchronized的实现原理 </p><p>1,synchronized代码块 monitorenter //进入同步方法 monitorexit //退出同步方法 2,synchronized方法 ACC_SYNCHRONIZED指明该方法为同步方法</p><p><a href="https://www.cnblogs.com/lixuwu/p/5676143.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2017/10/01/synchronized/syn.jpg&quot; alt=&quot;synchronized&quot;&gt;&lt;br&gt;synchronized是一种同步锁&lt;br&gt;同一时刻只能有一个线程能获取到锁&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修饰代码块：同步代码块，作用域是{}里面的代码，作用的对象是调用这个代码块的对象。&lt;/li&gt;
&lt;li&gt;修饰方法：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。&lt;/li&gt;
&lt;li&gt;修饰静态的方法：作用范围是整个方法，作用对象是这个类的所有对象。&lt;/li&gt;
&lt;li&gt;修饰类：作用范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Volatile关键字</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/08/01/volatile/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/08/01/volatile/</id>
    <published>2017-08-01T02:56:41.000Z</published>
    <updated>2019-01-16T09:22:40.684Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2017/08/01/volatile/vol.jpg" alt="volatile"></p><p><strong>Volatile 能够保证可见性。</strong></p><blockquote><p> volatile的两大特性：禁止重排序、内存可见性。</p></blockquote><pre><code>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。2）禁止进行指令重排序。</code></pre><a id="more"></a><p>并发编程中三大概念：<strong>原子性，有序性，可见性。</strong></p><hr><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>一个操作或者多个操作，要么全部执行并且执行过程中不会被任何一个因素打扰，要么就不会执行。<br>Java中，对于基本数据类型的变量读取和赋值操作是原子的。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="number">10</span>;   <span class="comment">//1</span></span><br><span class="line">y=x;    <span class="comment">//2</span></span><br><span class="line">x++;    <span class="comment">//3</span></span><br><span class="line">x=x+<span class="number">1</span>;  <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>只有1是原子的操作。</p><p>2是两个操作，先读取x的值，在把x的值写入工作内存，这两个操作都是原子操作，放在一起就不是原子操作了。</p><p>3和4都是先读取x的值，在进行加一的操作，写入新的值。</p><p>只有简单的读取、赋值（变量之间赋值不是）才是原子操作。</p><p>可以通过synchronized和Lock解决原子性问题。</p><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>线程之间的可见性，一个线程修改这个变量的值，其他的线程能够立即看到修改的值。</p><p>Java中，volatile关键字来保证可见性。<br>被volatile修饰的变量，变量修改的值会立即更新到主存，当其他线程需要读取的时候。就会读取主存的值。</p><p>普通变量被修改的时候，什么时候写入主存是不确定的。当其他线程读取的时候可能还是原来的值，因此无法保证可见性。</p><p>synchronized和Lock也能保证可见性，能够保证同一时刻只有一个线程获取锁，并且在释放锁之前会将变量修改刷新到主存中。</p><h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>程序执行的顺序按照代码先后执行。</p><p>指令重排序不会影响单个线程的执行，会影响到线程并发执行的正确性。</p><p>Java中允许编译器和处理器对指令进行重排序，volatile、synchronized和Lock都可以保证有序性，</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1.状态标记量</p><h2 id="2-double-check"><a href="#2-double-check" class="headerlink" title="2.double check"></a>2.double check</h2><p>volatile实现原理</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2017/08/01/volatile/vol.jpg&quot; alt=&quot;volatile&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Volatile 能够保证可见性。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; volatile的两大特性：禁止重排序、内存可见性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2）禁止进行指令重排序。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集算法</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/07/20/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/07/20/垃圾收集算法/</id>
    <published>2017-07-20T15:46:25.000Z</published>
    <updated>2019-01-16T07:30:18.226Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1.标记-清除算法"></a>1.标记-清除算法</h2><p>最基础的收集算法。<br>分为两个阶段：标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。<br>不足：效率，空间，标记清除后会产生大量不连续的内存碎片。<br><a id="more"></a></p><h2 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h2><p>解决效率问题。<br>将可用的内存按容量分为大小相等的两块，每次只使用一块。当一块用完了，将还存活的对象复制到另一块，然后再把已使用过的内存空间一次清理掉。</p><h2 id="3-标记整理算法"><a href="#3-标记整理算法" class="headerlink" title="3.标记整理算法"></a>3.标记整理算法</h2><p>复制算法有较多复制操作，效率问题。<br>根据老年代的特点，标记过程与标记-清除算法一样，后续操作让所有存活对象都像一端移动，然后直接清理掉边界以外的内存。</p><h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h2><p>在新生代中有大批对象死去，少量存活：复制算法。复制成本少。<br>老年代中对象存活率高，没有额外的空间对他进行担保：就必须使用 标记-清理 或 标记-整理 算法回收。</p><hr><p>一共有两种算法，一种是引用计数算法，每被引用一次计数器就+1，当引用为0就回收，不过这种算法有一个弊端就是，当对象之间互相引用的时候就永远不会回收，<br>所以用的最多的还是GC ROOTS可达性分析，看对象是否被GC ROOTS引用，那么哪些可以作为GC ROOTS呢？<br>有以下四种：1.栈里面的局部变量表，方法区的2.类静态属性引用的对象3.方法区中常量引用的对象，4.JNI本地变量栈中引用的对象<br><a href="http://www.importnew.com/13493.html" target="_blank" rel="noopener">http://www.importnew.com/13493.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-标记-清除算法&quot;&gt;&lt;a href=&quot;#1-标记-清除算法&quot; class=&quot;headerlink&quot; title=&quot;1.标记-清除算法&quot;&gt;&lt;/a&gt;1.标记-清除算法&lt;/h2&gt;&lt;p&gt;最基础的收集算法。&lt;br&gt;分为两个阶段：标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。&lt;br&gt;不足：效率，空间，标记清除后会产生大量不连续的内存碎片。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://zhangzhang18.github.io/myBlog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存分配</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/07/13/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/07/13/JVM内存分配/</id>
    <published>2017-07-13T12:46:25.000Z</published>
    <updated>2019-01-16T10:09:12.410Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2017/07/13/JVM内存分配/jvm.jpg" alt="jvm"></p><p>线程私有的：</p><blockquote><p> 程序计数器  虚拟机栈  本地方法栈</p></blockquote><p>线程共享的：</p><blockquote><p>  堆  方法区  直接内存<br><a id="more"></a></p></blockquote><h2 id="1-程序计数器（PCR）"><a href="#1-程序计数器（PCR）" class="headerlink" title="1.程序计数器（PCR）"></a>1.程序计数器（PCR）</h2><p>可以看做当前线程所执行的字节码的行号指示器。<br>为了线程切换后能够恢复到正确执行位置，每条线程都需要独立的程序计数器。</p><h2 id="2-栈（JVM-stack）"><a href="#2-栈（JVM-stack）" class="headerlink" title="2.栈（JVM stack）"></a>2.栈（JVM stack）</h2><p>线程私有，生命周期与线程相同。<br>描述的事Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接方法出口。<br>每个方法执行到完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><h2 id="3-本地方法栈（Native-Method-Stack）"><a href="#3-本地方法栈（Native-Method-Stack）" class="headerlink" title="3.本地方法栈（Native Method Stack）"></a>3.本地方法栈（Native Method Stack）</h2><p>与JVM栈相似，本地方法栈是用的是虚拟机的native方法</p><h2 id="4-堆（heap"><a href="#4-堆（heap" class="headerlink" title="4.堆（heap)"></a>4.堆（heap)</h2><p>是Java虚拟机管理内存中最大的一块。<br>是被所有线程共享的一块内存区域，次内存区域唯一目的是存放对象实例，几乎所有的对象及数组都要在这里分配内存。<br>是垃圾回收器管理的主要区域，因此很多时候也被称作“GC堆”。<br>现在收集器采用分代收集算法，所以Java堆还可以细分为：新生代，老年代；</p><h2 id="5-方法区（Method）"><a href="#5-方法区（Method）" class="headerlink" title="5.方法区（Method）"></a>5.方法区（Method）</h2><p>域Java堆一样。是各个线程共享的内存区域，<br>用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。</p><h2 id="6-运行时常量池（Runtime-Constant-Pool）"><a href="#6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="6.运行时常量池（Runtime Constant Pool）"></a>6.运行时常量池（Runtime Constant Pool）</h2><p>是方法区的一部分。<br>Class文件不仅有类的版本，字段，方法，接口描述信息外，还有一项信息是常量池，<br>用于存放编译期生成的各种字面量和符号引用。</p><h2 id="7-直接内存（Direct-Memory）"><a href="#7-直接内存（Direct-Memory）" class="headerlink" title="7.直接内存（Direct Memory）"></a>7.直接内存（Direct Memory）</h2><p>不是虚拟机运行数据区的一部分。<br>NIO（New Input/Output）类，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存。通过一个Java堆DirectByteBuffer对象作为这块内存的引用进行操作。<br>显著提高性能，因为避免了Java堆和Native堆来回复制数据。</p><hr><p>栈区：每次方法的执行都会有一次栈帧的生成，并且其中有局部变量表。<br>堆区：每次new出来的对象都保存在这儿。<br>本地方法栈：通过C/C++调用系统接口的一些方法。<br>方法区：类的信息 静态变量都在这儿，还有程序计数器</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2017/07/13/JVM内存分配/jvm.jpg&quot; alt=&quot;jvm&quot;&gt;&lt;/p&gt;
&lt;p&gt;线程私有的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 程序计数器  虚拟机栈  本地方法栈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线程共享的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  堆  方法区  直接内存&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://zhangzhang18.github.io/myBlog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>HashMap归纳总结</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/05/12/HashMap%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/05/12/HashMap归纳总结/</id>
    <published>2017-05-12T13:49:01.000Z</published>
    <updated>2019-01-16T09:53:40.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结ArrayList和LinkedList"><a href="#总结ArrayList和LinkedList" class="headerlink" title="总结ArrayList和LinkedList"></a>总结ArrayList和LinkedList</h2><p>HashMap<br><img src="/myBlog/2017/05/12/HashMap归纳总结/hashMap.jpg" alt="hashMap"></p><blockquote><p>（1）ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢</p><p>（2）LinkedList以链表形式实现，顺序插入、查找较慢，插入、删除方便<br><a id="more"></a></p></blockquote><hr><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ol><li><strong>了解HashMap吗？</strong></li></ol><blockquote><ul><li>HashMap是一种键值对（Key-Value）形式的存储结构。</li><li>key和value都允许为null。</li><li>当key重复的时候会覆盖，value允许重复。</li><li>是无序的，不会按照put的顺序排序。</li><li>是非线程安全的。</li><li>HashMap的Entry是一个单向链表</li></ul></blockquote><p><img src="/myBlog/2017/05/12/HashMap归纳总结/base.jpg" alt="base"></p><ol start="2"><li><strong>知道HashMap的工作原理吗？</strong></li></ol><blockquote><ul><li>内部是一个数组，数组元素Node是实现了Map.Entry(hash,key,value,next)，next非null的时候指向定位相同的另一个Entry。</li><li>使用put()传递键和值，先对键调用hashCode()方法，通过hashCode确定bucket位置存储Entry对象。当发生碰撞的时候，使用<strong>散列法</strong>处理碰撞节点，将旧的Entry的引用赋值给新的Entry的next上，就是一个链表，冲突的节点从<strong>链表头部插入</strong>，这样插入新的Entry就不需要遍历链表。</li><li>通过get()获取对象。</li></ul></blockquote><ol start="3"><li><strong>当两个对象的hashCode相同的时候，怎么获取值对象？</strong></li></ol><blockquote><ul><li>get方法先比较hashCode值，如果hashCode相等，就是用equal()方法比较。</li><li>== 号与equals()方法的区别:== 基本数据类型比较的是值，对象比较的是对象的地址值。<br>equals()继承自Object类。在所有没有重写equals()方法的类中，equals()内部是==，也是比较的地址值。然而，Java提供的所有类中，绝大多数类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值</li></ul></blockquote><ol start="4"><li><strong>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong></li></ol><blockquote><p>默认的负载因子大小为<strong>0.75</strong>，初始容量是16，,也就是说，当一个map填满了<strong>75%</strong>的bucket时候，就会发生resize。简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。</p></blockquote><ol start="5"><li><strong>重新调整HashMap大小存在什么问题？</strong></li></ol><blockquote><p>在多线程的情况下，整个HashMap中的元素都需要重新算一遍。rehash，成本非常大。<br>链表中节点的转移可能会出现死循环的情况。</p></blockquote><ol start="6"><li><strong>HashMap与HashTable的区别：</strong></li></ol><blockquote><ul><li>HashTable不接受为null的键值(key)和值(value)</li><li>Hashtable是线程安全的也是synchronized在单线程环境下它比HashMap要慢。</li></ul></blockquote><ol start="7"><li><strong>HashMap同步？</strong></li></ol><blockquote><p>Map m = Collections.synchronizeMap(hashMap);</p></blockquote><p><img src="/myBlog/2017/05/12/HashMap归纳总结/ConcurrentHashMap.png" alt="ConcurrentHashMap"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/myBlog/2017/05/12/HashMap归纳总结/HashMap.jpg" alt="HashMap"></h2><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><blockquote><p>需要线程安全，那么就使用ConcurrentHashMap。</p></blockquote><p>HashTable是使用synchronized来锁住整张Hash表来实现线程安全。</p><p>一个 ConcurrentHashMap 由一个个 Segment 组成，Segment代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。<br>Segment 内部是由 数组+链表 组成的。</p><p><img src="/myBlog/2017/05/12/HashMap归纳总结/ConcurrentHashMap.jpg" alt="ConcurrentHashMap"></p><p><a href="https://mp.weixin.qq.com/s/SyKckwLfV2ypJOzTFA7R_g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SyKckwLfV2ypJOzTFA7R_g</a></p><p><a href="https://mp.weixin.qq.com/s/__ZnkPAF6ucUqN8CVSVQeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/__ZnkPAF6ucUqN8CVSVQeA</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;总结ArrayList和LinkedList&quot;&gt;&lt;a href=&quot;#总结ArrayList和LinkedList&quot; class=&quot;headerlink&quot; title=&quot;总结ArrayList和LinkedList&quot;&gt;&lt;/a&gt;总结ArrayList和LinkedList&lt;/h2&gt;&lt;p&gt;HashMap&lt;br&gt;&lt;img src=&quot;/myBlog/2017/05/12/HashMap归纳总结/hashMap.jpg&quot; alt=&quot;hashMap&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（1）ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢&lt;/p&gt;
&lt;p&gt;（2）LinkedList以链表形式实现，顺序插入、查找较慢，插入、删除方便&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://zhangzhang18.github.io/myBlog/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>事物</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/03/16/%E4%BA%8B%E7%89%A9/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/03/16/事物/</id>
    <published>2017-03-16T04:50:21.000Z</published>
    <updated>2019-01-18T10:51:31.127Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常用Linux命令</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/01/16/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/01/16/常用Linux命令/</id>
    <published>2017-01-16T09:29:15.000Z</published>
    <updated>2019-01-16T10:01:26.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>ls　&ensp;&ensp;&ensp;&ensp;　        显示文件或目录</p><pre><code>-l           列出文件详细信息l(list)-a          列出当前目录下所有文件及目录，包括隐藏的a(all)</code></pre><p>mkdir  &ensp;&ensp;&ensp;&ensp;　       创建目录</p><pre><code>-p           创建目录，若无父目录，则创建p(parent)</code></pre><p>cd   &ensp;&ensp;&ensp;&ensp;　            切换目录</p><p>touch   &ensp;&ensp;&ensp;&ensp;　       创建空文件</p><p>echo   &ensp;&ensp;&ensp;&ensp;　         创建带有内容的文件。</p><p>cat    &ensp;&ensp;&ensp;&ensp;　          查看文件内容</p><p>cp     &ensp;&ensp;&ensp;&ensp;　           拷贝   cp [选项]… [-T] 源 目的</p><p>mv    &ensp;&ensp;&ensp;&ensp;　           移动或重命名</p><p>rm     &ensp;&ensp;&ensp;&ensp;　          删除文件</p><pre><code>-r            递归删除，可删除子目录及文件-f            强制删除</code></pre><p>find    &ensp;&ensp;&ensp;&ensp;　          在文件系统中搜索某文件</p><p>wc      &ensp;&ensp;&ensp;&ensp;　          统计文本中行数、字数、字符数</p><p>grep    &ensp;&ensp;&ensp;&ensp;　         在文本文件中查找某个字符串</p><p>rmdir    &ensp;&ensp;&ensp;&ensp;　       删除空目录</p><p>tree     &ensp;&ensp;&ensp;&ensp;　        树形结构显示目录，需要安装tree包</p><p>pwd      &ensp;&ensp;&ensp;&ensp;　        显示当前目录</p><p>ln      &ensp;&ensp;&ensp;&ensp;　            创建链接文件</p><p>more、less &ensp;&ensp;&ensp;&ensp;　 分页显示文本文件内容</p><p>head、tail   &ensp;&ensp;&ensp;&ensp;　 显示文件头、尾内容</p><p>ctrl+alt+F1 &ensp;&ensp;&ensp;&ensp;　 命令行全屏模式</p><p>##　打包压缩相关命令</p><p>gzip：</p><p>bzip2：</p><p>tar:                打包压缩</p><pre><code>-c              归档文件-x              压缩文件-z              gzip压缩文件-j              bzip2压缩文件-v              显示压缩或解压缩过程 v(view)-f              使用档名</code></pre><p>例：<br>tar -cvf /home/abc.tar /home/abc              只打包，不压缩</p><p>tar -zcvf /home/abc.tar.gz /home/abc        打包，并用gzip压缩</p><p>tar -jcvf /home/abc.tar.bz2 /home/abc      打包，并用bzip2压缩</p><p>当然，如果想解压缩，就直接替换上面的命令  tar -cvf  / tar -zcvf  / tar -jcvf 中的“c” 换成“x” 就可以了。</p><p>##　系统管理命令</p><p>stat    &ensp;&ensp;&ensp;&ensp;　          显示指定文件的详细信息，比ls更详细</p><p>who     &ensp;&ensp;&ensp;&ensp;　          显示在线登陆用户</p><p>whoami   &ensp;&ensp;&ensp;&ensp;　       显示当前操作用户</p><p>hostname  &ensp;&ensp;&ensp;&ensp;　    显示主机名</p><p>uname     &ensp;&ensp;&ensp;&ensp;　      显示系统信息</p><p>top     &ensp;&ensp;&ensp;&ensp;　           动态显示当前耗费资源最多进程信息</p><p>ps     &ensp;&ensp;&ensp;&ensp;　             显示瞬间进程状态 ps -aux</p><p>du    &ensp;&ensp;&ensp;&ensp;　              查看目录大小 du -h /home带有单位显示目录信息</p><p>df    &ensp;&ensp;&ensp;&ensp;　              查看磁盘大小 df -h 带有单位显示磁盘信息</p><p>ifconfig   &ensp;&ensp;&ensp;&ensp;　       查看网络情况</p><p>ping      &ensp;&ensp;&ensp;&ensp;　          测试网络连通</p><p>netstat    &ensp;&ensp;&ensp;&ensp;　      显示网络状态信息</p><p>man        &ensp;&ensp;&ensp;&ensp;　        命令不会用了，找男人  如：man ls</p><p>clear      &ensp;&ensp;&ensp;&ensp;　        清屏</p><p>alias     &ensp;&ensp;&ensp;&ensp;　          对命令重命名 如：alias showmeit=”ps -aux” ，另外解除使用unaliax showmeit</p><p>kill      &ensp;&ensp;&ensp;&ensp;　           杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常用指令&quot;&gt;&lt;a href=&quot;#常用指令&quot; class=&quot;headerlink&quot; title=&quot;常用指令&quot;&gt;&lt;/a&gt;常用指令&lt;/h2&gt;&lt;p&gt;ls　&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;　        显示文件或目录&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-l 
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Linux" scheme="https://zhangzhang18.github.io/myBlog/tags/Linux/"/>
    
  </entry>
  
</feed>
