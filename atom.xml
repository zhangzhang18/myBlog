<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>萌</title>
  
  <subtitle>冲啊\(0^v^0)/</subtitle>
  <link href="/myBlog/atom.xml" rel="self"/>
  
  <link href="https://zhangzhang18.github.io/myBlog/"/>
  <updated>2018-08-08T06:10:42.863Z</updated>
  <id>https://zhangzhang18.github.io/myBlog/</id>
  
  <author>
    <name>萌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试常用手写代码</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/10/12/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/10/12/面试常用手写代码/</id>
    <published>2017-10-12T13:07:31.000Z</published>
    <updated>2018-08-08T06:10:42.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>volatile 的一个语义禁止指令重排优化。<br>synchronized关键字<br>当两个线程同事进入第一的if判断语句后，线程1获取锁，线程2阻塞在1处，线程1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  private volatile static Singleton instance=null;</span><br><span class="line">  private Singleton()&#123;&#125;</span><br><span class="line">  public static Singleton getInstance()&#123;</span><br><span class="line">      if (instance==null)&#123;</span><br><span class="line">          synchronized(Singleton.class)&#123;//1</span><br><span class="line">              if(instance==null)&#123;//2</span><br><span class="line">                  instance=new Singleton();//3</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public enum Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void whateverMethod() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h2&gt;&lt;p&gt;volatile 的一个语义禁止指令重排优化。&lt;br&gt;synchronized关键字&lt;br&gt;当两个线程同事进入第一的if判断
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="面试" scheme="https://zhangzhang18.github.io/myBlog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/10/01/synchronized/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/10/01/synchronized/</id>
    <published>2017-10-01T02:47:54.000Z</published>
    <updated>2018-08-08T06:02:54.214Z</updated>
    
    <content type="html"><![CDATA[<p>synchronized是一种同步锁<br>同一时刻只能有一个线程能获取到锁</p><ol><li>修饰代码块：同步代码块，作用域是{}里面的代码，作用的对象是调用这个代码块的对象。</li><li>修饰方法：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。</li><li>修饰静态的方法：作用范围是整个方法，作用对象是这个类的所有对象。</li><li>修饰类：作用范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。</li></ol><hr><p>1.synchronized 代码块<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">   synchronized(obj) &#123;</span><br><span class="line">   //一次只能有一个线程进入</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>synchronized锁住的是括号里的对象，不是代码。<br>当synchronized锁住一个对象时，别的线程也想拿到这个对象的锁，必须等待这个线程执行完释放锁，才能再次给这个对象加锁。</p><blockquote><p>example</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class SyncThread implements Runnable &#123;</span><br><span class="line"></span><br><span class="line">    private static int count;</span><br><span class="line"></span><br><span class="line">    public SyncThread() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String lock=new String();</span><br><span class="line">            synchronized (this) &#123;//1 synchronized (lock) 2//synchronized (SyncThread.class)3</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;:a begin&quot;);</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;:a   end&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1,2,3</span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line"></span><br><span class="line">        SyncThread a = new SyncThread();</span><br><span class="line">        Thread t1 = new Thread(a);</span><br><span class="line">        Thread t2 = new Thread(a);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//3</span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line"></span><br><span class="line">        SyncThread a = new SyncThread();</span><br><span class="line">        SyncThread b = new SyncThread();</span><br><span class="line">        Thread t1 = new Thread(a);</span><br><span class="line">        Thread t2 = new Thread(b);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1,3输出</p><ul><li>t1—:a begin</li><li>t1—:a   end</li><li>t2—:a begin</li><li>t2—:a   end</li></ul><p>2输出</p><ul><li>t2—:a begin</li><li>t1—:a begin</li><li>t1—:a   end</li><li>t2—:a   end</li></ul><p>1是对类的当前实例加锁<br>2是对锁特定的实例加锁<br>3是对该类的所有对象都加了锁，该类所有的对象同一把锁。</p><p>1.synchronized 方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void syncAdd() &#123;</span><br><span class="line">   //4</span><br><span class="line">&#125;</span><br><span class="line">public static synchronized void syncAdd() &#123;</span><br><span class="line">   //5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>example</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class SyncThread &#123;</span><br><span class="line"></span><br><span class="line">    public SyncThread() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public synchronized void isSyncA() &#123;</span><br><span class="line">        int i = 5;</span><br><span class="line">        while( i-- &gt; 0)&#123;</span><br><span class="line">            System.out.println(&quot;funA-&quot;+Thread.currentThread().getName() + &quot; : &quot; + i);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125;</span><br><span class="line">            catch (InterruptedException ie)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public  synchronized void isSyncB()&#123;</span><br><span class="line">        int i = 5;</span><br><span class="line">        while( i-- &gt; 0)&#123;</span><br><span class="line">            System.out.println(&quot;funB-&quot;+Thread.currentThread().getName() + &quot; : &quot; + i);</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125;catch (InterruptedException ie)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static synchronized void cSync()&#123;</span><br><span class="line">        int i = 5;</span><br><span class="line">        while( i-- &gt; 0) &#123;</span><br><span class="line">            System.out.println(&quot;cSync&quot;+Thread.currentThread().getName() + &quot; : &quot; + i);</span><br><span class="line">            try&#123;</span><br><span class="line">                Thread.sleep(500);</span><br><span class="line">            &#125;catch (InterruptedException ie)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg)&#123;</span><br><span class="line">//4</span><br><span class="line">       SyncThread a = new SyncThread();</span><br><span class="line">       Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               a.isSyncA();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">       Thread t2 =new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               a.isSyncB();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出</p><ul><li>funA-t1 : 4</li><li>funA-t1 : 3</li><li>funA-t1 : 2</li><li>funA-t1 : 1</li><li>funA-t1 : 0</li><li>funB-t2 : 4</li><li>funB-t2 : 3</li><li>funB-t2 : 2</li><li>funB-t2 : 1</li><li>funB-t2 : 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg)&#123;</span><br><span class="line"> //5</span><br><span class="line">       SyncThread a = new SyncThread();</span><br><span class="line">       Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               SyncThread.cSync();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">       Thread t2 =new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               SyncThread.cSync();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>cSynct1 : 4</li><li>cSynct1 : 3</li><li>cSynct1 : 2</li><li>cSynct1 : 1</li><li>cSynct1 : 0</li><li>cSynct2 : 4</li><li>cSynct2 : 3</li><li>cSynct2 : 2</li><li>cSynct2 : 1</li><li>cSynct2 : 0</li></ul><p>4是对象锁<br>3,5得到的锁是类的锁</p><p>4是防止多线程同时访问这个对象的synchronized方法，（如果这个对象有多个synchronized方法，只要有一个线程访问了一个synchronized方法，其他的线程不能访问这个对象的任一synchronized方法），不同对象的synchronized方法互不影响。</p><p>5是防止多线程中不同实例对象同时访问方法，它对类的所有实例起作用。</p><hr><p>synchronized的实现原理 </p><p>1,synchronized代码块 monitorenter //进入同步方法 monitorexit //退出同步方法 2,synchronized方法 ACC_SYNCHRONIZED指明该方法为同步方法</p><p>参考</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;synchronized是一种同步锁&lt;br&gt;同一时刻只能有一个线程能获取到锁&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修饰代码块：同步代码块，作用域是{}里面的代码，作用的对象是调用这个代码块的对象。&lt;/li&gt;
&lt;li&gt;修饰方法：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Volatile关键字</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/08/01/Volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/08/01/Volatile关键字/</id>
    <published>2017-08-01T02:56:41.000Z</published>
    <updated>2018-08-08T06:03:15.773Z</updated>
    
    <content type="html"><![CDATA[<p>Volatile 能够保证可见性。</p><blockquote><p> volatile的两大特性：禁止重排序、内存可见性。</p></blockquote><p>并发编程中三大概念：原子性，有序性，可见性。</p><hr><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>一个操作或者多个操作，要么全部执行并且执行过程中不会被任何一个因素打扰，要么就不会执行。<br>Java中，对于基本数据类型的变量读取和赋值操作是原子的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=10;   //1</span><br><span class="line">y=x;    //2</span><br><span class="line">x++;    //3</span><br><span class="line">x=x+1;  //4</span><br></pre></td></tr></table></figure><p>只有1是原子的操作。</p><p>2是两个操作，先读取x的值，在把x的值写入工作内存，这两个操作都是原子操作，放在一起就不是原子操作了。</p><p>3和4都是先读取x的值，在进行加一的操作，写入新的值。</p><p>只有简单的读取、赋值（变量之间赋值不是）才是原子操作。</p><p>可以通过synchronized和Lock解决原子性问题。</p><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>线程之间的可见性，一个线程修改这个变量的值，其他的线程能够立即看到修改的值。</p><p>Java中，volatile关键字来保证可见性。<br>被volatile修饰的变量，变量修改的值会立即更新到主存，当其他线程需要读取的时候。就会读取主存的值。</p><p>普通变量被修改的时候，什么时候写入主存是不确定的。当其他线程读取的时候可能还是原来的值，因此无法保证可见性。</p><p>synchronized和Lock也能保证可见性，能够保证同一时刻只有一个线程获取锁，并且在释放锁之前会将变量修改刷新到主存中。</p><h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>程序执行的顺序按照代码先后执行。</p><p>指令重排序不会影响单个线程的执行，会影响到线程并发执行的正确性。</p><p>Java中允许编译器和处理器对指令进行重排序，volatile、synchronized和Lock都可以保证有序性，</p><hr><p>volatile实现原理</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Volatile 能够保证可见性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; volatile的两大特性：禁止重排序、内存可见性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并发编程中三大概念：原子性，有序性，可见性。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-原子性&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集算法</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/07/20/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/07/20/垃圾收集算法/</id>
    <published>2017-07-20T15:46:25.000Z</published>
    <updated>2018-07-17T09:00:13.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1.标记-清除算法"></a>1.标记-清除算法</h2><p>最基础的收集算法。<br>分为两个阶段：标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。<br>不足：效率，空间，标记清除后会产生大量不连续的内存碎片。</p><h2 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h2><p>解决效率问题。<br>将可用的内存按容量分为大小相等的两块，每次只使用一块。当一块用完了，将还存活的对象复制到另一块，然后再把已使用过的内存空间一次清理掉。</p><h2 id="3-标记整理算法"><a href="#3-标记整理算法" class="headerlink" title="3.标记整理算法"></a>3.标记整理算法</h2><p>复制算法有较多复制操作，效率问题。<br>根据老年代的特点，标记过程与标记-清除算法一样，后续操作让所有存活对象都像一端移动，然后直接清理掉边界以外的内存。</p><h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h2><p>在新生代中有大批对象死去，少量存活：复制算法。复制成本少。<br>老年代中对象存活率高，没有额外的空间对他进行担保：就必须使用 标记-清理 或 标记-整理 算法回收。</p><hr><p>一共有两种算法，一种是引用计数算法，每被引用一次计数器就+1，当引用为0就回收，不过这种算法有一个弊端就是，当对象之间互相引用的时候就永远不会回收，<br>所以用的最多的还是GC ROOTS可达性分析，看对象是否被GC ROOTS引用，那么哪些可以作为GC ROOTS呢？<br>有以下四种：1.栈里面的局部变量表，方法区的2.类静态属性引用的对象3.方法区中常量引用的对象，4.JNI本地变量栈中引用的对象<br><a href="http://www.importnew.com/13493.html" target="_blank" rel="noopener">http://www.importnew.com/13493.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-标记-清除算法&quot;&gt;&lt;a href=&quot;#1-标记-清除算法&quot; class=&quot;headerlink&quot; title=&quot;1.标记-清除算法&quot;&gt;&lt;/a&gt;1.标记-清除算法&lt;/h2&gt;&lt;p&gt;最基础的收集算法。&lt;br&gt;分为两个阶段：标记出所有需要回收的对象，标记完成后统一回收
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://zhangzhang18.github.io/myBlog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存分配</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/07/13/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/07/13/JVM内存分配/</id>
    <published>2017-07-13T12:46:25.000Z</published>
    <updated>2018-07-17T09:25:07.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-程序计数器（PCR）"><a href="#1-程序计数器（PCR）" class="headerlink" title="1.程序计数器（PCR）"></a>1.程序计数器（PCR）</h2><p>可以看做当前线程所执行的字节码的行号指示器。<br>为了线程切换后能够恢复到正确执行位置，每条线程都需要独立的程序计数器。</p><h2 id="2-栈（JVM-stack）"><a href="#2-栈（JVM-stack）" class="headerlink" title="2.栈（JVM stack）"></a>2.栈（JVM stack）</h2><p>线程私有，生命周期与线程相同。<br>描述的事Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接方法出口。<br>每个方法执行到完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><h2 id="3-本地方法栈（Native-Method-Stack）"><a href="#3-本地方法栈（Native-Method-Stack）" class="headerlink" title="3.本地方法栈（Native Method Stack）"></a>3.本地方法栈（Native Method Stack）</h2><p>与JVM栈相似，本地方法栈是用的是虚拟机的native方法</p><h2 id="4-堆（heap"><a href="#4-堆（heap" class="headerlink" title="4.堆（heap)"></a>4.堆（heap)</h2><p>是Java虚拟机管理内存中最大的一块。<br>是被所有线程共享的一块内存区域，次内存区域唯一目的是存放对象实例，几乎所有的对象及数组都要在这里分配内存。<br>是垃圾回收器管理的主要区域，因此很多时候也被称作“GC堆”。<br>现在收集器采用分代收集算法，所以Java堆还可以细分为：新生代，老年代；</p><h2 id="5-方法区（Method）"><a href="#5-方法区（Method）" class="headerlink" title="5.方法区（Method）"></a>5.方法区（Method）</h2><p>域Java堆一样。是各个线程共享的内存区域，<br>用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。</p><h2 id="6-运行时常量池（Runtime-Constant-Pool）"><a href="#6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="6.运行时常量池（Runtime Constant Pool）"></a>6.运行时常量池（Runtime Constant Pool）</h2><p>是方法区的一部分。<br>Class文件不仅有类的版本，字段，方法，接口描述信息外，还有一项信息是常量池，<br>用于存放编译期生成的各种字面量和符号引用。</p><h2 id="7-直接内存（Direct-Memory）"><a href="#7-直接内存（Direct-Memory）" class="headerlink" title="7.直接内存（Direct Memory）"></a>7.直接内存（Direct Memory）</h2><p>不是虚拟机运行数据区的一部分。<br>NIO（New Input/Output）类，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存。通过一个Java堆DirectByteBuffer对象作为这块内存的引用进行操作。<br>显著提高性能，因为避免了Java堆和Native堆来回复制数据。</p><hr><p>栈区：每次方法的执行都会有一次栈帧的生成，并且其中有局部变量表。<br>堆区：每次new出来的对象都保存在这儿。<br>本地方法栈：通过C/C++调用系统接口的一些方法。<br>方法区：类的信息 静态变量都在这儿，还有程序计数器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-程序计数器（PCR）&quot;&gt;&lt;a href=&quot;#1-程序计数器（PCR）&quot; class=&quot;headerlink&quot; title=&quot;1.程序计数器（PCR）&quot;&gt;&lt;/a&gt;1.程序计数器（PCR）&lt;/h2&gt;&lt;p&gt;可以看做当前线程所执行的字节码的行号指示器。&lt;br&gt;为了线程
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://zhangzhang18.github.io/myBlog/tags/JVM/"/>
    
  </entry>
  
</feed>
