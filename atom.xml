<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>萌</title>
  
  <subtitle>冲鸭\(0^v^0)/</subtitle>
  <link href="/myBlog/atom.xml" rel="self"/>
  
  <link href="https://zhangzhang18.github.io/myBlog/"/>
  <updated>2019-10-11T05:30:42.970Z</updated>
  <id>https://zhangzhang18.github.io/myBlog/</id>
  
  <author>
    <name>萌</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MQ归纳</title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/09/18/MQ%E5%BD%92%E7%BA%B3/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/09/18/MQ归纳/</id>
    <published>2019-09-18T02:00:47.000Z</published>
    <updated>2019-10-11T05:30:42.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h2><p><img src="/myBlog/2019/09/18/MQ归纳/mq.png" alt="Kafka"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;MQ&quot;&gt;&lt;a href=&quot;#MQ&quot; class=&quot;headerlink&quot; title=&quot;MQ&quot;&gt;&lt;/a&gt;MQ&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/myBlog/2019/09/18/MQ归纳/mq.png&quot; alt=&quot;Kafka&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Redis" scheme="https://zhangzhang18.github.io/myBlog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis归纳</title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/08/18/Redis%E5%BD%92%E7%BA%B3/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/08/18/Redis归纳/</id>
    <published>2019-08-18T08:31:47.000Z</published>
    <updated>2019-10-11T05:33:25.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>一个基于内存的高性能的key-value数据库。</p><blockquote><p>数据结构：String字符串，Hash字典，List列表，Set集合，SortedSet有序集合。</p></blockquote><p><img src="/myBlog/2019/08/18/Redis归纳/Redis.png" alt="Redis"></p><a id="more"></a><ol><li><strong>使用Redis有哪些好处？</strong></li></ol><blockquote><ul><li>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li><li>(2) 支持丰富数据类型，支持string，list，set，sorted set，hash</li><li>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ul></blockquote><p>2.<strong>为什么redis需要把所有数据放到内存中?</strong></p><blockquote><p>　Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。<br>　　　如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p></blockquote><p>3.<strong>Redis是单进程单线程的为什么也那么快？</strong></p><blockquote><p>　Redis快的主要原因是：</p><ul><li>完全基于内存</li><li>数据结构简单，对数据操作也简单</li><li>使用多路 I/O 复用模型</li></ul><p>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p></blockquote><p>4.<strong>Redis锁的使用。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static Redisson redisson = RedissonManager.getRedisson();</span><br><span class="line"></span><br><span class="line">    private static final String LOCK_FLAG = &quot;mylock_&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据name对进行上锁操作，redissonLock 阻塞的，采用的机制发布/订阅</span><br><span class="line">     * @param key</span><br><span class="line">     */</span><br><span class="line">    public static void lock(String key)&#123;</span><br><span class="line">        String lockKey = LOCK_FLAG + key;</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        //lock提供带timeout参数，timeout结束强制解锁，防止死锁 ：1分钟</span><br><span class="line">        lock.lock(1, TimeUnit.MINUTES);</span><br><span class="line">        logger.info(&quot;lock key:&#123;&#125;&quot;,lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 根据name对进行解锁操作</span><br><span class="line">     * @param key</span><br><span class="line">     */</span><br><span class="line">    public static void unlock(String key)&#123;</span><br><span class="line">        String lockKey = LOCK_FLAG + key;</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        //如果锁被当前线程持有，则释放</span><br><span class="line">        if(lock.isHeldByCurrentThread())&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            logger.info(&quot;unlock key:&#123;&#125;&quot;,lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h2&gt;&lt;p&gt;一个基于内存的高性能的key-value数据库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据结构：String字符串，Hash字典，List列表，Set集合，SortedSet有序集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/myBlog/2019/08/18/Redis归纳/Redis.png&quot; alt=&quot;Redis&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Redis" scheme="https://zhangzhang18.github.io/myBlog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>并发多线程</title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/04/20/%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/04/20/并发学习/</id>
    <published>2019-04-20T13:56:25.000Z</published>
    <updated>2019-10-11T10:51:10.806Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>   <h2 id="一：JAVA内存模型（JMM）"><a href="#一：JAVA内存模型（JMM）" class="headerlink" title="一：JAVA内存模型（JMM）"></a>一：JAVA内存模型（JMM）</h2><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><h4 id="实现机制-1"><a href="#实现机制-1" class="headerlink" title="实现机制"></a>实现机制</h4><h2 id="二：并发基础"><a href="#二：并发基础" class="headerlink" title="二：并发基础"></a>二：并发基础</h2><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h2 id="三：锁"><a href="#三：锁" class="headerlink" title="三：锁"></a>三：锁</h2><h3 id="ReenTrantLock可重入锁"><a href="#ReenTrantLock可重入锁" class="headerlink" title="ReenTrantLock可重入锁"></a>ReenTrantLock可重入锁</h3><h3 id="ReenTrantReadWriteLock读写锁"><a href="#ReenTrantReadWriteLock读写锁" class="headerlink" title="ReenTrantReadWriteLock读写锁"></a>ReenTrantReadWriteLock读写锁</h3><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><h2 id="四：并发工具类"><a href="#四：并发工具类" class="headerlink" title="四：并发工具类"></a>四：并发工具类</h2><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><h2 id="五：其他"><a href="#五：其他" class="headerlink" title="五：其他"></a>五：其他</h2><h2 id="六：并发集合"><a href="#六：并发集合" class="headerlink" title="六：并发集合"></a>六：并发集合</h2><h2 id="七：atomic原子"><a href="#七：atomic原子" class="headerlink" title="七：atomic原子"></a>七：atomic原子</h2><h2 id="八：阻塞队列"><a href="#八：阻塞队列" class="headerlink" title="八：阻塞队列"></a>八：阻塞队列</h2><h2 id="九：线程池"><a href="#九：线程池" class="headerlink" title="九：线程池"></a>九：线程池</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;   
&lt;h2 id=&quot;一：JAVA内存模型（JMM）&quot;&gt;&lt;a href=&quot;#一：JAVA内存模型（JMM）&quot; class=&quot;headerlink&quot; title=&quot;一：JAVA内存模型（JMM）&quot;&gt;&lt;/a&gt;一：JAVA内存模型（JMM）&lt;/h2&gt;
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Boot</title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/03/11/Spring-Boot/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/03/11/Spring-Boot/</id>
    <published>2019-03-11T01:24:22.000Z</published>
    <updated>2019-10-11T11:04:37.847Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot解决得问题</p><blockquote><p>配置、部署、监控变得简单。</p></blockquote><blockquote><p>Boot只需要很少得配置（@Configuration），项目快速搭建，主流框架无配置集成。</p></blockquote><h2 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h2><ol><li>独立运行Spring项目</li><li>内嵌servlet容器 - SpringApplication.run()</li><li>提供starter简化maven配置</li><li>自动装配Spring</li><li>准生产的应用监控</li><li>无代码生产和xml配置</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring Boot解决得问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置、部署、监控变得简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Boot只需要很少得配置（@Configuration），项目快速搭建，主流框架无配置集成。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Spring" scheme="https://zhangzhang18.github.io/myBlog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>AB测技术 </title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/02/13/AB%E6%B5%8B%E6%8A%80%E6%9C%AF/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/02/13/AB测技术/</id>
    <published>2019-02-13T02:17:26.000Z</published>
    <updated>2019-02-15T09:45:10.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简单来说，就是为同一个目标制定两个方案（比如两个页面）</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简单来说，就是为同一个目标制定两个方案（比如两个页面）&lt;/p&gt;
&lt;/blockquote&gt;

      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
  </entry>
  
  <entry>
    <title>Spring-Cloud</title>
    <link href="https://zhangzhang18.github.io/myBlog/2019/01/24/Spring-Cloud/"/>
    <id>https://zhangzhang18.github.io/myBlog/2019/01/24/Spring-Cloud/</id>
    <published>2019-01-24T08:21:58.000Z</published>
    <updated>2019-10-11T11:33:15.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud简介"><a href="#Spring-Cloud简介" class="headerlink" title="Spring Cloud简介"></a>Spring Cloud简介</h1><blockquote><p>Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p></blockquote><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><blockquote><p>简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。</p></blockquote><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ol><li>每个服务都比较简单，只关注一个业务功能</li><li>微服务架构方式是松耦合的，可以提供更高的灵活性</li><li>每个微服务可由不同团队独立开发，互不影响，加快推出市场速度<br>4.允许在频繁发布不同服务的同时，保持其他部分的可用性和稳定性<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2></li><li>运维开销的成本增加</li><li>系统复杂度变高</li><li>部署的速度变慢</li><li>分布式系统的冗余问题</li><li>分布式系统的复杂性</li></ol><h1 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h1><p><img src="/myBlog/2019/01/24/Spring-Cloud/register.png" alt="服务注册中心对比"></p><ul><li>Spring Cloud应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper</li><li>Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。</li></ul><ol start="2"><li><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。</p></li><li><p>Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。<br>##　CAP理论</p><blockquote><p>CAP理论是分布式架构中重要理论</p></blockquote></li><li>一致性(Consistency) (所有节点在同一时间具有相同的数据)</li><li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</li><li>分区容错(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Cloud简介&quot;&gt;&lt;a href=&quot;#Spring-Cloud简介&quot; class=&quot;headerlink&quot; title=&quot;Spring Cloud简介&quot;&gt;&lt;/a&gt;Spring Cloud简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Spring Cl
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Spring" scheme="https://zhangzhang18.github.io/myBlog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>ZooKeeper</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/12/26/ZooKeeper/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/12/26/ZooKeeper/</id>
    <published>2018-12-26T02:50:47.000Z</published>
    <updated>2019-10-11T10:55:03.599Z</updated>
    
    <content type="html"><![CDATA[<p>分布式协调服务-可以在分布式系统中共享配置，协调锁资源，提供命名服务</p><p>Zookeeper的数据模型：像数据结构中的树，也像文件系统中的目录<br>  <a id="more"></a></p><ul><li>Znode：包含数据，子节点引用，访问权限等。每个节点的数据最大不能超过1MB<br>Zookeeper包含的基本操作<ul><li>create：创建节点</li><li>delete：删除节点</li><li>exists：判断节点是否存在</li><li>getData：获得一个节点的数据</li><li>setData：设置一个节点的数据</li><li>getChildren：获取节点下的所有子节点</li></ul></li></ul><p>Zookeeper一致性</p><ul><li>Zookeeper Service集群是一主多从结构，更新数据时，首先跟新到主节点，在同步从节点。读取数据的时候可以读取任意节点</li></ul><p>Zookeeper应用场景：<br>-分布式协调服务</p><ul><li>分布式锁</li><li>服务注册与发现</li><li>共享配置和状态信息<br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/index.html" target="_blank" rel="noopener">Zookeeper IBM</a><br><a href="https://juejin.im/post/5b037d5c518825426e024473" target="_blank" rel="noopener">小灰 什么是ZooKeeper？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分布式协调服务-可以在分布式系统中共享配置，协调锁资源，提供命名服务&lt;/p&gt;
&lt;p&gt;Zookeeper的数据模型：像数据结构中的树，也像文件系统中的目录&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="分布式" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="ZK" scheme="https://zhangzhang18.github.io/myBlog/tags/ZK/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/12/06/Elasticsearch/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/12/06/Elasticsearch/</id>
    <published>2018-12-06T06:31:02.000Z</published>
    <updated>2019-10-11T10:55:51.960Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_document_oriented.html" target="_blank" rel="noopener">elasticsearch权威指南</a></p><p><strong>面向文档</strong><br>在应用程序中对象很少只是一个简单的键和值的列表。通常，它们拥有更复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。<br><a id="more"></a><br>Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。这种理解数据的方式与以往完全不同，这也是Elasticsearch能够执行复杂的全文搜索的原因之一。</p><p><strong>JSON</strong><br>Elasticsearch 使用 JavaScript Object Notation 或者 JSON 作为文档的序列化格式。</p><p>Elasticsearch集群可以包含多个索引(indices)（数据库），每一个索引可以包含多个类型(types)（表），每一个类型包含多个文档(documents)（行），然后每个文档包含多个字段(Fields)（列）。</p><p>所以为了创建员工目录，我们将进行如下操作：</p><p>为每个员工的文档(document)建立索引，每个文档包含了相应员工的所有信息。</p><p>每个文档的类型为employee。</p><p>employee类型归属于索引megacorp。</p><p>megacorp索引存储在Elasticsearch集群中。</p><p><a href="http://git.daojia-inc.com/jiazheng/jzup-brain.git" target="_blank" rel="noopener">http://git.daojia-inc.com/jiazheng/jzup-brain.git</a><br>实际上这些都是很容易的（尽管看起来有许多步骤）。我们能通过一个命令执行完成的操作：<br><code>PUT /megacorp/employee/1</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"first_name"</span>: <span class="string">"John"</span>,</span><br><span class="line"><span class="attr">"last_name"</span>: <span class="string">"Smith"</span>,</span><br><span class="line"><span class="attr">"age"</span>: <span class="number">25</span>,</span><br><span class="line"><span class="attr">"about"</span>: <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line"><span class="attr">"interests"</span>: [<span class="string">"sports"</span>, <span class="string">"music"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们看到path:/megacorp/employee/1包含三部分信息：名字说明megacorp索引名employee类型名1这个员工的ID</p><p>我们通过HTTP方法GET来检索文档，同样的，我们可以使用DELETE方法删除文档，使用HEAD方法检查某文档是否存在。如果想更新已存在的文档，我们只需再PUT一次。</p><p>我们尝试一个最简单的搜索全部员工的请求：</p><p><code>GET /megacorp/employee/_search</code></p><p>这种方法常被称作查询字符串(query string)搜索，因为我们像传递URL参数一样去传递查询语句：</p><p><code>GET /megacorp/employee/_search?q=last_name:Smith</code></p><p>使用DSL语句查询<br>DSL(Domain Specific Language特定领域语言)以JSON请求体的形式出现。我们可以这样表示之前关于“Smith”的查询:</p><p><code>GET /megacorp/employee/_search</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"query"</span>: &#123;</span><br><span class="line"><span class="attr">"match"</span>: &#123;</span><br><span class="line"><span class="attr">"last_name"</span>: <span class="string">"Smith"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这会返回与之前查询相同的结果。</p><p>更复杂的搜索</p><p>我们的语句将添加过滤器(filter),它使得我们高效率的执行一个结构化搜索：</p><p><code>GET /megacorp/employee/_search</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"query"</span>: &#123;</span><br><span class="line"><span class="attr">"filtered"</span>: &#123;</span><br><span class="line"><span class="attr">"filter"</span>: &#123;</span><br><span class="line"><span class="attr">"range"</span>: &#123;</span><br><span class="line"><span class="attr">"age"</span>: &#123;</span><br><span class="line"><span class="attr">"gt"</span>: <span class="number">30</span> //<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"query"</span>: &#123;</span><br><span class="line"><span class="attr">"match"</span>: &#123;</span><br><span class="line"><span class="attr">"last_name"</span>: <span class="string">"smith"</span>//<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><1> 这部分查询属于区间过滤器(range filter),它用于查找所有年龄大于30岁的数据——gt为”greater than”的缩写。</1></p><p><2> 这部分查询与之前的match语句(query)一致。</2></p><p>现在我们的搜索结果只显示了一个32岁且名字是“Jane Smith”的员工：<br>全文搜索<br>到目前为止搜索都很简单：搜索特定的名字，通过年龄筛选。让我们尝试一种更高级的搜索，全文搜索——一种传统数据库很难实现的功能。<br>我们将会搜索所有喜欢“rock climbing”的员工：</p><p><code>GET /megacorp/employee/_search</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解释了Elasticsearch如何在各种文本字段中进行全文搜索，并且返回相关性最大的结果集。相关性(relevance)的概念在Elasticsearch中非常重要，而这个概念在传统关系型数据库中是不可想象的，因为传统数据库对记录的查询只有匹配或者不匹配。</p><p>短语搜索<br>目前我们可以在字段中搜索单独的一个词，这挺好的，但是有时候你想要确切的匹配若干个单词或者短语(phrases)。例如我们想要查询同时包含”rock”和”climbing”（并且是相邻的）的员工记录。<br>要做到这个，我们只要将match查询变更为match_phrase查询即可:</p><p><code>GET /megacorp/employee/_search</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"query"</span>: &#123;</span><br><span class="line"><span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line"><span class="attr">"about"</span>: <span class="string">"rock climbing"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>高亮我们的搜索<br>很多应用喜欢从每个搜索结果中高亮(highlight)匹配到的关键字，这样用户可以知道为什么这些文档和查询相匹配。在Elasticsearch中高亮片段是非常容易的。<br>让我们在之前的语句上增加highlight参数：</p><p><code>GET /megacorp/employee/_search</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"query"</span>: &#123;</span><br><span class="line"><span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line"><span class="attr">"about"</span>: <span class="string">"rock climbing"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">"highlight"</span>: &#123;</span><br><span class="line"><span class="attr">"fields"</span>: &#123;</span><br><span class="line"><span class="attr">"about"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们运行这个语句时，会命中与之前相同的结果，但是在返回结果中会有一个新的部分叫做highlight，这里包含了来自about字段中的文本，并且用<em></em>来标识匹配到的单词。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/cn/elasticsearch/guide/current/_document_oriented.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;elasticsearch权威指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向文档&lt;/strong&gt;&lt;br&gt;在应用程序中对象很少只是一个简单的键和值的列表。通常，它们拥有更复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="ES" scheme="https://zhangzhang18.github.io/myBlog/tags/ES/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/11/10/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/11/10/分布式锁/</id>
    <published>2018-11-10T07:14:43.000Z</published>
    <updated>2019-10-11T09:58:34.888Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2018/11/10/分布式锁/suo.jpg" alt="image"></p><h3 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h3><p>将系统差分成不同的服务然后将这些服务放在不同服务器减轻单台服务的压力，提高性能和并发量。<br><a id="more"></a></p><blockquote><p>并发并行？</p></blockquote><p><img src="/myBlog/2018/11/10/分布式锁/concurrency.jpg" alt="concurrency"><br><img src="/myBlog/2018/11/10/分布式锁/parallel.jpg" alt="parallel"></p><pre><code>顺序执行：你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。    并行：你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。    并发：你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。    并发强调的是一起出发，并行强调的是一起执行。    并发的反义是顺序，并行的反义是串行。并发并行并不是互斥概念，只不过并发强调任务的抽象调度，并行强调任务的实际执行。    </code></pre><blockquote><p>分布式=高并发=多线程？</p></blockquote><pre><code>分布式：是为了解决单个物理服务器容量和性能瓶颈问题而采用的优化手段。            该领域需要解决的问题极多，在不同技术层面上，包括：分布式文件系统、缓存、数据库、计算等。           水平拓展：当一台机器扛不住流量时，通过添加机器的方式，将流量均分。            垂直拆分：前端有多种需求时，一台机器扛不住，可以将不同需求分发到不同机器上。    高并发：反应的是 [同时有多少量]，例如直播服务，同时可能有上万人观看。            高并发可以用分布式技术去解决，将并发流量分到不同物理机器上。            例如使用缓存技术和前端将静态资源放在CDN等；还可以用多线程技术将一台服务器的能力最大化。    多线程：是指从软件或硬件上实现多个线程并发执行的技术。            多线程聚焦于如何使用编程语言将CPU能力最大化。    </code></pre><h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>为了实现多个线程在同一时刻同一代码块只能有一个线程可执行，需要在某个地方做标记，这个标记必须满足所有的线程可见，标记不存在的时候设置标记，后续的线程发现已标记则等待拥有标记的线程结束，同步代码块取消标记后，在尝试设置标记，这个标记可以理解为锁。</p><h3 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h3><p>单体单机部署的系统被演化成分布式集群系统后，系统可能会有多份并且部署在不同的机器上，这些资源已经不是在线程之间共享了，而是属于进程之间共享的资源。<br>指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。</p><p>分布式的 CAP 理论：</p><blockquote><p>任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。</p></blockquote><h3 id="分布式锁要满足哪些要求呢"><a href="#分布式锁要满足哪些要求呢" class="headerlink" title="分布式锁要满足哪些要求呢"></a>分布式锁要满足哪些要求呢</h3><ul><li>互斥性：在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>容错性：获取或释放锁的机制必须高可用且性能佳</li><li>解铃还须系铃人：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ul><h3 id="分布式锁实现方式"><a href="#分布式锁实现方式" class="headerlink" title="分布式锁实现方式"></a>分布式锁实现方式</h3><p>为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。</p><blockquote><p>基于数据库实现分布式锁；<br>基于缓存（Redis等）实现分布式锁；<br>基于Zookeeper实现分布式锁；</p></blockquote><h4 id="基于数据库"><a href="#基于数据库" class="headerlink" title="基于数据库"></a>基于数据库</h4><p>思路：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。</p><h4 id="基于Redis"><a href="#基于Redis" class="headerlink" title="基于Redis"></a>基于Redis</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XttblogLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_SUCCESS = <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_IF_NOT_EXIST = <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SET_WITH_EXPIRE_TIME = <span class="string">"PX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long RELEASE_SUCCESS = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validParam</span><span class="params">(JedisPool jedisPool, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"jedisPool obj is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == lockKey || <span class="string">""</span>.equals(lockKey)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"lock key  is blank"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == requestId || <span class="string">""</span>.equals(requestId)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"requestId is blank"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (expireTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"expireTime is not allowed less zero"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(JedisPool jedisPool, String lockKey, String requestId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        validParam(jedisPool, lockKey, requestId, expireTime);</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">            <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">unLock</span><span class="params">(JedisPool jedisPool, String lockKey, String requestId)</span> </span>&#123;</span><br><span class="line">        validParam(jedisPool, lockKey, requestId, <span class="number">1</span>);</span><br><span class="line">        String script = <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            Object result = jedis.eval(script, Collections.singletonList(lockKey),Collections.singletonList(requestId));</span><br><span class="line">            <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.core.RLock;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonLockUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RedissonLockUtil.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Redisson redisson = RedissonManager.getRedisson();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOCK_FLAG = <span class="string">"recruitlock_"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据name对进行上锁操作，redissonLock 阻塞的，采用的机制发布/订阅</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        String lockKey = LOCK_FLAG + key;</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        <span class="comment">//lock提供带timeout参数，timeout结束强制解锁，防止死锁 ：1分钟</span></span><br><span class="line">        lock.lock(<span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line">        logger.info(<span class="string">"lock key:&#123;&#125;"</span>,lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据name对进行解锁操作</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        String lockKey = LOCK_FLAG + key;</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        <span class="keyword">if</span> (lock.isHeldByCurrentThread())</span><br><span class="line">        &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            logger.info(<span class="string">"unlock , key:&#123;&#125;"</span>+lockKey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> millisToWait 等待获取锁的时间--单位：秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(String key, <span class="keyword">long</span> millisToWait)</span> </span>&#123;</span><br><span class="line">        String lockKey = LOCK_FLAG + key;</span><br><span class="line">        logger.info(<span class="string">"get redis lock start , key:&#123;&#125;"</span>+lockKey);</span><br><span class="line">        RLock lock = redisson.getLock(lockKey);</span><br><span class="line">        logger.info(<span class="string">"get redis lock end , key:"</span>+lockKey);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>  lock.tryLock(millisToWait,<span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(<span class="string">"try lock error,key is:&#123;&#125;"</span>, lockKey, e);</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">"get redis lock false , key:"</span>+lockKey);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line"> if (result == 1) &#123;</span><br><span class="line">     // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span><br><span class="line">     jedis.expire(lockKey, expireTime);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://www.cnblogs.com/seesun2012/p/9214653.html" target="_blank" rel="noopener">https://www.cnblogs.com/seesun2012/p/9214653.html</a></p><p><a href="http://www.cnblogs.com/linjiqin/p/8003838.html" target="_blank" rel="noopener">http://www.cnblogs.com/linjiqin/p/8003838.html</a></p><p><a href="https://www.xttblog.com/?p=3171" target="_blank" rel="noopener">https://www.xttblog.com/?p=3171</a></p><p><a href="https://juejin.im/post/5c01532ef265da61362232ed" target="_blank" rel="noopener">https://juejin.im/post/5c01532ef265da61362232ed</a></p><p><img src="/myBlog/2018/11/10/分布式锁/bye.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2018/11/10/分布式锁/suo.jpg&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是分布式&quot;&gt;&lt;a href=&quot;#什么是分布式&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式&quot;&gt;&lt;/a&gt;什么是分布式&lt;/h3&gt;&lt;p&gt;将系统差分成不同的服务然后将这些服务放在不同服务器减轻单台服务的压力，提高性能和并发量。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="分布式" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/10/15/Dubbo/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/10/15/Dubbo/</id>
    <published>2018-10-15T03:35:25.000Z</published>
    <updated>2019-05-24T06:17:12.617Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo 工作原理：服务注册、注册中心、消费者、代理通信、负载均衡；</p><p><a href="http://dubbo.apache.org/zh-cn/docs/user/quick-start.html" target="_blank" rel="noopener">Dubbo</a></p><p><a href="https://www.cnblogs.com/hd3013779515/p/6896942.html" target="_blank" rel="noopener">Dubbo集群容错</a></p><p>一般的mvc项目 包含 Controller、Servicei、ServiceImpl、dao三层<br>使用doubbo我们可以把项目拆分：<br>Controller 作为 “消费着” 一个项目<br>ServiceImpl +dao 作为 “提供者” 一个项目</p><p>Service “接口” 可以作为一个项目</p><p><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-operating-principle.md" target="_blank" rel="noopener">https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-operating-principle.md</a></p><p><img src="/myBlog/2018/10/15/Dubbo/dubbo-operating-principle.png" alt="dubbo-operating-principle"></p><p>Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。</p><p><strong>节点角色说明：</strong></p><pre><code>*  Provider: 暴露服务的服务提供方。*  Consumer: 调用远程服务的服务消费方。*  Registry: 服务注册与发现的注册中心。*  Monitor: 统计服务的调用次调和调用时间的监控中心。*  Container: 服务运行容器。</code></pre><a id="more"></a><p><img src="/myBlog/2018/10/15/Dubbo/dubbo.jpg" alt="Dubbo"></p><p>###　<strong>工作流程</strong></p><pre><code>第一步：provider向注册中心注册服务第二部：consumer从注册中心订阅服务，注册中心会通知consumer注册好的服务第三部：consumer调用provider第四步：provider和consumer都异步通知监控中心</code></pre><h3 id="调用关系说明："><a href="#调用关系说明：" class="headerlink" title="调用关系说明："></a><strong>调用关系说明：</strong></h3><pre><code>* 服务容器负责启动，加载，运行服务提供者。* 服务提供者在启动时，向注册中心注册自己提供的服务。* 服务消费者在启动时，向注册中心订阅自己所需的服务。* 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。* 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。* 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</code></pre><h3 id="Dubbo-负载均衡策略"><a href="#Dubbo-负载均衡策略" class="headerlink" title="Dubbo 负载均衡策略"></a><strong>Dubbo 负载均衡策略</strong></h3><p>  1.random load balance：<strong>随机</strong>调用实现负载均衡，可以对 provider不同实例<strong>设置不同的权重</strong>，会按照权重来负载均衡，权重越大分配流量越高。<br>  2.roundrobin loadbalance:<strong>均匀</strong>的打到各个机器，可以将性能差的机器权重小一点。<br>  3.leastactive loadbalance：<strong>自动感知</strong>，如果某个机器性能越差，那么接收的请求越少，越不活跃，此时就会给<strong>不活跃的性能差的机器更少的请求</strong>。<br>  4.consistanthash loadbalance：一致性 Hash 算法，<strong>相同参数的请求</strong>一定分发到一个 provider 上去，provider 挂掉的时候，会基于虚拟节点均匀分配剩余的流量，抖动不会太大。如果需要的不是随机负载均衡，是要一类请求都到一个节点，那就走这个一致性 Hash 策略。</p><h3 id="Dubbo-集群容错策略"><a href="#Dubbo-集群容错策略" class="headerlink" title="Dubbo 集群容错策略"></a><strong>Dubbo 集群容错策略</strong></h3><p>  1.failover cluster ：<strong>失败自动切换</strong>，自动重试其他机器，默认就是这个，常见于<strong>读操作</strong>。（失败重试其它机器）<code>&lt;dubbo:service retries=&quot;2&quot; /&gt;</code><br>  2.failfast cluster ：一次调用失败就立即失败，常见于<strong>幂等性写操作</strong>。（调用失败就立即失败）<br>  3.failsafe cluster ：出现异常时忽略掉，常用于不重要的接口调用，比如<strong>记录日志</strong>。<br>  4.failback cluster ：失败了后台自动记录请求，然后定时重发，比较适合于<strong>写消息队列</strong>这种。<br>  5.forking  cluster ：并行调用多个 provider，只要一个成功就立即返回。常用于<strong>实时性要求比较高的读操作</strong>，但是会浪费资源。<br>  6.broadcast cluster：逐个调用所有的 provider。通常用于<strong>通知</strong>所有提供者更新缓存或日志等本地资源信息。</p><p>用 Spring 配置声明暴露服务<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"hello-world-app"</span>  /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.dubbo.demo.provider.DemoServiceImpl"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>加载Spring配置Provider.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"http://10.20.160.198/wiki/display/dubbo/provider.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line"></span><br><span class="line">        System.in.read(); <span class="comment">// 按任意键退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务消费者<br>通过Spring配置引用远程服务<br>consumer.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"consumer-of-helloworld-app"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"multicast://224.5.6.7:1234"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> /&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>加载Spring配置，并调用远程服务<br>Consumer.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[] &#123;<span class="string">"http://10.20.160.198/wiki/display/dubbo/consumer.xml"</span>&#125;);</span><br><span class="line">        context.start();</span><br><span class="line"></span><br><span class="line">        DemoService demoService = (DemoService)context.getBean(<span class="string">"demoService"</span>); <span class="comment">// 获取远程服务代理</span></span><br><span class="line">        String hello = demoService.sayHello(<span class="string">"world"</span>); <span class="comment">// 执行远程方法</span></span><br><span class="line"></span><br><span class="line">        System.out.println( hello ); <span class="comment">// 显示调用结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注册中心挂了还可以继续通信：因为刚开始初始化的时候，消费者会将服务提供者的地址拉取到本地。</p><p>通信协议：<br>    dubbo：单一长连接，进行NIO异步通信，基于<strong>hessian</strong>序列化协议。（长连接，通俗说就是建立连接之后可以持续发送请求，无需再建立连接）<br>               使用场景是传输数据量小（100kb以内），并发量高。<br>    rmi：java 的二进制序列化，适用于文件传输。<br>    hessian：hessian序列化<br>    http：json序列化<br>    webservice：soap文本序列化</p><p>服务治理：1.调用链路自动生成 2.服务访问压力及时长<br>服务降级：服务A调用服务B，B挂掉了，A重试几次还是不行，降级，走一个备用逻辑返回给用户。<br>失败重试超时重试：consumer调用provider失败了，可以重试，或者调用超时了也可以重试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dubbo 工作原理：服务注册、注册中心、消费者、代理通信、负载均衡；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dubbo.apache.org/zh-cn/docs/user/quick-start.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dubbo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hd3013779515/p/6896942.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dubbo集群容错&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一般的mvc项目 包含 Controller、Servicei、ServiceImpl、dao三层&lt;br&gt;使用doubbo我们可以把项目拆分：&lt;br&gt;Controller 作为 “消费着” 一个项目&lt;br&gt;ServiceImpl +dao 作为 “提供者” 一个项目&lt;/p&gt;
&lt;p&gt;Service “接口” 可以作为一个项目&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-operating-principle.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/dubbo-operating-principle.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/myBlog/2018/10/15/Dubbo/dubbo-operating-principle.png&quot; alt=&quot;dubbo-operating-principle&quot;&gt;&lt;/p&gt;
&lt;p&gt;Dubbo缺省协议采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点角色说明：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*  Provider: 暴露服务的服务提供方。
*  Consumer: 调用远程服务的服务消费方。
*  Registry: 服务注册与发现的注册中心。
*  Monitor: 统计服务的调用次调和调用时间的监控中心。
*  Container: 服务运行容器。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="分布式" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="Dubbo" scheme="https://zhangzhang18.github.io/myBlog/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Spring+Shiro+Redis实践</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/08/08/Spring+Shiro+Redis%E5%AE%9E%E8%B7%B5/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/08/08/Spring+Shiro+Redis实践/</id>
    <published>2018-08-08T06:32:27.000Z</published>
    <updated>2019-01-18T10:56:24.772Z</updated>
    
    <content type="html"><![CDATA[<p>Apache Shiro是Java的一个安全框架。<br>使用Spring+Shiro+Redis完成登录注册，权限认证的功能。<br><img src="/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro-core.png" alt="core"><br><a id="more"></a><br>Subject本质上就是当前访问用户的抽象描述。所有</p><p><img src="/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro.png" alt="shiro"></p><p><img src="/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro-action.png" alt="action"><br><img src="/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro-diagram.png" alt="diagram"></p><p><a href="http://jinnianshilongnian.iteye.com/blog/2018398" target="_blank" rel="noopener">参考张开涛《跟我学Shiro教程》</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Apache Shiro是Java的一个安全框架。&lt;br&gt;使用Spring+Shiro+Redis完成登录注册，权限认证的功能。&lt;br&gt;&lt;img src=&quot;/myBlog/2018/08/08/Spring+Shiro+Redis实践/shiro-core.png&quot; alt=&quot;core&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="Spring" scheme="https://zhangzhang18.github.io/myBlog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JAVA-IO</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/05/18/JAVA-IO/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/05/18/JAVA-IO/</id>
    <published>2018-05-18T07:44:56.000Z</published>
    <updated>2019-02-18T10:16:04.380Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式：装饰者模式<br><img src="/myBlog/2018/05/18/JAVA-IO/iostream.png" alt="iostream"></p><a id="more"></a><p><strong>NIO</strong><br><a href="https://link.juejin.im/?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzU4NDQ4MzU5OA%3D%3D%26mid%3D2247483956%26idx%3D1%26sn%3D57692bc5b7c2c6dfb812489baadc29c9%26chksm%3Dfd985455caefdd4331d828d8e89b22f19b304aa87d6da73c5d8c66fcef16e4c0b448b1a6f791%23rd" target="_blank" rel="noopener">Snailclimb Java NIO 概览</a></p><ul><li>IO是面向流的，NIO是面向缓冲区的</li><li>IO流是阻塞的，NIO流是不阻塞的。</li><li>NIO有选择器，而IO没有。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式：装饰者模式&lt;br&gt;&lt;img src=&quot;/myBlog/2018/05/18/JAVA-IO/iostream.png&quot; alt=&quot;iostream&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="IO" scheme="https://zhangzhang18.github.io/myBlog/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Spring-事物</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/02/16/Spring-%E4%BA%8B%E7%89%A9/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/02/16/Spring-事物/</id>
    <published>2018-02-16T04:50:21.000Z</published>
    <updated>2019-10-11T05:58:35.750Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2018/02/16/Spring-事物/shiwu.png" alt="事物"><br><a id="more"></a></p><ol><li>原子性：要么全部执行成功，要么全部执行失败</li><li>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏</li><li>隔离性：并发的食物是互相隔离的，一个事物执行不被其他事物影响</li><li><p>持久性：事物一旦提交，对数据库的改变是永久性的</p></li><li><p>脏读：指在一个事务处理过程里读取了另一个未提交的事务中的数据。</p></li><li>不可重复读：一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li><li>幻读：同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。幻读和不可重复读都是读取了另一条已经提交的事务</li></ol><p>MySQL数据库提供的四种隔离级别：</p><p>　　① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</p><p>　　② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</p><p>　　③ Read committed (读已提交)：可避免脏读的发生。</p><p>　　④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p><p><a href="https://blog.csdn.net/bao19901210/article/details/41724355" target="_blank" rel="noopener">spring事物配置</a><br>事务隔离级别</p><p><strong>隔离级别是指若干个并发的事务之间的隔离程度</strong>。TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><blockquote><ul><li>TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。</li><li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。</li><li>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li><li>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。</li><li>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul></blockquote><hr><p>事务传播行为</p><p>所谓事务的传播行为是指，<strong>如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。</strong> 在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p><blockquote><ul><li>TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。</li><li>TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li><li>TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul></blockquote><hr><p>数据库范式</p><p>第一范式：所有字段值都是不可分解的原子值（属性不可分）</p><p>第二范式：也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。（符合1NF，并且，非主属性完全依赖于码。）</p><p>第三范式：每一列数据都和主键直接相关，而不能间接相关。（符合2NF，并且，消除传递依赖）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2018/02/16/Spring-事物/shiwu.png&quot; alt=&quot;事物&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring-AOP</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/01/20/Spring-AOP/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/01/20/Spring-AOP/</id>
    <published>2018-01-20T09:27:23.000Z</published>
    <updated>2019-09-26T02:42:05.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-AOP面向切面编程"><a href="#3-AOP面向切面编程" class="headerlink" title="3.AOP面向切面编程"></a>3.AOP面向切面编程</h1><blockquote><p>OOP面向对象编程的基本单位是<strong>类</strong>，AOP的基本单位是<strong>方法</strong><br>适用于具有横切逻辑的应用场景，例如性能检测、范文控制、事物管理、及日志管理</p></blockquote><p>AOP希望将分散在各个业务逻辑代码中的相同代码通过横向切割的方式抽取到一个独立独立的模块中。<br><a id="more"></a></p><h2 id="3-1概念和术语"><a href="#3-1概念和术语" class="headerlink" title="3.1概念和术语"></a>3.1概念和术语</h2><ol><li>Aspect(切面):切面通常是指一个类，是通知和切入点的结合，@Aspect类注解。</li><li>Join point(连接点):程序执行的某个特定位置，例如类初始化前，类初始化后，方法执行前，方法执行后，方法抛出异常时等，Spring只支持方法级别的连接点，即方法执行前，方法执行后，方法抛出异常时，</li><li>Advice(增强):增强是织入到目标类连接点上的一段程序代码</li><li>Pointcut(切点):每个程序类都拥有多个连接点，如一个拥有两个方法的类，这两个方法都是连接点，即连接点是程序类中客观存在的事物 @Pointcut(“”)</li><li>Introduction(引介):允许向现有的类添加新方法或属性</li><li>Target object(目标对象):增强逻辑的织入目标类</li><li>AOP proxy(代理):一个类被AOP织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类</li><li>Weaving(织入):织入是将增强添加对目标类具体连接点上的过程<br>AOP有三种织入的方式：<ul><li>a、编译期织入，这要求使用特殊的Java编译器。</li><li>b、类装载期织入，这要求使用特殊的类装载器ClassLoader。</li><li>c、动态代理织入，在运行期为目标类添加增强生成子类的方式。<br>Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。</li></ul></li></ol><h3 id="3-1-1实现"><a href="#3-1-1实现" class="headerlink" title="3.1.1实现"></a>3.1.1实现</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>  <span class="attr">poxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">"testAspect"</span> <span class="attr">class</span>=<span class="string">"com.test.company.aop.TestAspect"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//切面就是切点和通知的组合体</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 切点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(*com.test.company.service.Impl.TestImpl.insert(..))"</span>)<span class="comment">//Pointcut 使用pointcut定义切点</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertPointcut</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 环绕通知</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> pjp</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"insertPointcut()"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">public</span> Object <span class="title">insert</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable</span>&#123;&#125;</span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 前置通知</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(*com.test.company.service.Impl.TestImpl.insert(..))"</span>)<span class="comment">//execution(*insert(..)) 切点表达式“execution”为关键字，“*insert(..)”为操作参数</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Before</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知</span></span><br><span class="line"><span class="comment">     * returnVal,切点方法执行后的返回值</span></span><br><span class="line"><span class="comment">     */</span>    </span><br><span class="line">    <span class="meta">@AfterReturning</span>(value=<span class="string">"execution(*com.test.company.service.Impl.TestImpl.insert(..))"</span>,returning = <span class="string">"returnVal"</span>)</span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AfterReturning</span><span class="params">(Object returnVal)</span></span>&#123; &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通知有5种类型如下：</p><pre><code>before 目标方法执行前执行，前置通知after 目标方法执行后执行，后置通知after returning 目标方法返回时执行 ，后置返回通知after throwing 目标方法抛出异常时执行 异常通知around 在目标函数执行中执行，可控制目标函数是否执行，环绕通知</code></pre><h3 id="3-1-2-相关Java基础知识"><a href="#3-1-2-相关Java基础知识" class="headerlink" title="3.1.2 相关Java基础知识"></a>3.1.2 相关Java基础知识</h3><ol><li>代理模式<blockquote><p>为某对象提供一个代理，从而通过代理来访问这个对象。</p></blockquote></li></ol><p>代理模式有三种角色组成:</p><pre><code>抽象角色(卖票)：接口代理角色(车票代售点)：Proxy真实角色(火车站)：实现</code></pre><ol><li><p>动态代理<br>代理类在程序运行前就已经存在，那么这种代理方式被成为 静态代理<br>静态代理：是在编译class文件时生成得代码逻辑。</p></li><li><p>JDK动态代理 </p><blockquote><p>jdk动态代理是由java内部的反射机制来实现的</p></blockquote></li></ol><p>主要涉及java.lang.reflect 包中：Proxy和InvocationHandler</p><p>使用动态代理需要定义一个位于代理类与委托类之间的中介类,中介类需要实现InvocationHandler定义的横切逻辑，通过反射机制调用目标类的方法，动态的将横切逻辑和业务逻辑编织在一起，InvocationHandler接口只定义了一个invoke方法<br>通过”Proxy”类提供的一个newProxyInstance方法用来创建一个对象的代理对象</p><p>JDK动态代理：是JDK自带的功能;是java.lang.reflect.*包提供的方式，它必须借助一个接口才能产生代理对象。<br>    实现代理逻辑类必须去实现InvocationHandler类</p><pre><code>1. 建立代理对象和真实对象的关系（blind()）2. 实现代理逻辑方法（invoke()）</code></pre><p>CGLIB：是第三方提供的技术;不需要提供接口，只要有一个非抽象类就可以实现。</p><p>二者都是通过getProxy()生成代理对象。<br>Spring常用这两种，Mybatis还使用Javassist。<br>拦截器是JDK动态代理。</p><p><a href="https://zhuanlan.zhihu.com/p/25522841" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25522841</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;3-AOP面向切面编程&quot;&gt;&lt;a href=&quot;#3-AOP面向切面编程&quot; class=&quot;headerlink&quot; title=&quot;3.AOP面向切面编程&quot;&gt;&lt;/a&gt;3.AOP面向切面编程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;OOP面向对象编程的基本单位是&lt;strong&gt;类&lt;/strong&gt;，AOP的基本单位是&lt;strong&gt;方法&lt;/strong&gt;&lt;br&gt;适用于具有横切逻辑的应用场景，例如性能检测、范文控制、事物管理、及日志管理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AOP希望将分散在各个业务逻辑代码中的相同代码通过横向切割的方式抽取到一个独立独立的模块中。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Spring" scheme="https://zhangzhang18.github.io/myBlog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-IOC</title>
    <link href="https://zhangzhang18.github.io/myBlog/2018/01/16/Spring-IOC/"/>
    <id>https://zhangzhang18.github.io/myBlog/2018/01/16/Spring-IOC/</id>
    <published>2018-01-16T09:27:23.000Z</published>
    <updated>2019-01-21T08:46:13.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Spring框架简介"><a href="#1-Spring框架简介" class="headerlink" title="1.Spring框架简介"></a>1.Spring框架简介</h1><p>Spring框架是基于Java平台的，它为开发Java应用提供了全方位的基础设施支持，并且它很好地处理了这些基础设施，所以你只需要关注你的应用本身即可。</p><p>Spring可以使用POJO（普通的Java对象，plain old java objects）创建应用，并且可以将企业服务非侵入式地应用到POJO。这项功能适用于Java SE编程模型以及全部或部分的Java EE。<br><a id="more"></a></p><h1 id="2-Spring模块结构"><a href="#2-Spring模块结构" class="headerlink" title="2.Spring模块结构"></a>2.Spring模块结构</h1><p><img src="/myBlog/2018/01/16/Spring-IOC/core.jpg" alt="core"></p><h2 id="2-1-IOC-控制反转"><a href="#2-1-IOC-控制反转" class="headerlink" title="2.1 IOC 控制反转"></a>2.1 IOC 控制反转</h2><blockquote><p>IoC也称为依赖注入（DI）<br>是为了解决对象之间的耦合度过高的问题</p></blockquote><p>钟表拥有多个独立的齿轮，这些齿轮相互啮合在一起，齿轮相互啮合在一起，协同工作，共同完成某项任务。如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。与软件系统中对象之间的耦合关系非常相似</p><p>软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”。</p><p>借助于“第三方”实现具有依赖关系的对象之间的解耦，这个“第三方”也就是IOC容器。</p><p><strong>哪些方面的控制被反转了呢</strong></p><ul><li>获得依赖对象的过程被反转了</li></ul><p>所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。</p><p>所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。</p><p>把依赖注入应用到软件系统中，再来描述一下这个过程：</p><ul><li>对象A依赖于对象B,当对象 A需要用到对象B的时候，IOC容器就会立即创建一个对象B送给对象A。</li><li>IOC容器就是一个对象制造工厂，你需要什么，它会给你送去，你直接使用就行了，而再也不用去关心你所用的东西是如何制成的，也不用关心最后是怎么被销毁的，这一切全部由IOC容器包办。</li></ul><h3 id="2-1-1-相关Java基础知识"><a href="#2-1-1-相关Java基础知识" class="headerlink" title="2.1.1 相关Java基础知识"></a>2.1.1 相关Java基础知识</h3><p>IOC流程<br><img src="/myBlog/2018/01/16/Spring-IOC/ioc.png" alt="ioc"></p><p><strong>反射</strong>：Java语言允许通过程序化的方式间接对class操作，Class文件由类加载器转载后，JVM形成一份描述Class结构的元信息，通过元信息对象可以获取到构造函数，属性和方法等。<br>      通过这个元信息对象间接的调用Class对象的功能。</p><p>几个重要的反射类：</p><blockquote><p>ClassLoader，Class，Constructor，和Method </p></blockquote><p>ClassLoader：类装载器，把一个类装入到JVM。<br>   需要经过：</p><pre><code>- 1.装载- 2.链接 校验 准备  解析- 3.初始化</code></pre><h3 id="2-1-2-IOC容器中转配Bean"><a href="#2-1-2-IOC容器中转配Bean" class="headerlink" title="2.1.2 IOC容器中转配Bean"></a>2.1.2 IOC容器中转配Bean</h3><ol><li><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views/"</span> /&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Spring 支持两种依赖注入方式：属性注入和构造函数注入，还支持工厂方法注入方式。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SpringBeanFactory.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title">getBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (BeanFactory.class) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String path = Config.getConfigFolder();</span><br><span class="line">                    <span class="keyword">if</span> (beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        beanFactory = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"/"</span> + path + <span class="string">"aplication-spring-dubbo.xml"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"初始化SpringDubbo Error"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```   </span><br><span class="line"><span class="number">3</span>. **自动装配 - autowire=<span class="string">"自动装配类型"</span>**</span><br><span class="line">   - byName：根据名称自动匹配</span><br><span class="line">   - byType：根据类型自动匹配</span><br><span class="line">   - constructor：与byType类似，它只针对构造函数注入的</span><br><span class="line">   - autodetect：</span><br><span class="line"><span class="number">4</span>. **bean作用域 - scope=<span class="string">"作用域"</span>**</span><br><span class="line">   - singleton：在IOC容器中只存在一个实例，以单例的方式存在,默认值</span><br><span class="line">   - prototype：每次从容器调用Bean时，都返回一个新的实例</span><br><span class="line">   - request：每次HTTP请求都会创建一个新的Bean，只适用于WebApplicationContext环境</span><br><span class="line">   - session：同一个HTTP Session共享一个Bean，只适用于WebApplicationContext环境</span><br><span class="line">   - global-session：</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>. **基于注解定义Bean**</span><br><span class="line"></span><br><span class="line"><span class="meta">@component</span>可以替代下面三种注解，为了清晰化，建议使用特定的注解</span><br><span class="line">   - <span class="meta">@Repository</span>：DAO层实现类</span><br><span class="line">   - <span class="meta">@Service</span>：Service实现类</span><br><span class="line">   - <span class="meta">@Controller</span>：Service实现类</span><br><span class="line">扫描包以应用注解的Bean</span><br><span class="line">```xml</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.test.company.*"</span> /&gt;</span><br></pre></td></tr></table></figure><p>Spring使用@Autowired注解实现Bean依赖注入<br>@Autowired默认按照byType匹配在容器中查找Bean<br>若想希望找不到Bean也不报NoSuchBeanDefinitionException异常，可以使用@Autowired(require=false)<br>@Qualifier注解可以限定Bean的名字</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Qualifier(&quot;userDaop&quot;)</span><br><span class="line">private UserDao userDao;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/wang-meng/p/5597490.html" target="_blank" rel="noopener">https://www.cnblogs.com/wang-meng/p/5597490.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Spring框架简介&quot;&gt;&lt;a href=&quot;#1-Spring框架简介&quot; class=&quot;headerlink&quot; title=&quot;1.Spring框架简介&quot;&gt;&lt;/a&gt;1.Spring框架简介&lt;/h1&gt;&lt;p&gt;Spring框架是基于Java平台的，它为开发Java应用提供了全方位的基础设施支持，并且它很好地处理了这些基础设施，所以你只需要关注你的应用本身即可。&lt;/p&gt;
&lt;p&gt;Spring可以使用POJO（普通的Java对象，plain old java objects）创建应用，并且可以将企业服务非侵入式地应用到POJO。这项功能适用于Java SE编程模型以及全部或部分的Java EE。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Spring" scheme="https://zhangzhang18.github.io/myBlog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>面试常用手写代码</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/10/12/%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/10/12/面试常用手写代码/</id>
    <published>2017-10-12T13:07:31.000Z</published>
    <updated>2019-10-12T10:25:12.556Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i,j,t,temp;</span><br><span class="line">  <span class="keyword">if</span>(left &gt;right)&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  temp=a[left];</span><br><span class="line">  i=left;</span><br><span class="line">  j=right;</span><br><span class="line">  <span class="keyword">while</span>(i!=j)&#123;</span><br><span class="line">    <span class="keyword">while</span>(a[j]&gt;=temp&amp;&amp;i&lt;j)&#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(a[i]&gt;=temp&amp;&amp;i&lt;j)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">        t=a[i];</span><br><span class="line">        a[i]=a[j];</span><br><span class="line">        a[j]=t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  a[left]=a[i];</span><br><span class="line">  a[i]=temp;</span><br><span class="line">  quicpSort(left,i-<span class="number">1</span>);</span><br><span class="line">  quickSort(i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="/myBlog/2017/10/12/面试常用手写代码/qs.png" alt="快速排序步骤"><br><img src="/myBlog/2017/10/12/面试常用手写代码/qs2.png" alt="快速排序理解"></p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">           <span class="comment">//折半成两个小集合，分别进行递归</span></span><br><span class="line">           <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">           mergeSort(arr, start, mid);</span><br><span class="line">           mergeSort(arr, mid + <span class="number">1</span>, end);</span><br><span class="line">           <span class="comment">//把有序小集合，归并成大集合</span></span><br><span class="line">           merge(arr, start, mid, end);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//开辟额外大集合</span></span><br><span class="line">       <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">       <span class="keyword">int</span> p1 = start, p2 = mid + <span class="number">1</span>, p = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//比较两个小集合放入大集合</span></span><br><span class="line">       <span class="keyword">while</span> (p1 &lt; mid &amp;&amp; p2 &lt; end) &#123;</span><br><span class="line">           <span class="keyword">if</span> (arr[p1] &lt;= arr[p2]) &#123;</span><br><span class="line">               temp[p++] = arr[p1++];</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               temp[p++] = arr[p2++];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//左侧有剩余</span></span><br><span class="line">       <span class="keyword">while</span> (p1 &lt; mid) &#123;</span><br><span class="line">           temp[p++] = arr[p1++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//右侧有剩余</span></span><br><span class="line">       <span class="keyword">while</span> (p2 &lt; end) &#123;</span><br><span class="line">           temp[p++] = arr[p2++];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//复制回原数组</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">           arr[i + start] = temp[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/myBlog/2017/10/12/面试常用手写代码/ms.jpg" alt="归并图解"></p><p><img src="/myBlog/2017/10/12/面试常用手写代码/allSort.png" alt="排序对比"></p><h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><h2 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h2><p>volatile 的一个语义禁止指令重排优化。在读取变量的时候直接从内存读取，保证所有线程看到的变量值都是相同的，<br>synchronized关键字锁住类<br>进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//检查实例，如果不存在，就进入同步代码块</span></span><br><span class="line">      <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;<span class="comment">//  双重检测机制  </span></span><br><span class="line">          <span class="keyword">synchronized</span>(Singleton.class)&#123;<span class="comment">//1  同步锁 类对象加锁</span></span><br><span class="line">              <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;<span class="comment">//2  双重检测机制</span></span><br><span class="line">                  instance = <span class="keyword">new</span> Singleton();<span class="comment">//3  </span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/myBlog/2017/10/12/面试常用手写代码/single.jpg" alt="single"></p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> LazyHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JVM会组织反射获取枚举类的私有构造方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/myBlog/2017/10/12/面试常用手写代码/compare.jpg" alt="compare"></p><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="非递归遍历二叉树"><a href="#非递归遍历二叉树" class="headerlink" title="非递归遍历二叉树"></a>非递归遍历二叉树</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">           stack.push(head);</span><br><span class="line">           <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">               head = stack.pop();</span><br><span class="line">               System.out.print(head.val + <span class="string">" "</span>);</span><br><span class="line">               <span class="keyword">if</span> (head.right != <span class="keyword">null</span>)</span><br><span class="line">                   stack.push(head.right);</span><br><span class="line">               <span class="keyword">if</span> (head.left != <span class="keyword">null</span>)</span><br><span class="line">                   stack.push(head.left);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">findDeep</span><span class="params">(BiTree root)</span>  </span></span><br><span class="line"><span class="function">  </span>&#123;  </span><br><span class="line">      <span class="keyword">int</span> deep = <span class="number">0</span>;  </span><br><span class="line">      <span class="keyword">if</span>(root != <span class="keyword">null</span>)  </span><br><span class="line">      &#123;  </span><br><span class="line">          <span class="keyword">int</span> lchilddeep = findDeep(root.left);  </span><br><span class="line">          <span class="keyword">int</span> rchilddeep = findDeep(root.right);  </span><br><span class="line">          deep = lchilddeep &gt; rchilddeep ? lchilddeep + <span class="number">1</span> : rchilddeep + <span class="number">1</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">return</span> deep;  </span><br><span class="line">  &#125;  </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 链表</span><br><span class="line"></span><br><span class="line">## 单链表反转</span><br><span class="line">```java</span><br><span class="line">     <span class="function">Node <span class="title">reverse</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node prev = <span class="keyword">null</span>;</span><br><span class="line">        Node now = head;</span><br><span class="line">        <span class="keyword">while</span> (now != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = now.next;</span><br><span class="line">            now.next = prev;</span><br><span class="line">            prev = now;</span><br><span class="line">            now = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="删除重复值"><a href="#删除重复值" class="headerlink" title="删除重复值"></a>删除重复值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function">Node <span class="title">deleteRepeat</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == head || <span class="keyword">null</span> == head.next) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    Node pre = head;</span><br><span class="line">    Node cur = head.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.val == pre.val) &#123;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">meetingNode</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node slow = head.next;</span><br><span class="line">    <span class="keyword">if</span> (slow == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node fast = slow.next;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span> &amp;&amp; fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> fast;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表中环入口节点"><a href="#链表中环入口节点" class="headerlink" title="链表中环入口节点"></a>链表中环入口节点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">nodeOfLoop</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到相遇节点</span></span><br><span class="line">    Node meetingNode = meetingNode(head);</span><br><span class="line">    <span class="keyword">if</span> (meetingNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到环节点数</span></span><br><span class="line">    <span class="keyword">int</span> nodeInLoopNum = <span class="number">1</span>;</span><br><span class="line">    Node p1 = meetingNode;</span><br><span class="line">    <span class="keyword">while</span> (p1.next != meetingNode) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        ++nodeInLoopNum;</span><br><span class="line">    &#125;</span><br><span class="line">    p1 = head;</span><br><span class="line">    Node p2 = head;</span><br><span class="line">    <span class="comment">//p1先移动环节点数nodeInLoopNum步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeInLoopNum; i++) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后p1,p2以相同速度移动</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        p1 = p1.next;</span><br><span class="line">        p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断两个链表是否相交"><a href="#判断两个链表是否相交" class="headerlink" title="判断两个链表是否相交"></a>判断两个链表是否相交</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isIntersert</span><span class="params">(Node h1, Node h2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="keyword">null</span> || h2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node tail = h1;</span><br><span class="line">    Node tail2 = h2;</span><br><span class="line">    <span class="keyword">while</span> (tail.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (tail2.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tail2 = tail2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail == tail2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="合并两个有序数据，结果任然有序"><a href="#合并两个有序数据，结果任然有序" class="headerlink" title="合并两个有序数据，结果任然有序"></a>合并两个有序数据，结果任然有序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] result;</span><br><span class="line">    result = <span class="keyword">new</span> <span class="keyword">int</span>[a.length + b.length];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.length &amp;&amp; j &lt; b.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; b[j]) &#123;</span><br><span class="line">            result[k++] = a[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result[k++] = b[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; a.length) &#123;</span><br><span class="line">        result[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; b.length) &#123;</span><br><span class="line">        result[k++] = b[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">         <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">if</span> (key == arr[mid]) &#123;</span><br><span class="line">             <span class="keyword">return</span> mid;</span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; arr[mid]) &#123;</span><br><span class="line">             low = mid + <span class="number">1</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             high = mid - <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;排序&quot;&gt;&lt;a href=&quot;#排序&quot; class=&quot;headerlink&quot; title=&quot;排序&quot;&gt;&lt;/a&gt;排序&lt;/h1&gt;&lt;h2 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; a[&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;],n;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;quickSort&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; left,&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; right)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i,j,t,temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(left &amp;gt;right)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  temp=a[left];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  i=left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  j=right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(i!=j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(a[j]&amp;gt;=temp&amp;amp;&amp;amp;i&amp;lt;j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        j--;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt;(a[i]&amp;gt;=temp&amp;amp;&amp;amp;i&amp;lt;j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(i&amp;lt;j)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t=a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[i]=a[j];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        a[j]=t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a[left]=a[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a[i]=temp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  quicpSort(left,i-&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  quickSort(i+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="面试" scheme="https://zhangzhang18.github.io/myBlog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>synchronized关键字</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/10/01/synchronized/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/10/01/synchronized/</id>
    <published>2017-10-01T02:47:54.000Z</published>
    <updated>2019-01-21T07:41:29.966Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2017/10/01/synchronized/syn.jpg" alt="synchronized"><br>synchronized是一种同步锁<br>同一时刻只能有一个线程能获取到锁</p><ol><li>修饰代码块：同步代码块，作用域是{}里面的代码，作用的对象是调用这个代码块的对象。</li><li>修饰方法：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。</li><li>修饰静态的方法：作用范围是整个方法，作用对象是这个类的所有对象。</li><li>修饰类：作用范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。<a id="more"></a></li></ol><hr><p>1.<strong>synchronized 代码块</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">   synchronized(obj) &#123;</span><br><span class="line">   //一次只能有一个线程进入</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>synchronized锁住的是括号里的对象，不是代码。<br>当synchronized锁住一个对象时，别的线程也想拿到这个对象的锁，必须等待这个线程执行完释放锁，才能再次给这个对象加锁。</p><blockquote><p>example</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String lock=<span class="keyword">new</span> String();</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;<span class="comment">//1 synchronized (lock) 2//synchronized (SyncThread.class)3</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":a begin"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">":a   end"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//1,2,3</span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line"></span><br><span class="line">        SyncThread a = new SyncThread();</span><br><span class="line">        Thread t1 = new Thread(a);</span><br><span class="line">        Thread t2 = new Thread(a);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//3</span><br><span class="line">    public static void main(String[] arg)&#123;</span><br><span class="line"></span><br><span class="line">        SyncThread a = new SyncThread();</span><br><span class="line">        SyncThread b = new SyncThread();</span><br><span class="line">        Thread t1 = new Thread(a);</span><br><span class="line">        Thread t2 = new Thread(b);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>1,3输出</p><ul><li>t1—:a begin</li><li>t1—:a   end</li><li>t2—:a begin</li><li>t2—:a   end</li></ul><p>2输出</p><ul><li>t2—:a begin</li><li>t1—:a begin</li><li>t1—:a   end</li><li>t2—:a   end</li></ul><p>1是对类的当前实例加锁<br>2是对锁特定的实例加锁<br>3是对该类的所有对象都加了锁，该类所有的对象同一把锁。</p><p>1.<strong>synchronized 方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>example</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SyncThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"funA-"</span>+Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException ie)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">isSyncB</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"funB-"</span>+Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ie)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">cSync</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">while</span>( i-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"cSync"</span>+Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException ie)&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg)&#123;</span><br><span class="line">//4</span><br><span class="line">       SyncThread a = new SyncThread();</span><br><span class="line">       Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               a.isSyncA();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">       Thread t2 =new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               a.isSyncB();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出</p><ul><li>funA-t1 : 4</li><li>funA-t1 : 3</li><li>funA-t1 : 2</li><li>funA-t1 : 1</li><li>funA-t1 : 0</li><li>funB-t2 : 4</li><li>funB-t2 : 3</li><li>funB-t2 : 2</li><li>funB-t2 : 1</li><li>funB-t2 : 0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] arg)&#123;</span><br><span class="line"> //5</span><br><span class="line">       SyncThread a = new SyncThread();</span><br><span class="line">       Thread t1 = new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               SyncThread.cSync();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t1&quot;);</span><br><span class="line"></span><br><span class="line">       Thread t2 =new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               SyncThread.cSync();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,&quot;t2&quot;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>cSynct1 : 4</li><li>cSynct1 : 3</li><li>cSynct1 : 2</li><li>cSynct1 : 1</li><li>cSynct1 : 0</li><li>cSynct2 : 4</li><li>cSynct2 : 3</li><li>cSynct2 : 2</li><li>cSynct2 : 1</li><li>cSynct2 : 0</li></ul><p>4是对象锁<br>3,5得到的锁是类的锁</p><p>4是防止多线程同时访问这个对象的synchronized方法，（如果这个对象有多个synchronized方法，只要有一个线程访问了一个synchronized方法，其他的线程不能访问这个对象的任一synchronized方法），不同对象的synchronized方法互不影响。</p><p>5是防止多线程中不同实例对象同时访问方法，它对类的所有实例起作用。</p><hr><p>synchronized的实现原理 </p><p>1,synchronized代码块 monitorenter //进入同步方法 monitorexit //退出同步方法 2,synchronized方法 ACC_SYNCHRONIZED指明该方法为同步方法</p><p><a href="https://www.cnblogs.com/lixuwu/p/5676143.html" target="_blank" rel="noopener">参考</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2017/10/01/synchronized/syn.jpg&quot; alt=&quot;synchronized&quot;&gt;&lt;br&gt;synchronized是一种同步锁&lt;br&gt;同一时刻只能有一个线程能获取到锁&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修饰代码块：同步代码块，作用域是{}里面的代码，作用的对象是调用这个代码块的对象。&lt;/li&gt;
&lt;li&gt;修饰方法：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。&lt;/li&gt;
&lt;li&gt;修饰静态的方法：作用范围是整个方法，作用对象是这个类的所有对象。&lt;/li&gt;
&lt;li&gt;修饰类：作用范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Volatile关键字</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/08/01/volatile/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/08/01/volatile/</id>
    <published>2017-08-01T02:56:41.000Z</published>
    <updated>2019-10-11T09:58:34.933Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2017/08/01/volatile/vol.jpg" alt="volatile"></p><p><strong>Volatile 能够保证可见性。</strong></p><blockquote><p> volatile的两大特性：禁止重排序、内存可见性。</p></blockquote><pre><code>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。2）禁止进行指令重排序。</code></pre><a id="more"></a><p>并发编程中三大概念：<strong>原子性，有序性，可见性。</strong></p><hr><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>一个操作或者多个操作，要么全部执行并且执行过程中不会被任何一个因素打扰，要么就不会执行。<br>Java中，对于基本数据类型的变量读取和赋值操作是原子的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x=10;   //1</span><br><span class="line">y=x;    //2</span><br><span class="line">x++;    //3</span><br><span class="line">x=x+1;  //4</span><br></pre></td></tr></table></figure><p>只有1是原子的操作。</p><p>2是两个操作，先读取x的值，在把x的值写入工作内存，这两个操作都是原子操作，放在一起就不是原子操作了。</p><p>3和4都是先读取x的值，在进行加一的操作，写入新的值。</p><p>只有简单的读取、赋值（变量之间赋值不是）才是原子操作。</p><p>可以通过synchronized和Lock解决原子性问题。</p><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>线程之间的可见性，一个线程修改这个变量的值，其他的线程能够立即看到修改的值。</p><p>Java中，volatile关键字来保证可见性。<br>被volatile修饰的变量，变量修改的值会立即更新到主存，当其他线程需要读取的时候。就会读取主存的值。</p><p>普通变量被修改的时候，什么时候写入主存是不确定的。当其他线程读取的时候可能还是原来的值，因此无法保证可见性。</p><p>synchronized和Lock也能保证可见性，能够保证同一时刻只有一个线程获取锁，并且在释放锁之前会将变量修改刷新到主存中。</p><h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>程序执行的顺序按照代码先后执行。</p><p>指令重排序不会影响单个线程的执行，会影响到线程并发执行的正确性。</p><p>Java中允许编译器和处理器对指令进行重排序，volatile、synchronized和Lock都可以保证有序性，</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>1.状态标记量</p><h2 id="2-double-check"><a href="#2-double-check" class="headerlink" title="2.double check"></a>2.double check</h2><p>volatile实现原理</p><p>happen-before ：操作之间的内存可见性<br>– 如果一个操作的执行结果对另一个操作可见，那么这两个操作之间必须要存在<br>内存屏障<br>写之前StoreStore<br>写之后StoreLoad</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2017/08/01/volatile/vol.jpg&quot; alt=&quot;volatile&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Volatile 能够保证可见性。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; volatile的两大特性：禁止重排序、内存可见性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2）禁止进行指令重排序。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多线程" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集算法</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/07/20/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/07/20/垃圾收集算法/</id>
    <published>2017-07-20T15:46:25.000Z</published>
    <updated>2019-10-11T05:43:57.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1.标记-清除算法"></a>1.标记-清除算法</h2><p>最基础的收集算法。<br>分为两个阶段：标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。<br>不足：效率，空间，标记清除后会产生大量不连续的内存碎片。<br><a id="more"></a></p><h2 id="2-复制算法"><a href="#2-复制算法" class="headerlink" title="2.复制算法"></a>2.复制算法</h2><p>解决效率问题。<br>将可用的内存按容量分为大小相等的两块，每次只使用一块。当一块用完了，将还存活的对象复制到另一块，然后再把已使用过的内存空间一次清理掉。</p><h2 id="3-标记整理算法"><a href="#3-标记整理算法" class="headerlink" title="3.标记整理算法"></a>3.标记整理算法</h2><p>复制算法有较多复制操作，效率问题。<br>根据老年代的特点，标记过程与标记-清除算法一样，后续操作让所有存活对象都像一端移动，然后直接清理掉边界以外的内存。</p><h2 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4.分代收集算法"></a>4.分代收集算法</h2><p>在新生代中有大批对象死去，少量存活：复制算法。复制成本少。<br>老年代中对象存活率高，没有额外的空间对他进行担保：就必须使用 标记-清理 或 标记-整理 算法回收。</p><hr><p>一共有两种算法，一种是引用计数算法，每被引用一次计数器就+1，当引用为0就回收，不过这种算法有一个弊端就是，当对象之间互相引用的时候就永远不会回收，<br>所以用的最多的还是GC ROOTS可达性分析，看对象是否被GC ROOTS引用，那么哪些可以作为GC ROOTS呢？<br>有以下四种：1.栈里面的局部变量表，方法区的2.类静态属性引用的对象3.方法区中常量引用的对象，4.JNI本地变量栈中引用的对象<br><a href="http://www.importnew.com/13493.html" target="_blank" rel="noopener">http://www.importnew.com/13493.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-标记-清除算法&quot;&gt;&lt;a href=&quot;#1-标记-清除算法&quot; class=&quot;headerlink&quot; title=&quot;1.标记-清除算法&quot;&gt;&lt;/a&gt;1.标记-清除算法&lt;/h2&gt;&lt;p&gt;最基础的收集算法。&lt;br&gt;分为两个阶段：标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。&lt;br&gt;不足：效率，空间，标记清除后会产生大量不连续的内存碎片。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://zhangzhang18.github.io/myBlog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java类加载</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/07/16/JAVA-%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/07/16/JAVA-类加载/</id>
    <published>2017-07-16T08:49:44.000Z</published>
    <updated>2019-10-11T05:41:47.686Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2017/07/16/JAVA-类加载/load.jpg" alt="load"></p><p>Java虚拟机加载类的全过程包括，加载，验证，准备，解析和初始化。<br><a id="more"></a></p><ul><li>加载：根据路径找到对应的class文件，导入</li><li>验证：检验加载的class文件正确性</li><li>准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</li><li>解析：给符号引用转换为直接引用(解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。)</li><li>初始化：对静态变量和静态代码块执行初始化工作</li></ul><p>何时触发初始化</p><ol><li>为一个类型创建一个新的对象实例时（比如new、反射、序列化）</li><li>调用一个类型的静态方法时（即在字节码中执行invokestatic指令）</li><li>调用一个类型或接口的静态字段，或者对这些静态字段执行赋值操作时（即在字节码中，执行getstatic或者putstatic指令），不过用final修饰的静态字段除外，它被初始化为一个编译时常量表达式</li><li>调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法）</li><li>初始化一个类的派生类时（Java虚拟机规范明确要求初始化一个类时，它的超类必须提前完成初始化操作，接口例外）</li><li>JVM启动包含main方法的启动类时。</li></ol><p>类加载器：</p><ul><li>Bootstrap ClassLoader(启动类加载器):负责加载系统类(jre/lib/rt.jar)</li><li>Extension ClassLoader(扩展类加载器):负责加载扩展类(jre/lib/ext/*.jar)</li><li>Applicaiton ClassLoader(应用程序类加载器):用于加载自己定义编写的类(classpath指定目录或jar中类)</li><li>User ClassLoader （用户自己实现的加载器）</li></ul><p>“双亲委派模型”简单来说就是：</p><ol><li>先检查需要加载的类是否已经被加载，如果没有被加载，则委托父加载器加载，父类继续检查，尝试请父类加载，这个过程是从下——-&gt; 上;</li><li>如果走到顶层发现类没有被加载过，那么会从顶层开始往下逐层尝试加载，这个过程是从上 ——&gt; 下;</li></ol><p><img src="/myBlog/2017/07/16/JAVA-类加载/parents.jpg" alt="parents"><br><img src="/myBlog/2017/07/16/JAVA-类加载/parents1.jpg" alt="parents1"></p><p>JAVA热部署实现<br>首先谈一下何为热部署（hotswap），热部署是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为。Java 类是通过 Java 虚拟机加载的，某个类的 class 文件在被 classloader 加载后，会生成对应的 Class 对象，之后就可以创建该类的实例。默认的虚拟机行为只会在启动时加载类，如果后期有一个类需要更新的话，单纯替换编译的 class 文件，Java 虚拟机是不会更新正在运行的 class。如果要实现热部署，最根本的方式是修改虚拟机的源代码，改变 classloader 的加载行为，使虚拟机能监听 class 文件的更新，重新加载 class 文件，这样的行为破坏性很大，为后续的 JVM 升级埋下了一个大坑。</p><p>另一种友好的方法是创建自己的 classloader 来加载需要监听的 class，这样就能控制类加载的时机，从而实现热部署。 </p><p> 热部署步骤：</p><p>1、销毁自定义classloader(被该加载器加载的class也会自动卸载)；</p><p>2、更新class</p><p>3、使用新的ClassLoader去加载class </p><p>JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）：</p><ul><li>该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。</li><li>加载该类的ClassLoader已经被GC。</li><li>该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法</li></ul><p><a href="https://juejin.im/post/57c66f386be3ff005851de05" target="_blank" rel="noopener">https://juejin.im/post/57c66f386be3ff005851de05</a><br><a href="https://juejin.im/post/5a1fad585188252ae93ab953" target="_blank" rel="noopener">https://juejin.im/post/5a1fad585188252ae93ab953</a><br><a href="https://www.cnblogs.com/aspirant/p/7200523.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/7200523.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2017/07/16/JAVA-类加载/load.jpg&quot; alt=&quot;load&quot;&gt;&lt;/p&gt;
&lt;p&gt;Java虚拟机加载类的全过程包括，加载，验证，准备，解析和初始化。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://zhangzhang18.github.io/myBlog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存分配</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/07/13/JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/07/13/JVM内存分配/</id>
    <published>2017-07-13T12:46:25.000Z</published>
    <updated>2019-03-01T03:30:01.097Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/myBlog/2017/07/13/JVM内存分配/jvm.jpg" alt="jvm"></p><h1 id="线程私有的："><a href="#线程私有的：" class="headerlink" title="线程私有的："></a>线程私有的：</h1><blockquote><p> 程序计数器  虚拟机栈  本地方法栈</p></blockquote><p>线程共享的：</p><blockquote><p>  堆  方法区  直接内存<br><a id="more"></a></p></blockquote><h2 id="1-程序计数器（PCR）"><a href="#1-程序计数器（PCR）" class="headerlink" title="1.程序计数器（PCR）"></a>1.程序计数器（PCR）</h2><p>可以看做当前线程所执行的字节码的行号指示器。<br>为了线程切换后能够恢复到正确执行位置，每条线程都需要独立的程序计数器。</p><h2 id="2-栈（JVM-stack）"><a href="#2-栈（JVM-stack）" class="headerlink" title="2.栈（JVM stack）"></a>2.栈（JVM stack）</h2><p>线程私有，生命周期与线程相同。<br>描述的事Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接方法出口。<br>每个方法执行到完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><h2 id="3-本地方法栈（Native-Method-Stack）"><a href="#3-本地方法栈（Native-Method-Stack）" class="headerlink" title="3.本地方法栈（Native Method Stack）"></a>3.本地方法栈（Native Method Stack）</h2><p>与JVM栈相似，本地方法栈是用的是虚拟机的native方法</p><h2 id="4-堆（heap"><a href="#4-堆（heap" class="headerlink" title="4.堆（heap)"></a>4.堆（heap)</h2><p>是Java虚拟机管理内存中最大的一块。<br>是被所有线程共享的一块内存区域，次内存区域唯一目的是存放对象实例，几乎所有的对象及数组都要在这里分配内存。<br>是垃圾回收器管理的主要区域，因此很多时候也被称作“GC堆”。<br>现在收集器采用分代收集算法，所以Java堆还可以细分为：新生代，老年代；</p><h2 id="5-方法区（Method）"><a href="#5-方法区（Method）" class="headerlink" title="5.方法区（Method）"></a>5.方法区（Method）</h2><p>域Java堆一样。是各个线程共享的内存区域，<br>用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。</p><h2 id="6-运行时常量池（Runtime-Constant-Pool）"><a href="#6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="6.运行时常量池（Runtime Constant Pool）"></a>6.运行时常量池（Runtime Constant Pool）</h2><p>是方法区的一部分。<br>Class文件不仅有类的版本，字段，方法，接口描述信息外，还有一项信息是常量池，<br>用于存放编译期生成的各种字面量和符号引用。</p><h2 id="7-直接内存（Direct-Memory）"><a href="#7-直接内存（Direct-Memory）" class="headerlink" title="7.直接内存（Direct Memory）"></a>7.直接内存（Direct Memory）</h2><p>不是虚拟机运行数据区的一部分。<br>NIO（New Input/Output）类，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存。通过一个Java堆DirectByteBuffer对象作为这块内存的引用进行操作。<br>显著提高性能，因为避免了Java堆和Native堆来回复制数据。</p><hr><p>栈区：每次方法的执行都会有一次栈帧的生成，并且其中有局部变量表。<br>堆区：每次new出来的对象都保存在这儿。<br>本地方法栈：通过C/C++调用系统接口的一些方法。<br>方法区：类的信息 静态变量都在这儿，还有程序计数器</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/myBlog/2017/07/13/JVM内存分配/jvm.jpg&quot; alt=&quot;jvm&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;线程私有的：&quot;&gt;&lt;a href=&quot;#线程私有的：&quot; class=&quot;headerlink&quot; title=&quot;线程私有的：&quot;&gt;&lt;/a&gt;线程私有的：&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 程序计数器  虚拟机栈  本地方法栈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线程共享的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  堆  方法区  直接内存&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="JVM" scheme="https://zhangzhang18.github.io/myBlog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>HashMap归纳总结</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/05/12/HashMap%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/05/12/HashMap归纳总结/</id>
    <published>2017-05-12T13:49:01.000Z</published>
    <updated>2019-07-31T05:23:44.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结ArrayList和LinkedList"><a href="#总结ArrayList和LinkedList" class="headerlink" title="总结ArrayList和LinkedList"></a>总结ArrayList和LinkedList</h2><p>HashMap<br><img src="/myBlog/2017/05/12/HashMap归纳总结/hashMap.jpg" alt="hashMap"></p><a id="more"></a><hr><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ol><li><strong>了解HashMap吗？</strong></li></ol><blockquote><ul><li>HashMap是一种键值对（Key-Value）形式的存储结构。</li><li>key和value都允许为null。</li><li>当key重复的时候会覆盖，value允许重复。</li><li>是无序的，不会按照put的顺序排序。</li><li>是非线程安全的。</li><li>HashMap的Entry是一个单向链表</li><li>默认初始长度是16</li></ul></blockquote><p><img src="/myBlog/2017/05/12/HashMap归纳总结/base.jpg" alt="base"></p><ol start="2"><li><strong>知道HashMap的工作原理吗？</strong></li></ol><blockquote><ul><li>内部是一个数组，数组元素Node是实现了Map.Entry(hash,key,value,next)，next非null的时候指向定位相同的另一个Entry。</li><li>使用put()传递键和值，先对键调用hashCode()方法，通过hashCode确定bucket位置存储Entry对象。当发生碰撞的时候，使用<strong>散列法</strong>处理碰撞节点，将旧的Entry的引用赋值给新的Entry的next上，就是一个链表，冲突的节点从<strong>链表头部插入</strong>，这样插入新的Entry就不需要遍历链表。</li><li>通过get()获取对象。</li></ul></blockquote><ol start="3"><li><strong>当两个对象的hashCode相同的时候，怎么获取值对象？</strong></li></ol><blockquote><ul><li>get方法先比较hashCode值，如果hashCode相等，就是用equal()方法比较。</li><li>== 号与equals()方法的区别:== 基本数据类型比较的是值，对象比较的是对象的地址值。<br>equals()继承自Object类。在所有没有重写equals()方法的类中，equals()内部是==，也是比较的地址值。然而，Java提供的所有类中，绝大多数类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值</li></ul></blockquote><ol start="4"><li><strong>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</strong></li></ol><blockquote><p>默认的负载因子大小为<strong>0.75</strong>，初始容量是16，,也就是说，当一个map填满了<strong>75%</strong>的bucket时候，就会发生resize。简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。</p></blockquote><ol start="5"><li><strong>重新调整HashMap大小存在什么问题？</strong></li></ol><blockquote><p>在多线程的情况下，整个HashMap中的元素都需要重新算一遍。rehash，成本非常大。<br>链表中节点的转移可能会出现死循环的情况。</p></blockquote><ol start="6"><li><strong>HashMap与HashTable的区别：</strong></li></ol><blockquote><ul><li>HashTable不接受为null的键值(key)和值(value)</li><li>Hashtable是线程安全的也是synchronized在单线程环境下它比HashMap要慢。</li></ul></blockquote><ol start="7"><li><strong>HashMap同步？</strong></li></ol><blockquote><p>Map m = Collections.synchronizeMap(hashMap);</p></blockquote><ol start="8"><li>高并发下的HashMap</li></ol><p>Rehash是HashMap在扩容时的一个步骤，HashMap的容量是有限的。使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。<br>这时候，HashMap需要扩展它的长度，也就是进行Resize。</p><p>Resize的条件是:HashMap.Size &gt;= Capacity * LoadFactor。</p><p>Resize要经过两个过程：扩容和ReHash</p><ol><li><p>扩容：创建一个新的Entry空数组，长度是原数组的2倍。</p></li><li><p>ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。为什么要重新Hash呢？因为长度扩大以后，Hash的规则也随之改变。</p></li></ol><p>Hash公式：index = HashCode（Key） &amp; （Length - 1）</p><p><img src="/myBlog/2017/05/12/HashMap归纳总结/ConcurrentHashMap.png" alt="ConcurrentHashMap"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/myBlog/2017/05/12/HashMap归纳总结/HashMap.jpg" alt="HashMap"></h2><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><blockquote><p>需要线程安全，那么就使用ConcurrentHashMap。</p></blockquote><p>HashTable是使用synchronized来锁住整张Hash表来实现线程安全。</p><p>一个 ConcurrentHashMap 由一个个 Segment 组成，Segment代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。<br>Segment 内部是由 数组+链表 组成的。<br>(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)<br><img src="/myBlog/2017/05/12/HashMap归纳总结/ConcurrentHashMap.jpg" alt="ConcurrentHashMap"></p><blockquote><p>（1）ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢</p><p>（2）LinkedList以链表形式实现，顺序插入、查找较慢，插入、删除方便</p></blockquote><p><a href="https://mp.weixin.qq.com/s/SyKckwLfV2ypJOzTFA7R_g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SyKckwLfV2ypJOzTFA7R_g</a></p><p><a href="https://mp.weixin.qq.com/s/__ZnkPAF6ucUqN8CVSVQeA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/__ZnkPAF6ucUqN8CVSVQeA</a></p><p><a href="https://juejin.im/post/5a224e1551882535c56cb940" target="_blank" rel="noopener">https://juejin.im/post/5a224e1551882535c56cb940</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;总结ArrayList和LinkedList&quot;&gt;&lt;a href=&quot;#总结ArrayList和LinkedList&quot; class=&quot;headerlink&quot; title=&quot;总结ArrayList和LinkedList&quot;&gt;&lt;/a&gt;总结ArrayList和LinkedList&lt;/h2&gt;&lt;p&gt;HashMap&lt;br&gt;&lt;img src=&quot;/myBlog/2017/05/12/HashMap归纳总结/hashMap.jpg&quot; alt=&quot;hashMap&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="基础" scheme="https://zhangzhang18.github.io/myBlog/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="https://zhangzhang18.github.io/myBlog/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>准备面试基础</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/03/01/%E9%9D%A2%E7%BB%8F%E5%9F%BA%E7%A1%80/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/03/01/面经基础/</id>
    <published>2017-03-01T03:14:08.000Z</published>
    <updated>2019-10-11T10:55:03.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java内存区域-各个模块的作用"><a href="#java内存区域-各个模块的作用" class="headerlink" title="java内存区域, 各个模块的作用"></a>java内存区域, 各个模块的作用</h3><pre><code>线程共享：堆，方法区，直接内存  线程私有的：程序计数器，虚拟机栈，本地方法栈  程序计数器：记录线程执行的位置行数，为了线程切换后能恢复正确的执行位置  虚拟机栈：存储局部变量表，常量池的引用，方法的出口等，一个方法的执行意味着一个栈帧入栈出栈的过程  本地方法栈：与栈类似，它用的是虚拟机的native方法为保证线程中局部变量不被其他线程访问到，所以虚拟机栈和本地方法栈是线程私有的堆：是java虚拟机管理内存最大的一块，存储实例对象和数组，是垃圾回收管理主要区域  方法区：存储类信息，常量和静态变量，接口，变量，方法名等描述信息  </code></pre><a id="more"></a>    <h6 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h6><pre><code>1.引用计数法      给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。        不能解决项目引用的问题。    2.可达性分析法     利用JVM对象引用图，从根节点遍历对象应用图，同时标记遍历到的对象。遍历结束后未被标记的对象就是不在使用的对象了       可作为GC Roots的对象包括下面几种:         虚拟机栈(栈帧中的本地变量表)中引用的对象。          方法区中类静态属性引用的对象。         方法区中常量引用的对象。         本地方法栈中JNI(即一般说的Native方法)引用的对象。      1.标记-清除算法          算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。      它是最基础的收集算法，效率也很高，但是会带来两个明显的问题： 效率问题 空间问题（标记清除后会产生大量不连续的碎片）      2.复制算法        它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。3.标记-整理算法          根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。4.分代收集算法         根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</code></pre><h6 id="堆溢出-栈溢出举例-内存溢出与泄漏的区别并举例"><a href="#堆溢出-栈溢出举例-内存溢出与泄漏的区别并举例" class="headerlink" title="堆溢出,栈溢出举例, 内存溢出与泄漏的区别并举例"></a>堆溢出,栈溢出举例, 内存溢出与泄漏的区别并举例</h6><pre><code>堆OutOfMemoryError(Java heap space)：堆中主要存储的是对象。如果不断的new对象则会导致堆中的空间溢出 -Xms 去调整堆的大小  栈StackOverflowError：创建的栈帧超过了栈的深度，**死循环或递归调用**，-Xss 去调整栈的大小  内存泄露memory leak：1.在堆中申请的空间没有被释放，2。对象已经不在使用还在内存中保留   -Xms10M -Xmx10M控制           原因：1.静态集合类 2.各种连接不显示的close 3.监听器没有删除 4.变量不合理的作用域     内存溢出OutOfMemory：新建对象，对象所需要的内存大于堆剩余空间   -调大-Xmx          原因：代码中存在死循环或循环产生过多重复的对象实体              内存中加载的数据量过于庞大，如一次从数据库取出过多数据         </code></pre><h6 id="双亲委派模型-java类加载过程-每个过程做了什么"><a href="#双亲委派模型-java类加载过程-每个过程做了什么" class="headerlink" title="双亲委派模型, java类加载过程,每个过程做了什么"></a>双亲委派模型, java类加载过程,每个过程做了什么</h6><pre><code>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化  加载：找到class文件导入  验证：验证class文件正确性  准备：为类变量（静态变量）分配内存和设置初始值，（在方法区分配内存）`public static int value=123;`  解析：给符号引用转变为直接引用  初始化：对静态变量和静态代码块执行初始化工作双亲委派模型工作过程是：如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。只有当父加载器在自己的搜索范围内找不到指定的类时，子加载器才会尝试自己去加载。     启动类加载器(Bootstrap ClassLoader)-&gt;扩展类加载器(Extension ClassLoader)-&gt;应用程序类加载器(Application ClassLoader)-&gt;自定义classLoader</code></pre><h6 id="java中的锁-乐观锁-悲观锁-自旋锁等等"><a href="#java中的锁-乐观锁-悲观锁-自旋锁等等" class="headerlink" title="java中的锁, 乐观锁,悲观锁, 自旋锁等等"></a>java中的锁, 乐观锁,悲观锁, 自旋锁等等</h6><pre><code>乐观锁：读取数据时不加锁，在更新操作的时候才对冲突检测  悲观锁：操作数据的时候就上锁，所以整个处理过程数据都是被锁住的，synchronized就是悲观锁自旋锁：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。可重入锁:又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。 ReentrantLock  Synchronized  独享锁:是指该锁一次只能被一个线程所持有。    ReentrantLock Synchronized共享锁:是指该锁可被多个线程所持有。     ReadWriteLock，其读锁是共享锁，其写锁是独享锁分段锁:其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作https://www.cnblogs.com/lxmyhappy/p/7380073.html</code></pre><h6 id="ReentrantLock与synchronized"><a href="#ReentrantLock与synchronized" class="headerlink" title="ReentrantLock与synchronized"></a>ReentrantLock与synchronized</h6><pre><code>都是可重入锁    ReentrantLock是JDK实现的，synchronized是基于JVM实现的synchronized由编译器加锁和释放锁，ReentrantLock需要手动ReentrantLock是公平锁，就是先等待的线程可以先获得锁ReentrantLock可以分组唤醒线程ReentrantLock提供中断等待锁的机制lock.lockInterruptibly()</code></pre><h6 id="volatile的作用-CAS的原理-在java中哪些地方有用到"><a href="#volatile的作用-CAS的原理-在java中哪些地方有用到" class="headerlink" title="volatile的作用, CAS的原理, 在java中哪些地方有用到"></a>volatile的作用, CAS的原理, 在java中哪些地方有用到</h6><pre><code>volatile：保证线程可见性，一个线程修改了变量值，对其他线程是立即可见的CAS(比较并交换) 解决原子性；操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。   如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。   CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”https://blog.csdn.net/v123411739/article/details/79561458</code></pre><h6 id="线程同步的方式"><a href="#线程同步的方式" class="headerlink" title="线程同步的方式"></a>线程同步的方式</h6><pre><code>https://www.cnblogs.com/XHJT/p/3897440.htmlvolatile synchronized ReentrantLock</code></pre><h6 id="ConcurrentHashMap的原理-是如何保证多线程安全的"><a href="#ConcurrentHashMap的原理-是如何保证多线程安全的" class="headerlink" title="ConcurrentHashMap的原理,是如何保证多线程安全的"></a>ConcurrentHashMap的原理,是如何保证多线程安全的</h6><pre><code>https://www.cnblogs.com/ITtangtang/p/3948786.html</code></pre><h6 id="多线程的应用，理解"><a href="#多线程的应用，理解" class="headerlink" title="多线程的应用，理解"></a>多线程的应用，理解</h6><pre><code>多个线程同时运行，减少线程上下文切换的时间利用多线程可以提高系统整体并发能力及性能Java的内存模式：是从主存读取变量，线程吧变量保存在本地内存（寄存器）中，不是直接从主存进行读写，               一个线程修改主存的变量值，另一起还在使用寄存器中拷贝的值，造成数据不一致  volatile变量–多线程间可见 （每次都从主存进行读取）   synchronized-一时刻只能有一个线程能获取到锁  原子性：Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。  同步异步：   举例同步，你喊我吃饭，如果听见了，就一起去吃饭，如果没听见，你就不停喊，知道我听见才一起去吃饭，   异步，你喊我吃饭，然后自己去吃饭，我听到消息可能立刻走也可能等下班才去吃饭。</code></pre><h6 id="java中的线程池-有哪些参数-每个参数的含义-如何创建线程池-项目中的线程池的作用"><a href="#java中的线程池-有哪些参数-每个参数的含义-如何创建线程池-项目中的线程池的作用" class="headerlink" title="java中的线程池, 有哪些参数,每个参数的含义, 如何创建线程池, 项目中的线程池的作用"></a>java中的线程池, 有哪些参数,每个参数的含义, 如何创建线程池, 项目中的线程池的作用</h6><p><code>ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue&lt;Runnable     workQueue)</code></p><pre><code>corePoolSize： 线程池启动后，在池中保持的线程的最小数量  maxinumPoolSize： 线程池中能容纳的最大线程数量  unit： keepAliveTime的时间单位，可以是纳秒，毫秒，秒，分钟等   keepAliveTime： 线程的最大生命周期 workQueue：  任务队列  threadFactory： 定义如何启动一个线程，可以设置线程的名称，并且可以确定是否是后台线程等。   handler： 拒绝任务处理器。由于超出线程数量和队列容量而对继续增加的任务进行处理的程序。  **首先创建一个线程池，然后根据任务的数量逐步将线程增大到corePoolSize，如果此时仍有任务增加，则放置到workQueue中**，直到workQueue爆满为止，然后继续增加池中的线程数量（增强处理能力），**最终达到maxinumPoolSize**。降低资源消耗：事先创建若干个线程放在容器中，当使用的时候不需要自行创建，使用完不是去销毁而是归还到容器，减少了线程创建和销毁的时间     提高响应速度：不需要等待线程创建    提高线程的可管理性：无限制的创建线程，不仅消耗资源还降低系统稳定性，线程池可以进行统一分配，监控    </code></pre><h6 id="LRU原理-LinkedHashMap是如何实现的-LinkedHashMap数据结构源码"><a href="#LRU原理-LinkedHashMap是如何实现的-LinkedHashMap数据结构源码" class="headerlink" title="LRU原理, LinkedHashMap是如何实现的, LinkedHashMap数据结构源码"></a>LRU原理, LinkedHashMap是如何实现的, LinkedHashMap数据结构源码</h6><h6 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h6><pre><code>https://blog.csdn.net/ls5718/article/details/51896159   互斥条件，不剥夺条件，请求等待条件，循环等待</code></pre><h6 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h6><pre><code>索引就是个目录，字典的目录，有了目录就能更快的定位为了方便我们查找，提高查询的效率。缺点：索引需要维护成本，索引文件是单独存在的，数据的增删改 会产生会索引的额外操作，可能会影响增删改的速度原理：没有索引就是遍历整张表去查找      把无序的数据变成有序的查询，把随机变成顺序          1、把创建了索引的列的内容进行排序          2、对排序结果生成倒排表          3、在倒排表内容上拼上数据地址链          4、在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据      使用树形索引，还有哈希索引它适合单条查询    </code></pre><h6 id="联合索引查询优化-什么情况会失效-a-b-c分别建索引失效情况"><a href="#联合索引查询优化-什么情况会失效-a-b-c分别建索引失效情况" class="headerlink" title="联合索引查询优化, 什么情况会失效, a,b,c分别建索引失效情况"></a>联合索引查询优化, 什么情况会失效, a,b,c分别建索引失效情况</h6><h6 id="mysql存储引擎的对比-为什么用B-树实现"><a href="#mysql存储引擎的对比-为什么用B-树实现" class="headerlink" title="mysql存储引擎的对比, 为什么用B+树实现"></a>mysql存储引擎的对比, 为什么用B+树实现</h6><h6 id="事物的隔离级别，事物的实际应用"><a href="#事物的隔离级别，事物的实际应用" class="headerlink" title="事物的隔离级别，事物的实际应用"></a>事物的隔离级别，事物的实际应用</h6><pre><code>1.脏读：指在一个事务处理过程里读取了另一个未提交的事务中的数据。   2.不可重复读：一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。    3.幻读：同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。幻读和不可重复读都是读取了另一条已经提交的事务</code></pre><p>  <code>@Transactional(value = &quot;transactionManager&quot;, propagation = Propagation.REQUIRED,isolation = Isolation.READ_COMMITTED)</code></p><pre><code>隔离级别是指若干个并发的事务之间的隔离程度DEFAULT :默认的，     READ_UNCOMMITTED：读未提交，这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用     READ_COMMITED：读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读     REPEATABLE_READ：重复读取，明确数据读取出来就是为了更新用的，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决    SERLALIZABLE：串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题    </code></pre><h6 id="HAVING-用法，join用法"><a href="#HAVING-用法，join用法" class="headerlink" title="HAVING 用法，join用法"></a>HAVING 用法，join用法</h6><pre><code>WHERE 子句用来筛选 FROM 子句中指定的操作所产生的行。 GROUP BY 子句用来分组 WHERE 子句的输出。  HAVING 子句用来从分组的结果中筛选行。 HAVING 语法与 WHERE 语法类似，但 HAVING 可以包含聚合函数。 JOIN（inner join） 只有两个表格都满足条件，才会列出 LEFT JOIN 关键字会从左表那里返回所有的行，即使在右表中没有匹配的行。(RIGHT JOIN同理)</code></pre><h6 id="TCP可靠传输"><a href="#TCP可靠传输" class="headerlink" title="TCP可靠传输"></a>TCP可靠传输</h6><pre><code>确认应答（三次四次）,超时重传，流量控制，拥塞控制校验和：TCP将保持它首部和数据的检验和。</code></pre><p>######　解决幂等性问题</p><pre><code>幂等性：其任意多次执行对资源本身所产生的影响均与一次执行的影响相同，比如支付，下单。处理方式：每个请求有唯一标识，订单支付请求，订单id            处理完请求后，用一个纪录标识这个请求处理过了，常见方案是在数据库中记录状态             每次接受请求进行判断，比如订单已支付，数据库存在数据就不在处理了         redis请求加锁 乐观悲观锁</code></pre><p>######　表单的重复提交</p><pre><code>在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token，表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致，如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交，处理完后清除当前用户的Session域中存储的标识号。              </code></pre><p>######　过滤器拦截器应用，区别</p><pre><code>filter-&gt;servlet-&gt;intercept-&gt;controller过滤器：Filter是实现了javax.servlet.Filter接口的服务器端程序过滤器用途：设置字符集，控制权限，过滤掉非法url，拦截器： SpringMVC 中的Interceptor 拦截请求是通过HandlerInterceptor 来实现的拦截器用途：权限检查，如登录检查 创建一个Filter只需两个步骤    创建Filter处理类    web.xml文件中配置Filter 当web应用重新启动或销毁时，Filter也被销毁  void init(FilterConfig config):用于完成Filter的初始化。 void destory():用于Filter销毁前，完成某些资源的回收。 void doFilter(ServletRequest request,ServletResponse response,FilterChain chain):实现过滤功能拦截器实现 preHandle (HttpServletRequest request, HttpServletResponse response, Object handle) 方法，该方法将在请求处理之前进行调用。当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会再执行； postHandle (HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView) 方法，就是在当前请求进行处理之后，也就是Controller 方法调用之后执行 afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex) 方法，该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图之后执行。这个方法的主要作用是用于进行资源清理工作的。 过滤器和拦截器的区别： 　　①拦截器是基于java的反射机制的，而过滤器是基于函数回调。 　　②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。 　　③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。 　　④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。 　　⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。 　　⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。 原文：https://blog.csdn.net/chenleixing/article/details/44573495 </code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java内存区域-各个模块的作用&quot;&gt;&lt;a href=&quot;#java内存区域-各个模块的作用&quot; class=&quot;headerlink&quot; title=&quot;java内存区域, 各个模块的作用&quot;&gt;&lt;/a&gt;java内存区域, 各个模块的作用&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;线程共享：堆，方法区，直接内存  
线程私有的：程序计数器，虚拟机栈，本地方法栈  

程序计数器：记录线程执行的位置行数，为了线程切换后能恢复正确的执行位置  
虚拟机栈：存储局部变量表，常量池的引用，方法的出口等，一个方法的执行意味着一个栈帧入栈出栈的过程  
本地方法栈：与栈类似，它用的是虚拟机的native方法
为保证线程中局部变量不被其他线程访问到，所以虚拟机栈和本地方法栈是线程私有的
堆：是java虚拟机管理内存最大的一块，存储实例对象和数组，是垃圾回收管理主要区域  
方法区：存储类信息，常量和静态变量，接口，变量，方法名等描述信息  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="面试" scheme="https://zhangzhang18.github.io/myBlog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>准备面试</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/03/01/%E9%9D%A2%E7%BB%8F%E5%8D%87%E7%BA%A7/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/03/01/面经升级/</id>
    <published>2017-03-01T03:14:08.000Z</published>
    <updated>2019-10-11T10:55:03.608Z</updated>
    
    <content type="html"><![CDATA[<h6 id="spring事务传播特性"><a href="#spring事务传播特性" class="headerlink" title="spring事务传播特性"></a>spring事务传播特性</h6><pre><code>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。   propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。    propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。    propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。     propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。    propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。     propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。     propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与propagation_required类似的操作 </code></pre><h6 id="了解Spring使用到的设计模式吗？"><a href="#了解Spring使用到的设计模式吗？" class="headerlink" title="了解Spring使用到的设计模式吗？"></a>了解Spring使用到的设计模式吗？</h6><h6 id="说说对MQ理解"><a href="#说说对MQ理解" class="headerlink" title="说说对MQ理解"></a>说说对MQ理解</h6><pre><code>https://github.com/doocs/advanced-java作用：解耦、消峰、异步、广播如果使用 MQ，A 系统产生一条数据，发送到 MQ 里面去，哪个系统需要数据自己去 MQ 里面消费。如果新系统需要数据，直接从 MQ 里消费即可；如果某个系统不需要这条数据了，就取消对 MQ 消息的消费即可。这样下来，A 系统压根儿不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。保证消息消费幂等性（重复消费问题）   1.写库时，先跟进主键确认是否已存在 2.redis的set 处理消息丢失问题 生产者   1.使用事物，如果失败就回滚，重试发送消息，成功便提交事务   2.开启confirm模式，持久化queue元数据，将消息持久化到磁盘，消息被持久化到磁盘，再通知生产者，</code></pre><h6 id="了解MQ-底层吗"><a href="#了解MQ-底层吗" class="headerlink" title="了解MQ 底层吗"></a>了解MQ 底层吗</h6><h6 id="为什么要用缓存"><a href="#为什么要用缓存" class="headerlink" title="为什么要用缓存"></a>为什么要用缓存</h6><pre><code>用缓存，主要有两个用途：高性能、高并发。高性能：就是说对于一些需要复杂操作耗时查出来的结果，且确定后面不怎么变化，但是有很多读请求，那么直接将查询出来的结果放在缓存中，后面直接读缓存就好。高并发：缓存是走内存的，内存天然就支撑高并发。</code></pre><h6 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h6><pre><code>缓存雪崩：缓存挂了，所有请求都打到数据库    缓存雪崩的事前事中事后的解决方案如下。     事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。     事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。     事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。缓存穿透：缓存中查不到，每次去数据库里查，也查不到。就会直接把数据库给打死    解决方式：从数据库中只要没查到，就写一个空值到缓存里去              然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。缓存击穿：就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。     解决方式：可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。</code></pre><h6 id="Redis-过期策略"><a href="#Redis-过期策略" class="headerlink" title="Redis 过期策略"></a>Redis 过期策略</h6><pre><code>1.定期删除+惰性删除。所谓定期删除，指的是 redis 默认是每隔 100ms 就随机抽取一些设置了过期时间的 key，检查其是否过期，如果过期就删除。惰性删除，获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西。2.走内存淘汰机制---在内存不足容纳新的数据的的时候    a).noeviction :    新写入数据报错    b).allkeys-lru：   在所有键中，删除最近最少使用的键    c).allkeys-random：在所有键中，随机删除某个键    d).volatile-lru：  在设置过期时间的键中，删除最近最少使用的键    e).volatile-random:在设置过期时间的键中，随机删除某个键    f).volatile-ttl：  在设置过期时间的键中，删除最早过期的键</code></pre><h6 id="Redis-主从架构-哨兵集群实现高可用"><a href="#Redis-主从架构-哨兵集群实现高可用" class="headerlink" title="Redis 主从架构 哨兵集群实现高可用"></a>Redis 主从架构 哨兵集群实现高可用</h6><pre><code>一:主从架构   一主多从： 主负责写，并且将数据复制到从节点，从节点负责读</code></pre><h6 id="mysql-读写分离"><a href="#mysql-读写分离" class="headerlink" title="mysql 读写分离"></a>mysql 读写分离</h6><pre><code>主库将变更写到binlog中，当从库连接到主库后，从库有一个IO线程，将主库的binlog日志copy到自己本地，执行binlog中的日志内容，写入relay log，就是在自己本地再执行一遍sql。从库同步主库的数据过程是串行化的，也就是主库并行的操作，在从库会串行执行。高并发场景下，从库数据就会比主库慢，有延时如果主库突然宕机，数据还没同步到从库时，MySql有两个机制半同步复制和并行复制1:主库写入binlog后，强制立即将数据同步到从库，从库写入relay log后，从库会返回ask给主库，主库接收至少一个从库的ask才会认为写操作完成。2：从库开启多个线程，并行取relay log中不同库的数据，并行重放不同库的日志。</code></pre><h6 id="高并发系统设计"><a href="#高并发系统设计" class="headerlink" title="高并发系统设计"></a>高并发系统设计</h6><pre><code>1.系统拆分 2.缓存 3.MQ 4.分库分表 5.读写分离 6.ElasticSearch</code></pre><h6 id="说说一次-rpc-请求的流程？"><a href="#说说一次-rpc-请求的流程？" class="headerlink" title="说说一次 rpc 请求的流程？"></a>说说一次 rpc 请求的流程？</h6><pre><code>第一步：provider 向注册中心去注册第二步：consumer 从注册中心订阅服务，注册中心会通知 consumer 注册好的服务第三步：consumer 调用 provider第四步：consumer 和 provider 都异步通知监控中心Dubbo 传输协议：Dubbo缺省协议采用单一长连接和NIO异步通讯，</code></pre><p>注册中心挂了可以继续通信吗？</p><pre><code>可以，因为刚开始初始化的时候，消费者会将提供者的地址等信息拉取到本地缓存，所以注册中心挂了可以继续通信。    </code></pre><h6 id="说说对zk的理解？"><a href="#说说对zk的理解？" class="headerlink" title="说说对zk的理解？"></a>说说对zk的理解？</h6><h3 id="注解的理解"><a href="#注解的理解" class="headerlink" title="注解的理解"></a>注解的理解</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;spring事务传播特性&quot;&gt;&lt;a href=&quot;#spring事务传播特性&quot; class=&quot;headerlink&quot; title=&quot;spring事务传播特性&quot;&gt;&lt;/a&gt;spring事务传播特性&lt;/h6&gt;&lt;pre&gt;&lt;code&gt;事务传播行为就是多个事务方法相互调用时，事务
      
    
    </summary>
    
    
      <category term="JAVA" scheme="https://zhangzhang18.github.io/myBlog/tags/JAVA/"/>
    
      <category term="面试" scheme="https://zhangzhang18.github.io/myBlog/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>常用Linux命令</title>
    <link href="https://zhangzhang18.github.io/myBlog/2017/01/16/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/"/>
    <id>https://zhangzhang18.github.io/myBlog/2017/01/16/常用Linux命令/</id>
    <published>2017-01-16T09:29:15.000Z</published>
    <updated>2019-10-11T09:58:34.923Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><p>ls　&ensp;&ensp;&ensp;&ensp;　        显示文件或目录</p><pre><code>-l           列出文件详细信息l(list)-a          列出当前目录下所有文件及目录，包括隐藏的a(all)</code></pre><p>mkdir  &ensp;&ensp;&ensp;&ensp;　       创建目录</p><pre><code>-p           创建目录，若无父目录，则创建p(parent)</code></pre><p>cd   &ensp;&ensp;&ensp;&ensp;　            切换目录</p><p>touch   &ensp;&ensp;&ensp;&ensp;　       创建空文件</p><p>echo   &ensp;&ensp;&ensp;&ensp;　         创建带有内容的文件。</p><p>cat    &ensp;&ensp;&ensp;&ensp;　          查看文件内容</p><p>cp     &ensp;&ensp;&ensp;&ensp;　           拷贝   cp [选项]… [-T] 源 目的</p><p>mv    &ensp;&ensp;&ensp;&ensp;　           移动或重命名</p><p>rm     &ensp;&ensp;&ensp;&ensp;　          删除文件</p><pre><code>-r            递归删除，可删除子目录及文件-f            强制删除</code></pre><p>find    &ensp;&ensp;&ensp;&ensp;　          在文件系统中搜索某文件</p><p>wc      &ensp;&ensp;&ensp;&ensp;　          统计文本中行数、字数、字符数</p><p>grep    &ensp;&ensp;&ensp;&ensp;　         在文本文件中查找某个字符串</p><p>rmdir    &ensp;&ensp;&ensp;&ensp;　       删除空目录</p><p>tree     &ensp;&ensp;&ensp;&ensp;　        树形结构显示目录，需要安装tree包</p><p>pwd      &ensp;&ensp;&ensp;&ensp;　        显示当前目录</p><p>ln      &ensp;&ensp;&ensp;&ensp;　            创建链接文件</p><p>more、less &ensp;&ensp;&ensp;&ensp;　 分页显示文本文件内容</p><p>head、tail   &ensp;&ensp;&ensp;&ensp;　 显示文件头、尾内容</p><p>ctrl+alt+F1 &ensp;&ensp;&ensp;&ensp;　 命令行全屏模式</p><p>##　打包压缩相关命令</p><p>gzip：</p><p>bzip2：</p><p>tar:                打包压缩</p><pre><code>-c              归档文件-x              压缩文件-z              gzip压缩文件-j              bzip2压缩文件-v              显示压缩或解压缩过程 v(view)-f              使用档名</code></pre><p>例：<br>tar -cvf /home/abc.tar /home/abc              只打包，不压缩</p><p>tar -zcvf /home/abc.tar.gz /home/abc        打包，并用gzip压缩</p><p>tar -jcvf /home/abc.tar.bz2 /home/abc      打包，并用bzip2压缩</p><p>当然，如果想解压缩，就直接替换上面的命令  tar -cvf  / tar -zcvf  / tar -jcvf 中的“c” 换成“x” 就可以了。</p><p>##　系统管理命令</p><p>stat    &ensp;&ensp;&ensp;&ensp;　          显示指定文件的详细信息，比ls更详细</p><p>who     &ensp;&ensp;&ensp;&ensp;　          显示在线登陆用户</p><p>whoami   &ensp;&ensp;&ensp;&ensp;　       显示当前操作用户</p><p>hostname  &ensp;&ensp;&ensp;&ensp;　    显示主机名</p><p>uname     &ensp;&ensp;&ensp;&ensp;　      显示系统信息</p><p>top     &ensp;&ensp;&ensp;&ensp;　           动态显示当前耗费资源最多进程信息</p><p>ps     &ensp;&ensp;&ensp;&ensp;　             显示瞬间进程状态 ps -aux</p><p>du    &ensp;&ensp;&ensp;&ensp;　              查看目录大小 du -h /home带有单位显示目录信息</p><p>df    &ensp;&ensp;&ensp;&ensp;　              查看磁盘大小 df -h 带有单位显示磁盘信息</p><p>ifconfig   &ensp;&ensp;&ensp;&ensp;　       查看网络情况</p><p>ping      &ensp;&ensp;&ensp;&ensp;　          测试网络连通</p><p>netstat    &ensp;&ensp;&ensp;&ensp;　      显示网络状态信息</p><p>man        &ensp;&ensp;&ensp;&ensp;　        命令不会用了，找男人  如：man ls</p><p>clear      &ensp;&ensp;&ensp;&ensp;　        清屏</p><p>alias     &ensp;&ensp;&ensp;&ensp;　          对命令重命名 如：alias showmeit=”ps -aux” ，另外解除使用unaliax showmeit</p><p>kill      &ensp;&ensp;&ensp;&ensp;　           杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;常用指令&quot;&gt;&lt;a href=&quot;#常用指令&quot; class=&quot;headerlink&quot; title=&quot;常用指令&quot;&gt;&lt;/a&gt;常用指令&lt;/h2&gt;&lt;p&gt;ls　&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;　        显示文件或目录&lt;
      
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="Linux" scheme="https://zhangzhang18.github.io/myBlog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>leetcode</title>
    <link href="https://zhangzhang18.github.io/myBlog/2016/10/15/leetcode/"/>
    <id>https://zhangzhang18.github.io/myBlog/2016/10/15/leetcode/</id>
    <published>2016-10-15T03:35:25.000Z</published>
    <updated>2019-10-11T10:55:51.950Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="NoteBook" scheme="https://zhangzhang18.github.io/myBlog/categories/NoteBook/"/>
    
    
      <category term="leetcode" scheme="https://zhangzhang18.github.io/myBlog/tags/leetcode/"/>
    
      <category term="算法" scheme="https://zhangzhang18.github.io/myBlog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
