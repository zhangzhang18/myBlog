<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AB测技术]]></title>
    <url>%2FmyBlog%2F2019%2F02%2F13%2FAB%E6%B5%8B%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[简单来说，就是为同一个目标制定两个方案（比如两个页面）]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ZooKeeper]]></title>
    <url>%2FmyBlog%2F2018%2F12%2F26%2FZooKeeper%2F</url>
    <content type="text"><![CDATA[分布式协调服务-可以在分布式系统中共享配置，协调锁资源，提供命名服务 Zookeeper的数据模型：像数据结构中的树，也像文件系统中的目录 Znode：包含数据，子节点引用，访问权限等。每个节点的数据最大不能超过1MB Zookeeper包含的基本操作 create：创建节点 delete：删除节点 exists：判断节点是否存在 getData：获得一个节点的数据 setData：设置一个节点的数据 getChildren：获取节点下的所有子节点 Zookeeper一致性 Zookeeper Service集群是一主多从结构，更新数据时，首先跟新到主节点，在同步从节点。读取数据的时候可以读取任意节点 Zookeeper应用场景： 分布式锁 服务注册与发现 共享配置和状态信息Zookeeper IBM小灰 什么是ZooKeeper？]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>ZK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch]]></title>
    <url>%2FmyBlog%2F2018%2F12%2F06%2FElasticsearch%2F</url>
    <content type="text"><![CDATA[https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/https://github.com/elasticsearch-cnelasticsearch权威指南翻译阮一峰ES入门面向文档在应用程序中对象很少只是一个简单的键和值的列表。通常，它们拥有更复杂的数据结构，可能包括日期、地理信息、其他对象或者数组等。 Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。这种理解数据的方式与以往完全不同，这也是Elasticsearch能够执行复杂的全文搜索的原因之一。 JSONElasticsearch 使用 JavaScript Object Notation 或者 JSON 作为文档的序列化格式。 Elasticsearch集群可以包含多个索引(indices)（数据库），每一个索引可以包含多个类型(types)（表），每一个类型包含多个文档(documents)（行），然后每个文档包含多个字段(Fields)（列）。 所以为了创建员工目录，我们将进行如下操作： 为每个员工的文档(document)建立索引，每个文档包含了相应员工的所有信息。 每个文档的类型为employee。 employee类型归属于索引megacorp。 megacorp索引存储在Elasticsearch集群中。 实际上这些都是很容易的（尽管看起来有许多步骤）。我们能通过一个命令执行完成的操作：PUT /megacorp/employee/11234567&#123; "first_name": "John", "last_name": "Smith", "age": 25, "about": "I love to go rock climbing", "interests": ["sports", "music"]&#125; 我们看到path:/megacorp/employee/1包含三部分信息：名字说明megacorp索引名employee类型名1这个员工的ID 我们通过HTTP方法GET来检索文档，同样的，我们可以使用DELETE方法删除文档，使用HEAD方法检查某文档是否存在。如果想更新已存在的文档，我们只需再PUT一次。 我们尝试一个最简单的搜索全部员工的请求： GET /megacorp/employee/_search 这种方法常被称作查询字符串(query string)搜索，因为我们像传递URL参数一样去传递查询语句： GET /megacorp/employee/_search?q=last_name:Smith 使用DSL语句查询DSL(Domain Specific Language特定领域语言)以JSON请求体的形式出现。我们可以这样表示之前关于“Smith”的查询: GET /megacorp/employee/_search1234567&#123; "query": &#123; "match": &#123; "last_name": "Smith" &#125; &#125;&#125; 这会返回与之前查询相同的结果。 更复杂的搜索 我们的语句将添加过滤器(filter),它使得我们高效率的执行一个结构化搜索： GET /megacorp/employee/_search123456789101112131415161718&#123; "query": &#123; "filtered": &#123; "filter": &#123; "range": &#123; "age": &#123; "gt": 30 //1 &#125; &#125; &#125;, "query": &#123; "match": &#123; "last_name": "smith"//2 &#125; &#125; &#125; &#125;&#125; 这部分查询属于区间过滤器(range filter),它用于查找所有年龄大于30岁的数据——gt为”greater than”的缩写。 这部分查询与之前的match语句(query)一致。 现在我们的搜索结果只显示了一个32岁且名字是“Jane Smith”的员工：全文搜索到目前为止搜索都很简单：搜索特定的名字，通过年龄筛选。让我们尝试一种更高级的搜索，全文搜索——一种传统数据库很难实现的功能。我们将会搜索所有喜欢“rock climbing”的员工： GET /megacorp/employee/_search1234567&#123; "query" : &#123; "match" : &#123; "about" : "rock climbing" &#125; &#125;&#125; 解释了Elasticsearch如何在各种文本字段中进行全文搜索，并且返回相关性最大的结果集。相关性(relevance)的概念在Elasticsearch中非常重要，而这个概念在传统关系型数据库中是不可想象的，因为传统数据库对记录的查询只有匹配或者不匹配。 短语搜索目前我们可以在字段中搜索单独的一个词，这挺好的，但是有时候你想要确切的匹配若干个单词或者短语(phrases)。例如我们想要查询同时包含”rock”和”climbing”（并且是相邻的）的员工记录。要做到这个，我们只要将match查询变更为match_phrase查询即可: GET /megacorp/employee/_search1234567&#123; "query": &#123; "match_phrase": &#123; "about": "rock climbing" &#125; &#125;&#125; 高亮我们的搜索很多应用喜欢从每个搜索结果中高亮(highlight)匹配到的关键字，这样用户可以知道为什么这些文档和查询相匹配。在Elasticsearch中高亮片段是非常容易的。让我们在之前的语句上增加highlight参数： GET /megacorp/employee/_search123456789101112&#123; "query": &#123; "match_phrase": &#123; "about": "rock climbing" &#125; &#125;, "highlight": &#123; "fields": &#123; "about": &#123;&#125; &#125; &#125;&#125; 当我们运行这个语句时，会命中与之前相同的结果，但是在返回结果中会有一个新的部分叫做highlight，这里包含了来自about字段中的文本，并且用来标识匹配到的单词。]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式锁]]></title>
    <url>%2FmyBlog%2F2018%2F11%2F10%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%2F</url>
    <content type="text"><![CDATA[什么是锁为了实现多个线程在同一时刻同一代码块只能有一个线程可执行，需要在某个地方做标记，这个标记必须满足所有的线程可见，标记不存在的时候设置标记，后续的线程发现已标记则等待拥有标记的线程结束，同步代码块取消标记后，在尝试设置标记，这个标记可以理解为锁。 什么是分布式锁单体单机部署的系统被演化成分布式集群系统后，系统可能会有多份并且部署在不同的机器上，这些资源已经不是在线程之间共享了，而是属于进程之间共享的资源。指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。分布式的 CAP 理论： 任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。 分布式锁要满足哪些要求呢 互斥性：在任意时刻，只有一个客户端能持有锁。 不会发生死锁：即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。 容错性：获取或释放锁的机制必须高可用且性能佳 解铃还须系铃人：加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。 分布式锁实现方式为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同一时间内只能被同一个线程执行。 基于数据库实现分布式锁；基于缓存（Redis等）实现分布式锁；基于Zookeeper实现分布式锁； 基于数据库思路：在数据库中创建一个表，表中包含方法名等字段，并在方法名字段上创建唯一索引，想要执行某个方法，就使用这个方法名向表中插入数据，成功插入则获取锁，执行完成后删除对应的行数据释放锁。 基于Redis1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Collections;import redis.clients.jedis.Jedis;import redis.clients.jedis.JedisPool;public class XttblogLock &#123; private static final String LOCK_SUCCESS = "OK"; private static final String SET_IF_NOT_EXIST = "NX"; private static final String SET_WITH_EXPIRE_TIME = "PX"; private static final Long RELEASE_SUCCESS = 1L; private static void validParam(JedisPool jedisPool, String lockKey, String requestId, int expireTime) &#123; if (null == jedisPool) &#123; throw new IllegalArgumentException("jedisPool obj is null"); &#125; if (null == lockKey || "".equals(lockKey)) &#123; throw new IllegalArgumentException("lock key is blank"); &#125; if (null == requestId || "".equals(requestId)) &#123; throw new IllegalArgumentException("requestId is blank"); &#125; if (expireTime &lt; 0) &#123; throw new IllegalArgumentException("expireTime is not allowed less zero"); &#125; &#125; public static boolean tryLock(JedisPool jedisPool, String lockKey, String requestId, int expireTime) &#123; validParam(jedisPool, lockKey, requestId, expireTime); Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime); if (LOCK_SUCCESS.equals(result)) &#123; return true; &#125; &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; if (null != jedis) &#123; jedis.close(); &#125; &#125; return false; &#125; public static boolean unLock(JedisPool jedisPool, String lockKey, String requestId) &#123; validParam(jedisPool, lockKey, requestId, 1); String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"; Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); Object result = jedis.eval(script, Collections.singletonList(lockKey),Collections.singletonList(requestId)); if (RELEASE_SUCCESS.equals(result)) &#123; return true; &#125; &#125; catch (Exception e) &#123; throw e; &#125; finally &#123; if (null != jedis) &#123; jedis.close(); &#125; &#125; return false; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.concurrent.TimeUnit;import org.redisson.Redisson;import org.redisson.core.RLock;import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class RedissonLockUtil &#123; private static final Logger logger = LoggerFactory.getLogger(RedissonLockUtil.class); private static Redisson redisson = RedissonManager.getRedisson(); private static final String LOCK_FLAG = "recruitlock_"; /** * 根据name对进行上锁操作，redissonLock 阻塞的，采用的机制发布/订阅 * @param key */ public static void lock(String key)&#123; String lockKey = LOCK_FLAG + key; RLock lock = redisson.getLock(lockKey); //lock提供带timeout参数，timeout结束强制解锁，防止死锁 ：1分钟 lock.lock(1, TimeUnit.MINUTES); logger.info("lock key:&#123;&#125;",lockKey); &#125; /** * 根据name对进行解锁操作 * @param key */ public static void unlock(String key)&#123; String lockKey = LOCK_FLAG + key; RLock lock = redisson.getLock(lockKey); if (lock.isHeldByCurrentThread()) &#123; lock.unlock(); logger.info("unlock , key:&#123;&#125;"+lockKey); &#125; &#125; /** * @param key * @param millisToWait 等待获取锁的时间--单位：秒 */ public static boolean tryLock(String key, long millisToWait) &#123; String lockKey = LOCK_FLAG + key; logger.info("get redis lock start , key:&#123;&#125;"+lockKey); RLock lock = redisson.getLock(lockKey); logger.info("get redis lock end , key:"+lockKey); try &#123; return lock.tryLock(millisToWait,5000, TimeUnit.MILLISECONDS); &#125; catch (Exception e) &#123; logger.error("try lock error,key is:&#123;&#125;", lockKey, e); &#125; logger.info("get redis lock false , key:"+lockKey); return false; &#125;&#125; 错误示例12345Long result = jedis.setnx(lockKey, requestId); if (result == 1) &#123; // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁 jedis.expire(lockKey, expireTime); &#125; https://www.cnblogs.com/seesun2012/p/9214653.html http://www.cnblogs.com/linjiqin/p/8003838.html https://www.xttblog.com/?p=3171]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dubbo]]></title>
    <url>%2FmyBlog%2F2018%2F10%2F15%2FDubbo%2F</url>
    <content type="text"><![CDATA[Dubbo 一般的mvc项目 包含 Controller、Servicei、ServiceImpl、dao三层使用doubbo我们可以把项目拆分：Controller 作为 “消费着” 一个项目ServiceImpl +dao 作为 “提供者” 一个项目 Service “接口” 可以作为一个项目 节点角色说明： * Provider: 暴露服务的服务提供方 * Consumer: 调用远程服务的服务消费方。 * Registry: 服务注册与发现的注册中心。 * Monitor: 统计服务的调用次调和调用时间的监控中心。 * Container: 服务运行容器。 调用关系说明： * 服务容器负责启动，加载，运行服务提供者。 * 服务提供者在启动时，向注册中心注册自己提供的服务。 *服务消费者在启动时，向注册中心订阅自己所需的服务。 * 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 * 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 * 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 用 Spring 配置声明暴露服务123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name="hello-world-app" /&gt; &lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt; &lt;dubbo:registry address="multicast://224.5.6.7:1234" /&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name="dubbo" port="20880" /&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface="com.alibaba.dubbo.demo.DemoService" ref="demoService" /&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;bean id="demoService" class="com.alibaba.dubbo.demo.provider.DemoServiceImpl" /&gt;&lt;/beans&gt; 加载Spring配置Provider.java12345678910import org.springframework.context.support.ClassPathXmlApplicationContext;public class Provider &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;"http://10.20.160.198/wiki/display/dubbo/provider.xml"&#125;); context.start(); System.in.read(); // 按任意键退出 &#125;&#125; 服务消费者通过Spring配置引用远程服务consumer.xml12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt;&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;&lt;dubbo:application name="consumer-of-helloworld-app" /&gt;&lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt;&lt;dubbo:registry address="multicast://224.5.6.7:1234" /&gt;&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;&lt;dubbo:reference id="demoService" interface="com.alibaba.dubbo.demo.DemoService" /&gt;&lt;/beans&gt; 加载Spring配置，并调用远程服务Consumer.java12345678910111213141516import org.springframework.context.support.ClassPathXmlApplicationContext;import com.alibaba.dubbo.demo.DemoService;public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;"http://10.20.160.198/wiki/display/dubbo/consumer.xml"&#125;); context.start(); DemoService demoService = (DemoService)context.getBean("demoService"); // 获取远程服务代理 String hello = demoService.sayHello("world"); // 执行远程方法 System.out.println( hello ); // 显示调用结果 &#125;&#125;]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis归纳]]></title>
    <url>%2FmyBlog%2F2018%2F08%2F18%2FRedis%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[Redis一个基于内存的高性能的key-value数据库。 数据结构：String字符串，Hash字典，List列表，Set集合，SortedSet有序集合。 使用Redis有哪些好处？ (1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) (2) 支持丰富数据类型，支持string，list，set，sorted set，hash (3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行 (4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除 2.为什么redis需要把所有数据放到内存中? Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。 如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。 3.Redis是单进程单线程的为什么也那么快？ Redis快的主要原因是： 完全基于内存 数据结构简单，对数据操作也简单 使用多路 I/O 复用模型 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗； 这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。 4.Redis锁的使用。 1234567891011121314151617181920212223242526272829private static Redisson redisson = RedissonManager.getRedisson(); private static final String LOCK_FLAG = &quot;mylock_&quot;; /** * 根据name对进行上锁操作，redissonLock 阻塞的，采用的机制发布/订阅 * @param key */ public static void lock(String key)&#123; String lockKey = LOCK_FLAG + key; RLock lock = redisson.getLock(lockKey); //lock提供带timeout参数，timeout结束强制解锁，防止死锁 ：1分钟 lock.lock(1, TimeUnit.MINUTES); logger.info(&quot;lock key:&#123;&#125;&quot;,lockKey); &#125; /** * 根据name对进行解锁操作 * @param key */ public static void unlock(String key)&#123; String lockKey = LOCK_FLAG + key; RLock lock = redisson.getLock(lockKey); //如果锁被当前线程持有，则释放 if(lock.isHeldByCurrentThread())&#123; lock.unlock(); logger.info(&quot;unlock key:&#123;&#125;&quot;,lockKey); &#125; &#125;]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring+Shiro+Redis实践]]></title>
    <url>%2FmyBlog%2F2018%2F08%2F08%2FSpring%2BShiro%2BRedis%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[Apache Shiro是Java的一个安全框架。使用Spring+Shiro+Redis完成登录注册，权限认证的功能。Subject本质上就是当前访问用户的抽象描述。所有 参考张开涛《跟我学Shiro教程》]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA-IO]]></title>
    <url>%2FmyBlog%2F2018%2F05%2F18%2FJAVA-IO%2F</url>
    <content type="text"><![CDATA[设计模式：装饰者模式 NIOSnailclimb Java NIO 概览 IO是面向流的，NIO是面向缓冲区的 IO流是阻塞的，NIO流是不阻塞的。 NIO有选择器，而IO没有。]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-事物]]></title>
    <url>%2FmyBlog%2F2018%2F03%2F16%2FSpring-%E4%BA%8B%E7%89%A9%2F</url>
    <content type="text"><![CDATA[原子性：要么全部执行成功，要么全部执行失败 一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏 隔离性：并发的食物是互相隔离的，一个事物执行不被其他事物影响 持久性：事物一旦提交，对数据库的改变是永久性的 脏读：指在一个事务处理过程里读取了另一个未提交的事务中的数据。 不可重复读：一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 幻读：同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。幻读和不可重复读都是读取了另一条已经提交的事务 MySQL数据库提供的四种隔离级别： ① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 ② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 ③ Read committed (读已提交)：可避免脏读的发生。 ④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。 spring事物配置事务隔离级别 隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量： TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。 TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。 TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。 TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。 TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。 事务传播行为 所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量： TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。 TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。 TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-AOP]]></title>
    <url>%2FmyBlog%2F2018%2F01%2F20%2FSpring-AOP%2F</url>
    <content type="text"><![CDATA[3.AOP面向切面编程 OOP面向对象编程的基本单位是类，AOP的基本单位是方法适用于具有横切逻辑的应用场景，例如性能检测、范文控制、事物管理、及日志管理 AOP希望将分散在各个业务逻辑代码中的相同代码通过横向切割的方式抽取到一个独立独立的模块中。 3.1概念和术语 Aspect(切面):切面通常是指一个类，是通知和切入点的结合 Join point(连接点):程序执行的某个特定位置，例如类初始化前，类初始化后，方法执行前，方法执行后，方法抛出异常时等，Spring只支持方法级别的连接点，即方法执行前，方法执行后，方法抛出异常时 Advice(增强):增强是织入到目标类连接点上的一段程序代码 Pointcut(切点):每个程序类都拥有多个连接点，如一个拥有两个方法的类，这两个方法都是连接点，即连接点是程序类中客观存在的事物 Introduction(引介):允许向现有的类添加新方法或属性 Target object(目标对象):增强逻辑的织入目标类 AOP proxy(代理):一个类被AOP织入增强后，就产出了一个结果类，它是融合了原类和增强逻辑的代理类 Weaving(织入):织入是将增强添加对目标类具体连接点上的过程AOP有三种织入的方式： a、编译期织入，这要求使用特殊的Java编译器。 b、类装载期织入，这要求使用特殊的类装载器。 c、动态代理织入，在运行期为目标类添加增强生成子类的方式。Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。3.1.1实现123456&lt;beans&gt; &lt;aop:aspectj-autoproxy poxy-target-class="true"/&gt; &lt;!-- 声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。--&gt; &lt;!--表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。--&gt; &lt;bean id = "testAspect" class="com.test.company.aop.TestAspect" /&gt;&lt;/beans&gt; 1234567891011121314151617181920212223242526//切面就是切点和通知的组合体@Aspectpublic class TestAspect &#123; /** * 切点 */ @Pointcut("execution(*com.test.company.service.Impl.TestImpl.insert(..))")//Pointcut 使用pointcut定义切点 private void insertPointcut()&#123; &#125; /** * 环绕通知 * @param pjp */ @Around("insertPointcut()") public Object insert(ProceedingJoinPoint pjp) throws Throwable&#123;&#125; /** * 前置通知 */ @Before("execution(*com.test.company.service.Impl.TestImpl.insert(..))")//execution(*insert(..)) 切点表达式“execution”为关键字，“*insert(..)”为操作参数 private void Before()&#123; &#125; /** * 后置通知 * returnVal,切点方法执行后的返回值 */ @AfterReturning(value="execution(*com.test.company.service.Impl.TestImpl.insert(..))",returning = "returnVal") private void AfterReturning(Object returnVal)&#123; &#125; &#125; 通知有5种类型如下： before 目标方法执行前执行，前置通知 after 目标方法执行后执行，后置通知 after returning 目标方法返回时执行 ，后置返回通知 after throwing 目标方法抛出异常时执行 异常通知 around 在目标函数执行中执行，可控制目标函数是否执行，环绕通知 3.1.2 相关Java基础知识 代理模式 为某对象提供一个代理，从而通过代理来访问这个对象。 代理模式有三种角色组成: 抽象角色(卖票)：接口 代理角色(车票代售点)：Proxy 真实角色(火车站)：实现 动态代理代理类在程序运行前就已经存在，那么这种代理方式被成为 静态代理 JDK动态代理 jdk动态代理是由java内部的反射机制来实现的 主要涉及java.lang.reflect 包中：Proxy和InvocationHandler 使用动态代理需要定义一个位于代理类与委托类之间的中介类,中介类需要实现InvocationHandler定义的横切逻辑，通过反射机制调用目标类的方法，动态的将横切逻辑和业务逻辑编织在一起，InvocationHandler接口只定义了一个invoke方法通过”Proxy”类提供的一个newProxyInstance方法用来创建一个对象的代理对象 https://zhuanlan.zhihu.com/p/25522841]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-IOC]]></title>
    <url>%2FmyBlog%2F2018%2F01%2F16%2FSpring-IOC%2F</url>
    <content type="text"><![CDATA[1.Spring框架简介Spring框架是基于Java平台的，它为开发Java应用提供了全方位的基础设施支持，并且它很好地处理了这些基础设施，所以你只需要关注你的应用本身即可。 Spring可以使用POJO（普通的Java对象，plain old java objects）创建应用，并且可以将企业服务非侵入式地应用到POJO。这项功能适用于Java SE编程模型以及全部或部分的Java EE。 2.Spring模块结构 2.1 IOC 控制反转 IoC也称为依赖注入（DI）是为了解决对象之间的耦合度过高的问题 钟表拥有多个独立的齿轮，这些齿轮相互啮合在一起，齿轮相互啮合在一起，协同工作，共同完成某项任务。如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。与软件系统中对象之间的耦合关系非常相似 软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”。 借助于“第三方”实现具有依赖关系的对象之间的解耦，这个“第三方”也就是IOC容器。 哪些方面的控制被反转了呢 获得依赖对象的过程被反转了 所谓依赖注入，就是由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。 所以，依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。 把依赖注入应用到软件系统中，再来描述一下这个过程： 对象A依赖于对象B,当对象 A需要用到对象B的时候，IOC容器就会立即创建一个对象B送给对象A。 IOC容器就是一个对象制造工厂，你需要什么，它会给你送去，你直接使用就行了，而再也不用去关心你所用的东西是如何制成的，也不用关心最后是怎么被销毁的，这一切全部由IOC容器包办。 2.1.1 相关Java基础知识IOC流程 反射：Java语言允许通过程序化的方式间接对class操作，Class文件由类加载器转载后，JVM形成一份描述Class结构的元信息，通过元信息对象可以获取到构造函数，属性和方法等。 通过这个元信息对象间接的调用Class对象的功能。 几个重要的反射类： ClassLoader，Class，Constructor，和Method ClassLoader：类装载器，把一个类装入到JVM。 需要经过： - 1.装载 - 2.链接 校验 准备 解析 - 3.初始化 2.1.2 IOC容器中转配Bean 1234 &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/views/" /&gt; &lt;property name="suffix" value=".jsp" /&gt;&lt;/bean&gt; Spring 支持两种依赖注入方式：属性注入和构造函数注入，还支持工厂方法注入方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class SpringBeanFactory &#123; private static BeanFactory beanFactory; private static Logger logger = LoggerFactory.getLogger(SpringBeanFactory.class); public static BeanFactory getBeanFactory() &#123; if (beanFactory == null) &#123; synchronized (BeanFactory.class) &#123; try &#123; String path = Config.getConfigFolder(); if (beanFactory == null) &#123; beanFactory = new FileSystemXmlApplicationContext("/" + path + "aplication-spring-dubbo.xml"); &#125; &#125; catch (Exception e) &#123; logger.error("初始化SpringDubbo Error", e); &#125; &#125; &#125; return beanFactory; &#125;&#125;``` 3. **自动装配 - autowire="自动装配类型"** - byName：根据名称自动匹配 - byType：根据类型自动匹配 - constructor：与byType类似，它只针对构造函数注入的 - autodetect：4. **bean作用域 - scope="作用域"** - singleton：在IOC容器中只存在一个实例，以单例的方式存在,默认值 - prototype：每次从容器调用Bean时，都返回一个新的实例 - request：每次HTTP请求都会创建一个新的Bean，只适用于WebApplicationContext环境 - session：同一个HTTP Session共享一个Bean，只适用于WebApplicationContext环境 - global-session：5. **基于注解定义Bean**@component可以替代下面三种注解，为了清晰化，建议使用特定的注解 - @Repository：DAO层实现类 - @Service：Service实现类 - @Controller：Service实现类扫描包以应用注解的Bean```xml&lt;context:component-scan base-package="com.test.company.*" /&gt; Spring使用@Autowired注解实现Bean依赖注入@Autowired默认按照byType匹配在容器中查找Bean若想希望找不到Bean也不报NoSuchBeanDefinitionException异常，可以使用@Autowired(require=false)@Qualifier注解可以限定Bean的名字 12@Qualifier(&quot;userDaop&quot;)private UserDao userDao; https://www.cnblogs.com/wang-meng/p/5597490.html]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类加载]]></title>
    <url>%2FmyBlog%2F2018%2F01%2F16%2FJAVA-%E7%B1%BB%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Java虚拟机加载类的全过程包括，加载，验证，准备，解析和初始化。 加载：根据路径找到对应的class文件，导入 验证：检验加载的class文件正确性 准备：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 解析：给符号引用转换为直接引用(解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。) 初始化：对静态变量和静态代码块执行初始化工作 何时触发初始化 为一个类型创建一个新的对象实例时（比如new、反射、序列化） 调用一个类型的静态方法时（即在字节码中执行invokestatic指令） 调用一个类型或接口的静态字段，或者对这些静态字段执行赋值操作时（即在字节码中，执行getstatic或者putstatic指令），不过用final修饰的静态字段除外，它被初始化为一个编译时常量表达式 调用JavaAPI中的反射方法时（比如调用java.lang.Class中的方法，或者java.lang.reflect包中其他类的方法） 初始化一个类的派生类时（Java虚拟机规范明确要求初始化一个类时，它的超类必须提前完成初始化操作，接口例外） JVM启动包含main方法的启动类时。 类加载器： Bootstrap ClassLoader(启动类加载器):负责加载系统类(jre/lib/rt.jar) Extension ClassLoader(扩展类加载器):负责加载扩展类(jre/lib/ext/*.jar) Applicaiton ClassLoader(应用程序类加载器):用于加载自己定义编写的类(classpath指定目录或jar中类) User ClassLoader （用户自己实现的加载器） “双亲委派模型”简单来说就是： 先检查需要加载的类是否已经被加载，如果没有被加载，则委托父加载器加载，父类继续检查，尝试请父类加载，这个过程是从下——-&gt; 上; 如果走到顶层发现类没有被加载过，那么会从顶层开始往下逐层尝试加载，这个过程是从上 ——&gt; 下; JAVA热部署实现首先谈一下何为热部署（hotswap），热部署是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为。Java 类是通过 Java 虚拟机加载的，某个类的 class 文件在被 classloader 加载后，会生成对应的 Class 对象，之后就可以创建该类的实例。默认的虚拟机行为只会在启动时加载类，如果后期有一个类需要更新的话，单纯替换编译的 class 文件，Java 虚拟机是不会更新正在运行的 class。如果要实现热部署，最根本的方式是修改虚拟机的源代码，改变 classloader 的加载行为，使虚拟机能监听 class 文件的更新，重新加载 class 文件，这样的行为破坏性很大，为后续的 JVM 升级埋下了一个大坑。 另一种友好的方法是创建自己的 classloader 来加载需要监听的 class，这样就能控制类加载的时机，从而实现热部署。 热部署步骤： 1、销毁自定义classloader(被该加载器加载的class也会自动卸载)； 2、更新class 3、使用新的ClassLoader去加载class JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）： 该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。 加载该类的ClassLoader已经被GC。 该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法 https://juejin.im/post/57c66f386be3ff005851de05https://juejin.im/post/5a1fad585188252ae93ab953https://www.cnblogs.com/aspirant/p/7200523.html]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试常用手写代码]]></title>
    <url>%2FmyBlog%2F2017%2F10%2F12%2F%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[快速排序123456789101112131415161718192021222324252627int a[10],n;void quickSort(int left,int right)&#123; int i,j,t,temp; if(left &gt;right)&#123; return; &#125; temp=a[left]; i=left; j=right; while(i!=j)&#123; while(a[j]&gt;=temp&amp;&amp;i&lt;j)&#123; j--; &#125; while(a[i]&gt;=temp&amp;&amp;i&lt;j)&#123; i++; &#125; if(i&lt;j)&#123; t=a[i]; a[i]=a[j]; a[j]=t; &#125; &#125; a[left]=a[i]; a[i]=temp; quicpSort(left,i-1); quickSort(i+1,right);&#125; 单例模式volatile 的一个语义禁止指令重排优化。在读取变量的时候直接从内存读取，保证所有线程看到的变量值都是相同的，synchronized关键字锁住类进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。 123456789101112131415public class Singleton &#123; private volatile static Singleton instance=null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; //检查实例，如果不存在，就进入同步代码块 if (instance==null)&#123;// 双重检测机制 synchronized(Singleton.class)&#123;//1 同步锁 if(instance==null)&#123;//2 双重检测机制 instance=new Singleton();//3 &#125; &#125; &#125; return instance; &#125;&#125; 1234567//enum JVM会组织反射获取枚举类的私有构造方法public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125; 判断链表是否有环123456789101112131415161718typedef struct node&#123; char data ; node * next ; &#125;Node; bool exitLoop(Node *head) &#123; Node *fast, *slow ; slow = fast = head ; while (slow != NULL &amp;&amp; fast -&gt; next != NULL) &#123; slow = slow -&gt; next ; fast = fast -&gt; next -&gt; next ; if (slow == fast) return true ; &#125; return false ; &#125; 单链表反转123456789101112public Node reverse(Node node) &#123; Node prev = null; Node now = node; while (now != null) &#123; Node next = now.next; now.next = prev; prev = now; now = next; &#125; return prev; &#125;]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized关键字]]></title>
    <url>%2FmyBlog%2F2017%2F10%2F01%2Fsynchronized%2F</url>
    <content type="text"><![CDATA[synchronized是一种同步锁同一时刻只能有一个线程能获取到锁 修饰代码块：同步代码块，作用域是{}里面的代码，作用的对象是调用这个代码块的对象。 修饰方法：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。 修饰静态的方法：作用范围是整个方法，作用对象是这个类的所有对象。 修饰类：作用范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。 1.synchronized 代码块12345public void run() &#123; synchronized(obj) &#123; //一次只能有一个线程进入 &#125;&#125; synchronized锁住的是括号里的对象，不是代码。当synchronized锁住一个对象时，别的线程也想拿到这个对象的锁，必须等待这个线程执行完释放锁，才能再次给这个对象加锁。 example 1234567891011121314151617181920212223public class SyncThread implements Runnable &#123; private static int count; public SyncThread() &#123; &#125; @Override public void run() &#123; try &#123; String lock=new String(); synchronized (this) &#123;//1 synchronized (lock) 2//synchronized (SyncThread.class)3 System.out.println(Thread.currentThread().getName()+":a begin"); Thread.sleep(500); System.out.println(Thread.currentThread().getName()+":a end"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789//1,2,3 public static void main(String[] arg)&#123; SyncThread a = new SyncThread(); Thread t1 = new Thread(a); Thread t2 = new Thread(a); t1.start(); t2.start(); &#125; 12345678910//3 public static void main(String[] arg)&#123; SyncThread a = new SyncThread(); SyncThread b = new SyncThread(); Thread t1 = new Thread(a); Thread t2 = new Thread(b); t1.start(); t2.start(); &#125; 1,3输出 t1—:a begin t1—:a end t2—:a begin t2—:a end 2输出 t2—:a begin t1—:a begin t1—:a end t2—:a end 1是对类的当前实例加锁2是对锁特定的实例加锁3是对该类的所有对象都加了锁，该类所有的对象同一把锁。 1.synchronized 方法123456public synchronized void syncAdd() &#123; //4&#125;public static synchronized void syncAdd() &#123; //5&#125; example 12345678910111213141516171819202122232425262728293031323334353637public class SyncThread &#123; public SyncThread() &#123; &#125; public synchronized void isSyncA() &#123; int i = 5; while( i-- &gt; 0)&#123; System.out.println("funA-"+Thread.currentThread().getName() + " : " + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ie)&#123; &#125; &#125; &#125; public synchronized void isSyncB()&#123; int i = 5; while( i-- &gt; 0)&#123; System.out.println("funB-"+Thread.currentThread().getName() + " : " + i); try &#123; Thread.sleep(500); &#125;catch (InterruptedException ie)&#123; &#125; &#125; &#125; public static synchronized void cSync()&#123; int i = 5; while( i-- &gt; 0) &#123; System.out.println("cSync"+Thread.currentThread().getName() + " : " + i); try&#123; Thread.sleep(500); &#125;catch (InterruptedException ie)&#123; &#125; &#125; &#125;&#125; main 1234567891011121314151617181920public static void main(String[] arg)&#123;//4 SyncThread a = new SyncThread(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; a.isSyncA(); &#125; &#125;,&quot;t1&quot;); Thread t2 =new Thread(new Runnable() &#123; @Override public void run() &#123; a.isSyncB(); &#125; &#125;,&quot;t2&quot;); t1.start(); t2.start(); &#125; 输出 funA-t1 : 4 funA-t1 : 3 funA-t1 : 2 funA-t1 : 1 funA-t1 : 0 funB-t2 : 4 funB-t2 : 3 funB-t2 : 2 funB-t2 : 1 funB-t2 : 0 1234567891011121314151617181920public static void main(String[] arg)&#123; //5 SyncThread a = new SyncThread(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; SyncThread.cSync(); &#125; &#125;,&quot;t1&quot;); Thread t2 =new Thread(new Runnable() &#123; @Override public void run() &#123; SyncThread.cSync(); &#125; &#125;,&quot;t2&quot;); t1.start(); t2.start(); &#125; cSynct1 : 4 cSynct1 : 3 cSynct1 : 2 cSynct1 : 1 cSynct1 : 0 cSynct2 : 4 cSynct2 : 3 cSynct2 : 2 cSynct2 : 1 cSynct2 : 0 4是对象锁3,5得到的锁是类的锁 4是防止多线程同时访问这个对象的synchronized方法，（如果这个对象有多个synchronized方法，只要有一个线程访问了一个synchronized方法，其他的线程不能访问这个对象的任一synchronized方法），不同对象的synchronized方法互不影响。 5是防止多线程中不同实例对象同时访问方法，它对类的所有实例起作用。 synchronized的实现原理 1,synchronized代码块 monitorenter //进入同步方法 monitorexit //退出同步方法 2,synchronized方法 ACC_SYNCHRONIZED指明该方法为同步方法 参考]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Volatile关键字]]></title>
    <url>%2FmyBlog%2F2017%2F08%2F01%2Fvolatile%2F</url>
    <content type="text"><![CDATA[Volatile 能够保证可见性。 volatile的两大特性：禁止重排序、内存可见性。 1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 2）禁止进行指令重排序。 并发编程中三大概念：原子性，有序性，可见性。 1.原子性一个操作或者多个操作，要么全部执行并且执行过程中不会被任何一个因素打扰，要么就不会执行。Java中，对于基本数据类型的变量读取和赋值操作是原子的。 1234x=10; //1y=x; //2x++; //3x=x+1; //4 只有1是原子的操作。 2是两个操作，先读取x的值，在把x的值写入工作内存，这两个操作都是原子操作，放在一起就不是原子操作了。 3和4都是先读取x的值，在进行加一的操作，写入新的值。 只有简单的读取、赋值（变量之间赋值不是）才是原子操作。 可以通过synchronized和Lock解决原子性问题。 2.可见性线程之间的可见性，一个线程修改这个变量的值，其他的线程能够立即看到修改的值。 Java中，volatile关键字来保证可见性。被volatile修饰的变量，变量修改的值会立即更新到主存，当其他线程需要读取的时候。就会读取主存的值。 普通变量被修改的时候，什么时候写入主存是不确定的。当其他线程读取的时候可能还是原来的值，因此无法保证可见性。 synchronized和Lock也能保证可见性，能够保证同一时刻只有一个线程获取锁，并且在释放锁之前会将变量修改刷新到主存中。 3.有序性程序执行的顺序按照代码先后执行。 指令重排序不会影响单个线程的执行，会影响到线程并发执行的正确性。 Java中允许编译器和处理器对指令进行重排序，volatile、synchronized和Lock都可以保证有序性， 应用场景1.状态标记量 2.double checkvolatile实现原理]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集算法]]></title>
    <url>%2FmyBlog%2F2017%2F07%2F20%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.标记-清除算法最基础的收集算法。分为两个阶段：标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。不足：效率，空间，标记清除后会产生大量不连续的内存碎片。 2.复制算法解决效率问题。将可用的内存按容量分为大小相等的两块，每次只使用一块。当一块用完了，将还存活的对象复制到另一块，然后再把已使用过的内存空间一次清理掉。 3.标记整理算法复制算法有较多复制操作，效率问题。根据老年代的特点，标记过程与标记-清除算法一样，后续操作让所有存活对象都像一端移动，然后直接清理掉边界以外的内存。 4.分代收集算法在新生代中有大批对象死去，少量存活：复制算法。复制成本少。老年代中对象存活率高，没有额外的空间对他进行担保：就必须使用 标记-清理 或 标记-整理 算法回收。 一共有两种算法，一种是引用计数算法，每被引用一次计数器就+1，当引用为0就回收，不过这种算法有一个弊端就是，当对象之间互相引用的时候就永远不会回收，所以用的最多的还是GC ROOTS可达性分析，看对象是否被GC ROOTS引用，那么哪些可以作为GC ROOTS呢？有以下四种：1.栈里面的局部变量表，方法区的2.类静态属性引用的对象3.方法区中常量引用的对象，4.JNI本地变量栈中引用的对象http://www.importnew.com/13493.html]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存分配]]></title>
    <url>%2FmyBlog%2F2017%2F07%2F13%2FJVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[线程私有的： 程序计数器 虚拟机栈 本地方法栈 线程共享的： 堆 方法区 直接内存 1.程序计数器（PCR）可以看做当前线程所执行的字节码的行号指示器。为了线程切换后能够恢复到正确执行位置，每条线程都需要独立的程序计数器。 2.栈（JVM stack）线程私有，生命周期与线程相同。描述的事Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接方法出口。每个方法执行到完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 3.本地方法栈（Native Method Stack）与JVM栈相似，本地方法栈是用的是虚拟机的native方法 4.堆（heap)是Java虚拟机管理内存中最大的一块。是被所有线程共享的一块内存区域，次内存区域唯一目的是存放对象实例，几乎所有的对象及数组都要在这里分配内存。是垃圾回收器管理的主要区域，因此很多时候也被称作“GC堆”。现在收集器采用分代收集算法，所以Java堆还可以细分为：新生代，老年代； 5.方法区（Method）域Java堆一样。是各个线程共享的内存区域，用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。 6.运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件不仅有类的版本，字段，方法，接口描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。 7.直接内存（Direct Memory）不是虚拟机运行数据区的一部分。NIO（New Input/Output）类，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存。通过一个Java堆DirectByteBuffer对象作为这块内存的引用进行操作。显著提高性能，因为避免了Java堆和Native堆来回复制数据。 栈区：每次方法的执行都会有一次栈帧的生成，并且其中有局部变量表。堆区：每次new出来的对象都保存在这儿。本地方法栈：通过C/C++调用系统接口的一些方法。方法区：类的信息 静态变量都在这儿，还有程序计数器]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap归纳总结]]></title>
    <url>%2FmyBlog%2F2017%2F05%2F12%2FHashMap%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结ArrayList和LinkedListHashMap （1）ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢 （2）LinkedList以链表形式实现，顺序插入、查找较慢，插入、删除方便 HashMap 了解HashMap吗？ HashMap是一种键值对（Key-Value）形式的存储结构。 key和value都允许为null。 当key重复的时候会覆盖，value允许重复。 是无序的，不会按照put的顺序排序。 是非线程安全的。 HashMap的Entry是一个单向链表 默认初始长度是16 知道HashMap的工作原理吗？ 内部是一个数组，数组元素Node是实现了Map.Entry(hash,key,value,next)，next非null的时候指向定位相同的另一个Entry。 使用put()传递键和值，先对键调用hashCode()方法，通过hashCode确定bucket位置存储Entry对象。当发生碰撞的时候，使用散列法处理碰撞节点，将旧的Entry的引用赋值给新的Entry的next上，就是一个链表，冲突的节点从链表头部插入，这样插入新的Entry就不需要遍历链表。 通过get()获取对象。 当两个对象的hashCode相同的时候，怎么获取值对象？ get方法先比较hashCode值，如果hashCode相等，就是用equal()方法比较。 == 号与equals()方法的区别:== 基本数据类型比较的是值，对象比较的是对象的地址值。equals()继承自Object类。在所有没有重写equals()方法的类中，equals()内部是==，也是比较的地址值。然而，Java提供的所有类中，绝大多数类都重写了equals()方法，重写后的equals()方法一般都是比较两个对象的值 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？ 默认的负载因子大小为0.75，初始容量是16，,也就是说，当一个map填满了75%的bucket时候，就会发生resize。简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。 重新调整HashMap大小存在什么问题？ 在多线程的情况下，整个HashMap中的元素都需要重新算一遍。rehash，成本非常大。链表中节点的转移可能会出现死循环的情况。 HashMap与HashTable的区别： HashTable不接受为null的键值(key)和值(value) Hashtable是线程安全的也是synchronized在单线程环境下它比HashMap要慢。 HashMap同步？ Map m = Collections.synchronizeMap(hashMap); 高并发下的HashMap Rehash是HashMap在扩容时的一个步骤 ConcurrentHashMap 需要线程安全，那么就使用ConcurrentHashMap。 HashTable是使用synchronized来锁住整张Hash表来实现线程安全。 一个 ConcurrentHashMap 由一个个 Segment 组成，Segment代表”部分“或”一段“的意思，所以很多地方都会将其描述为分段锁。Segment 内部是由 数组+链表 组成的。 https://mp.weixin.qq.com/s/SyKckwLfV2ypJOzTFA7R_g https://mp.weixin.qq.com/s/__ZnkPAF6ucUqN8CVSVQeA]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>基础</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Linux命令]]></title>
    <url>%2FmyBlog%2F2017%2F01%2F16%2F%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常用指令ls &ensp;&ensp;&ensp;&ensp; 显示文件或目录 -l 列出文件详细信息l(list) -a 列出当前目录下所有文件及目录，包括隐藏的a(all) mkdir &ensp;&ensp;&ensp;&ensp; 创建目录 -p 创建目录，若无父目录，则创建p(parent) cd &ensp;&ensp;&ensp;&ensp; 切换目录 touch &ensp;&ensp;&ensp;&ensp; 创建空文件 echo &ensp;&ensp;&ensp;&ensp; 创建带有内容的文件。 cat &ensp;&ensp;&ensp;&ensp; 查看文件内容 cp &ensp;&ensp;&ensp;&ensp; 拷贝 cp [选项]… [-T] 源 目的 mv &ensp;&ensp;&ensp;&ensp; 移动或重命名 rm &ensp;&ensp;&ensp;&ensp; 删除文件 -r 递归删除，可删除子目录及文件 -f 强制删除 find &ensp;&ensp;&ensp;&ensp; 在文件系统中搜索某文件 wc &ensp;&ensp;&ensp;&ensp; 统计文本中行数、字数、字符数 grep &ensp;&ensp;&ensp;&ensp; 在文本文件中查找某个字符串 rmdir &ensp;&ensp;&ensp;&ensp; 删除空目录 tree &ensp;&ensp;&ensp;&ensp; 树形结构显示目录，需要安装tree包 pwd &ensp;&ensp;&ensp;&ensp; 显示当前目录 ln &ensp;&ensp;&ensp;&ensp; 创建链接文件 more、less &ensp;&ensp;&ensp;&ensp; 分页显示文本文件内容 head、tail &ensp;&ensp;&ensp;&ensp; 显示文件头、尾内容 ctrl+alt+F1 &ensp;&ensp;&ensp;&ensp; 命令行全屏模式 ## 打包压缩相关命令 gzip： bzip2： tar: 打包压缩 -c 归档文件 -x 压缩文件 -z gzip压缩文件 -j bzip2压缩文件 -v 显示压缩或解压缩过程 v(view) -f 使用档名 例：tar -cvf /home/abc.tar /home/abc 只打包，不压缩 tar -zcvf /home/abc.tar.gz /home/abc 打包，并用gzip压缩 tar -jcvf /home/abc.tar.bz2 /home/abc 打包，并用bzip2压缩 当然，如果想解压缩，就直接替换上面的命令 tar -cvf / tar -zcvf / tar -jcvf 中的“c” 换成“x” 就可以了。 ## 系统管理命令 stat &ensp;&ensp;&ensp;&ensp; 显示指定文件的详细信息，比ls更详细 who &ensp;&ensp;&ensp;&ensp; 显示在线登陆用户 whoami &ensp;&ensp;&ensp;&ensp; 显示当前操作用户 hostname &ensp;&ensp;&ensp;&ensp; 显示主机名 uname &ensp;&ensp;&ensp;&ensp; 显示系统信息 top &ensp;&ensp;&ensp;&ensp; 动态显示当前耗费资源最多进程信息 ps &ensp;&ensp;&ensp;&ensp; 显示瞬间进程状态 ps -aux du &ensp;&ensp;&ensp;&ensp; 查看目录大小 du -h /home带有单位显示目录信息 df &ensp;&ensp;&ensp;&ensp; 查看磁盘大小 df -h 带有单位显示磁盘信息 ifconfig &ensp;&ensp;&ensp;&ensp; 查看网络情况 ping &ensp;&ensp;&ensp;&ensp; 测试网络连通 netstat &ensp;&ensp;&ensp;&ensp; 显示网络状态信息 man &ensp;&ensp;&ensp;&ensp; 命令不会用了，找男人 如：man ls clear &ensp;&ensp;&ensp;&ensp; 清屏 alias &ensp;&ensp;&ensp;&ensp; 对命令重命名 如：alias showmeit=”ps -aux” ，另外解除使用unaliax showmeit kill &ensp;&ensp;&ensp;&ensp; 杀死进程，可以先用ps 或 top命令查看进程的id，然后再用kill命令杀死进程。]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
