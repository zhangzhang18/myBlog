<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面试常用手写代码]]></title>
    <url>%2FmyBlog%2F2017%2F10%2F12%2F%E9%9D%A2%E8%AF%95%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[单例模式volatile 的一个语义禁止指令重排优化。synchronized关键字当两个线程同事进入第一的if判断语句后，线程1获取锁，线程2阻塞在1处，线程1 123456789101112131415161718192021public class Singleton &#123; private volatile static Singleton instance=null; private Singleton()&#123;&#125; public static Singleton getInstance()&#123; if (instance==null)&#123; synchronized(Singleton.class)&#123;//1 if(instance==null)&#123;//2 instance=new Singleton();//3 &#125; &#125; &#125; return instance; &#125;&#125;public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125;&#125;]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized关键字]]></title>
    <url>%2FmyBlog%2F2017%2F10%2F01%2Fsynchronized%2F</url>
    <content type="text"><![CDATA[synchronized是一种同步锁同一时刻只能有一个线程能获取到锁 修饰代码块：同步代码块，作用域是{}里面的代码，作用的对象是调用这个代码块的对象。 修饰方法：同步方法，作用范围是整个方法，作用对象是调用这个方法的对象。 修饰静态的方法：作用范围是整个方法，作用对象是这个类的所有对象。 修饰类：作用范围是synchronized后面括号括起来的部分，作用的对象是这个类的所有对象。 1.synchronized 代码块12345public void run() &#123; synchronized(obj) &#123; //一次只能有一个线程进入 &#125;&#125; synchronized锁住的是括号里的对象，不是代码。当synchronized锁住一个对象时，别的线程也想拿到这个对象的锁，必须等待这个线程执行完释放锁，才能再次给这个对象加锁。 example 1234567891011121314151617181920212223public class SyncThread implements Runnable &#123; private static int count; public SyncThread() &#123; &#125; @Override public void run() &#123; try &#123; String lock=new String(); synchronized (this) &#123;//1 synchronized (lock) 2//synchronized (SyncThread.class)3 System.out.println(Thread.currentThread().getName()+&quot;:a begin&quot;); Thread.sleep(500); System.out.println(Thread.currentThread().getName()+&quot;:a end&quot;); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789//1,2,3 public static void main(String[] arg)&#123; SyncThread a = new SyncThread(); Thread t1 = new Thread(a); Thread t2 = new Thread(a); t1.start(); t2.start(); &#125; 12345678910//3 public static void main(String[] arg)&#123; SyncThread a = new SyncThread(); SyncThread b = new SyncThread(); Thread t1 = new Thread(a); Thread t2 = new Thread(b); t1.start(); t2.start(); &#125; 1,3输出 t1—:a begin t1—:a end t2—:a begin t2—:a end 2输出 t2—:a begin t1—:a begin t1—:a end t2—:a end 1是对类的当前实例加锁2是对锁特定的实例加锁3是对该类的所有对象都加了锁，该类所有的对象同一把锁。 1.synchronized 方法123456public synchronized void syncAdd() &#123; //4&#125;public static synchronized void syncAdd() &#123; //5&#125; example 12345678910111213141516171819202122232425262728293031323334353637public class SyncThread &#123; public SyncThread() &#123; &#125; public synchronized void isSyncA() &#123; int i = 5; while( i-- &gt; 0)&#123; System.out.println(&quot;funA-&quot;+Thread.currentThread().getName() + &quot; : &quot; + i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException ie)&#123; &#125; &#125; &#125; public synchronized void isSyncB()&#123; int i = 5; while( i-- &gt; 0)&#123; System.out.println(&quot;funB-&quot;+Thread.currentThread().getName() + &quot; : &quot; + i); try &#123; Thread.sleep(500); &#125;catch (InterruptedException ie)&#123; &#125; &#125; &#125; public static synchronized void cSync()&#123; int i = 5; while( i-- &gt; 0) &#123; System.out.println(&quot;cSync&quot;+Thread.currentThread().getName() + &quot; : &quot; + i); try&#123; Thread.sleep(500); &#125;catch (InterruptedException ie)&#123; &#125; &#125; &#125;&#125; main 1234567891011121314151617181920public static void main(String[] arg)&#123;//4 SyncThread a = new SyncThread(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; a.isSyncA(); &#125; &#125;,&quot;t1&quot;); Thread t2 =new Thread(new Runnable() &#123; @Override public void run() &#123; a.isSyncB(); &#125; &#125;,&quot;t2&quot;); t1.start(); t2.start(); &#125; 输出 funA-t1 : 4 funA-t1 : 3 funA-t1 : 2 funA-t1 : 1 funA-t1 : 0 funB-t2 : 4 funB-t2 : 3 funB-t2 : 2 funB-t2 : 1 funB-t2 : 0 1234567891011121314151617181920public static void main(String[] arg)&#123; //5 SyncThread a = new SyncThread(); Thread t1 = new Thread(new Runnable() &#123; @Override public void run() &#123; SyncThread.cSync(); &#125; &#125;,&quot;t1&quot;); Thread t2 =new Thread(new Runnable() &#123; @Override public void run() &#123; SyncThread.cSync(); &#125; &#125;,&quot;t2&quot;); t1.start(); t2.start(); &#125; cSynct1 : 4 cSynct1 : 3 cSynct1 : 2 cSynct1 : 1 cSynct1 : 0 cSynct2 : 4 cSynct2 : 3 cSynct2 : 2 cSynct2 : 1 cSynct2 : 0 4是对象锁3,5得到的锁是类的锁 4是防止多线程同时访问这个对象的synchronized方法，（如果这个对象有多个synchronized方法，只要有一个线程访问了一个synchronized方法，其他的线程不能访问这个对象的任一synchronized方法），不同对象的synchronized方法互不影响。 5是防止多线程中不同实例对象同时访问方法，它对类的所有实例起作用。 synchronized的实现原理 1,synchronized代码块 monitorenter //进入同步方法 monitorexit //退出同步方法 2,synchronized方法 ACC_SYNCHRONIZED指明该方法为同步方法 参考]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Volatile关键字]]></title>
    <url>%2FmyBlog%2F2017%2F08%2F01%2FVolatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[Volatile 能够保证可见性。 volatile的两大特性：禁止重排序、内存可见性。 并发编程中三大概念：原子性，有序性，可见性。 1.原子性一个操作或者多个操作，要么全部执行并且执行过程中不会被任何一个因素打扰，要么就不会执行。Java中，对于基本数据类型的变量读取和赋值操作是原子的。 1234x=10; //1y=x; //2x++; //3x=x+1; //4 只有1是原子的操作。 2是两个操作，先读取x的值，在把x的值写入工作内存，这两个操作都是原子操作，放在一起就不是原子操作了。 3和4都是先读取x的值，在进行加一的操作，写入新的值。 只有简单的读取、赋值（变量之间赋值不是）才是原子操作。 可以通过synchronized和Lock解决原子性问题。 2.可见性线程之间的可见性，一个线程修改这个变量的值，其他的线程能够立即看到修改的值。 Java中，volatile关键字来保证可见性。被volatile修饰的变量，变量修改的值会立即更新到主存，当其他线程需要读取的时候。就会读取主存的值。 普通变量被修改的时候，什么时候写入主存是不确定的。当其他线程读取的时候可能还是原来的值，因此无法保证可见性。 synchronized和Lock也能保证可见性，能够保证同一时刻只有一个线程获取锁，并且在释放锁之前会将变量修改刷新到主存中。 3.有序性程序执行的顺序按照代码先后执行。 指令重排序不会影响单个线程的执行，会影响到线程并发执行的正确性。 Java中允许编译器和处理器对指令进行重排序，volatile、synchronized和Lock都可以保证有序性， volatile实现原理]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集算法]]></title>
    <url>%2FmyBlog%2F2017%2F07%2F20%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.标记-清除算法最基础的收集算法。分为两个阶段：标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。不足：效率，空间，标记清除后会产生大量不连续的内存碎片。 2.复制算法解决效率问题。将可用的内存按容量分为大小相等的两块，每次只使用一块。当一块用完了，将还存活的对象复制到另一块，然后再把已使用过的内存空间一次清理掉。 3.标记整理算法复制算法有较多复制操作，效率问题。根据老年代的特点，标记过程与标记-清除算法一样，后续操作让所有存活对象都像一端移动，然后直接清理掉边界以外的内存。 4.分代收集算法在新生代中有大批对象死去，少量存活：复制算法。复制成本少。老年代中对象存活率高，没有额外的空间对他进行担保：就必须使用 标记-清理 或 标记-整理 算法回收。 一共有两种算法，一种是引用计数算法，每被引用一次计数器就+1，当引用为0就回收，不过这种算法有一个弊端就是，当对象之间互相引用的时候就永远不会回收，所以用的最多的还是GC ROOTS可达性分析，看对象是否被GC ROOTS引用，那么哪些可以作为GC ROOTS呢？有以下四种：1.栈里面的局部变量表，方法区的2.类静态属性引用的对象3.方法区中常量引用的对象，4.JNI本地变量栈中引用的对象http://www.importnew.com/13493.html]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存分配]]></title>
    <url>%2FmyBlog%2F2017%2F07%2F13%2FJVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1.程序计数器（PCR）可以看做当前线程所执行的字节码的行号指示器。为了线程切换后能够恢复到正确执行位置，每条线程都需要独立的程序计数器。 2.栈（JVM stack）线程私有，生命周期与线程相同。描述的事Java方法执行的内存模型：每个方法执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接方法出口。每个方法执行到完成，对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 3.本地方法栈（Native Method Stack）与JVM栈相似，本地方法栈是用的是虚拟机的native方法 4.堆（heap)是Java虚拟机管理内存中最大的一块。是被所有线程共享的一块内存区域，次内存区域唯一目的是存放对象实例，几乎所有的对象及数组都要在这里分配内存。是垃圾回收器管理的主要区域，因此很多时候也被称作“GC堆”。现在收集器采用分代收集算法，所以Java堆还可以细分为：新生代，老年代； 5.方法区（Method）域Java堆一样。是各个线程共享的内存区域，用于存储虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。 6.运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件不仅有类的版本，字段，方法，接口描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用。 7.直接内存（Direct Memory）不是虚拟机运行数据区的一部分。NIO（New Input/Output）类，引入一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存。通过一个Java堆DirectByteBuffer对象作为这块内存的引用进行操作。显著提高性能，因为避免了Java堆和Native堆来回复制数据。 栈区：每次方法的执行都会有一次栈帧的生成，并且其中有局部变量表。堆区：每次new出来的对象都保存在这儿。本地方法栈：通过C/C++调用系统接口的一些方法。方法区：类的信息 静态变量都在这儿，还有程序计数器]]></content>
      <categories>
        <category>NoteBook</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
